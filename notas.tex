%        File: notas.tex
%     Created: seg fev 18 09:00  2019 -0
% Last Change: seg fev 18 09:00  2019 -0
%

\documentclass[a4paper]{article}

\usepackage[margin=1.3in]{geometry}

\usepackage{amsfonts}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\usepackage{epigraph}

\usepackage{color}   %May be necessary if you want to color links
\usepackage{xcolor}

\definecolor{platinum}{rgb}{0.9, 0.89, 0.89}

\usepackage{listings}
\lstset{
	basicstyle=\tt\footnotesize,
	backgroundcolor=\color{platinum}
	%keywordstyle=\color{blue},
	%stringstyle=\color{red}
}	

\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks=true, %set true if you want colored links
	linkcolor=black,
	linktoc=all
}

\newtheorem{exercicio}{Exercício}

\begin{document}

\title{Programação Funcional}
\author{Luiz Alberto do Carmo Viana}

\maketitle

\begin{abstract}
	Notas de aula para a disciplina de Programação Funcional, ministrada no curso de Ciência da Computação, no campus da UFC em Crateús.
\end{abstract}

\tableofcontents

\pagebreak

\section{Introdução}

Programar computadores é uma atividade que pode ser bastante prazeroza.
Testar programas de computador, a fim de garantir que funcionem adequadamente,
já não é tão agradável (ao menos para mim).

A crescente complexidade dos ambientes computacionais traz consigo linguagens de
programação cada vez mais sofisticadas, dotadas de recursos necessários para
lidar com os avanços técnicos dos computadores.
Atualmente, por exemplo, é bastante comum nos depararmos com computadores
dotados de múltiplos processadores ou \emph{cores}.
Para tirar proveito desse recurso, é preciso escrever programas que executem
instruções em paralelo, com o auxílio de linguagens que forneçam os meios para
lidar com os vários \emph{cores} do processador.

Se considerarmos que \emph{debugar} um programa simples já é desafiador, o que
podemos dizer sobre corrigir um programa que executa, simultaneamente,
diferentes instruções em alguns processadores?
Uma vez que pudéssemos demonstrar a corretude do nosso programa, não haveria a
preocupação de testá-lo, e assim esse problema desapareceria completamente.

O paradigma de Programação Funcional propõe o desenvolvimento de linguagens de
programação que se aproximem o máximo possível da linguagem matemática.
Essa escolha de \emph{design} facilita a demonstração da corretude de um
programa funcional, que não precisa ser testado.
Dessa forma, o paradigma em estudo ganha bastante adequação para o
desenvolvimento de programas que lidam com ambientes computacionais complexos.

\section{Ferramentas}

Nestas notas de aula, usaremos a linguagem de programação Haskell, na dsitribuição Linux de sua preferência.
Admitimos, naturalmente, o uso do compilador GHC (Glasgow Haskell Compiler), e esperamos que sua versão
seja a 8.4.4.
Você pode conferir a versão instalada com o comando \texttt{ghci} (falaremos mais a respeito dele no futuro), que deve
produzir uma saída como esta.

\begin{lstlisting}[language=bash, frame=single]
$ ghci
GHCi, version 8.6.3: http://www.haskell.org/ghc/
Prelude> 
\end{lstlisting}

Existem diversas formas de se obter o GHC.
Você pode tentar instalá-lo pelo gerenciador de pacotes da sua distribuição, ou tentar baixá-lo pelo site oficial.
Recomendamos o uso do ghcup, que costuma instalar a versão mais recente do compilador.

\section{Programando em Haskell}

Aqui, reimplementamos as funções básicas de Haskell com o propósito de entender seu funcionamento.
Isso também nos permite ganhar familiaridade com a linguagem e sua sintaxe, além de nos expor, aos poucos, às suas características.

Vamos desenvolver nossa reimplementação utilizando uma divisão em módulos mais simplificada que a estrutura modular oficial.
Usaremos os seguintes arquivos:
\begin{itemize}
	\item \texttt{Bool.hs}: aqui se encontram as funções relacionadas a operações com valores booleanos;
	\item \texttt{BSTree.hs}: contém as definições da estrutura de árvore binária de busca;
	\item \texttt{Either.hs}: implementa valores disjuntivos e funções para seu manuseio;
	\item \texttt{Functions.hs}: apresenta as operações elementares para o reuso de funções;
	\item \texttt{Graph.hs}: define algumas funções para manipulação de grafos;
	\item \texttt{Heap.hs}: implementação de uma fila de prioridade mínima;
	\item \texttt{InfinityTree.hs}: árvore binária infinita, isto é, sem folhas;
	\item \texttt{List.hs}: elenca diversas funções para o tratamento de listas;
	\item \texttt{Maybe.hs}: define um tipo para representação de falha, assim como facilidades para o seu manuseio;
	\item \texttt{Memo.hs}: traz funções que implementam memoização;
	\item \texttt{SeqTree.hs}: contém as definições de uma estrutura arbórea simples para a representação de sequências.
\end{itemize}

\subsection{Trabalhando com listas}

Iniciamos nossos estudos da linguagem Haskell tratando de um tipo composto que é clássico para o paradigma funcional: a \emph{lista}.
A lista é caracterizada por ser uma estrutura linear que contém elementos de um único tipo.
Uma lista é uma estrutura que pode ou ser \emph{vazia} ou ter uma \emph{cabeça} (composta de um único elemento) e uma \emph{cauda} (uma outra lista, contendo o mesmo tipo de elemento).

Vamos criar um arquivo \texttt{List.hs} com o seguinte conteúdo inicial.
Este indica que iremos trabalhar com algumas definições de Prelude, bem como iremos fazer uso de conceitos definidos em outros módulos.

\begin{lstlisting}[language=haskell, frame=single]
module List where

import Prelude (
	Eq, Num, Int, Char, Bool(True, False),
	(+), (-), (*), (<=), (==), (/=), error,
	Functor(fmap), (<$>), Applicative(pure, (<*>)),
	seq)

import Control.Applicative (Alternative(empty, (<|>)))

import Bool
import Functions
import Maybe 
\end{lstlisting}

Iniciamos nossas implementações com uma operação muito básica: determinar o comprimento de uma lista.
Dada sua natureza recursiva, podemos aproveitar a estrutura de uma lista para calcular recursivamente seu comprimento.

\begin{lstlisting}[language=haskell, frame=single]
length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + length xs
\end{lstlisting}

Vamos entender o código acima por partes.
A primeira linha determina a assinatura da função \texttt{length}, que recebe uma lista de elementos do tipo \texttt{a} (pode ser um tipo qualquer), e retorna um elemento do tipo \texttt{Int}, isto é, um inteiro.
Em Haskell, uma lista vazia é representada por \texttt{[]}.
Intuitivamente, sabemos que uma lista vazia tem 0 elementos, e dizemos isso na segunda linha.
Esse é o nosso caso base.
Quando tomamos uma lista não vazia, sabemos que ela tem cabeça e cauda.
Em Haskell, representamos uma lista não vazia como \texttt{(x:xs)}, que tem cabeça \texttt{x} e cauda \texttt{xs}.
Essa lista tem um elemento \texttt{x}, e esse ``um" precisa ser somado à quantidade de elementos da cauda \texttt{xs} (computada recursivamente, já que \texttt{xs} é uma lista).
Agora vamos testar nosso código.

Antes de aprendermos a utilizar o compilador (comando \texttt{ghc}), vamos nos habituar a testar nosso código no interpretador (comando \texttt{ghci}).
Vamos para o diretório onde está \texttt{List.hs} e executamos o seguinte.

\pagebreak

\begin{lstlisting}[language=bash, frame=single]
$ ghci                                                                      
GHCi, version 8.6.3: http://www.haskell.org/ghc/                                        
Prelude> :l List                                                                                   
[1 of 1] Compiling List                                                    
Ok, one module loaded.                                                                             
*List> length [1,2,4]                                                                              
3                                                                                                  
*List> :q                                                                                          
Leaving GHCi.               
\end{lstlisting}

Como podemos ver, carregamos o arquivo no interpretador utilizando \texttt{:l List} (note que não precisamos escrever a extensão do arquivo).
Quando passamos uma lista com três elementos, \texttt{length} responde de acordo.
Para sair do interpretador, utilizamos \texttt{:q}.

Agora que entendemos o básico de como utilizar o interpretador, vamos nos concentrar em desenvolver outras funções.
A função \texttt{null}, por exemplo, determina se uma lista é vazia ou não.

\begin{lstlisting}[language=haskell, frame=single]
null :: [a] -> Bool
null [] = True
null (x:xs) = False
\end{lstlisting}

Recomendamos carregar \texttt{List.hs} no interpretador e fazer alguns testes.
Não deve ser difícil entender que \texttt{null} recebe uma lista contendo elementos de um tipo qualquer e retorna um valor booleano (verdadeiro para listas vazias).

Vamos agora criar duas funções para acessar as componentes do tipo lista: cabeça e cauda.

\begin{lstlisting}[language=haskell, frame=single]
head :: [a] -> a
head [] = error "head: empty list"
head (x:_) = x
\end{lstlisting}

Temos duas coisas novas no trecho de código acima.
Primeiro, como não podemos retornar a cabeça de uma lista vazia, temos de lançar uma exceção.
Isso é feito utilizando a função \texttt{error}, que recebe uma string e lança uma exceção (a assinatura de error é muito interessante).
A segunda coisa ocorre na expressão \texttt{(x:\_)}: o \emph{underline} serve para ignorar o nome de um argumento de função (nesse caso, a cauda de uma lista decomposta).
Como não precisamos mencionar a cauda da lista para retornar sua cabeça, consideramos boa prática não nomeá-la.
Agora definimos a função \texttt{tail}, de forma análoga.

\begin{lstlisting}[language=haskell, frame=single]
tail :: [a] -> [a]
tail [] = error "tail: empty list"
tail (_:xs) = xs
\end{lstlisting}

Podemos entender o par de funções \texttt{head} e \texttt{tail} como duas funções que decompõem uma lista separando seu primeiro elemento.
Intuitivamente, podemos conceber as funções \texttt{last} e \texttt{init}, que decompõem uma lista separando seu último elemento.

\begin{lstlisting}[language=haskell, frame=single]
last :: [a] -> a
last [] = error "last: empty list"
last (x:[]) = x
last (_:xs) = last xs
\end{lstlisting}

Observe que a implementação de \texttt{last} tem três casos, apesar de uma lista ter apenas duas definições: vazia ou com cabeça e cauda.
É preciso tratar o caso de uma lista ter cabeça e uma cauda vazia (uma lista com apenas um elemento) por conta da definição recursiva.
Observe que, se não houvesse o referido caso, a definição recursiva sempre levaria ao lançamento de uma exceção.
Definimos agora \texttt{init}.

\begin{lstlisting}[language=haskell, frame=single]
init :: [a] -> [a]
init [] = error "init: empty list"
init (_:[]) = []
init (x:xs) = x : init xs
\end{lstlisting}

A ocorrência de três casos em \texttt{init} é justificada da mesma forma que em \texttt{last}.
Temos algo novo no caso recursivo: além de \texttt{(:)} ser usado para decompor listas, também pode ser usado para a construção de listas.
Em \texttt{init}, usamos \texttt{(:)} para construir uma lista, a ser retornada, cuja cabeça é \texttt{x} e cuja cauda é o resultado de \texttt{init xs}.

Uma operação usual em listas (e outros tipos compostos lineares) é a \emph{concatenação}, que consiste em tomar duas listas e retornar uma lista maior, resultado de justapor a primeira seguida da segunda.
Vamos implementar essa função como um operador infixo, isto é, como uma função ``binária" (essas aspas serão explicadas posteriormente) que ocorre entre seus argumentos.

\begin{lstlisting}[language=haskell, frame=single]
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : xs ++ ys
\end{lstlisting}

A primeira coisa que observamos é como o operador \texttt{(++)} é definido na assinatura.
Quando definimos a assinatura de operadores, colocamos seu nome entre parênteses.
Quando definimos os casos de um operador, escrevemos seu nome entre seus dois argumentos.
Quanto à definição de \texttt{(++)}, seu primeiro caso é bem simples.
No último caso, definimos que o primeiro elemento da concatenação de duas listas não vazias é justamente o primeiro elemento da primeira lista, e os demais elementos da concatenação são definidos recursivamente.

Para facilitar o uso de \texttt{(++)} em certos contextos, definimos também a função \texttt{concat}, que recebe uma lista de listas e retorna uma lista simples, resultado da sucessiva concatenação das sublistas recebidas.

\begin{lstlisting}[language=haskell, frame=single]
concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss
\end{lstlisting}

Chamamos a atenção para o estilo de nomenclatura utilizado.
Listas simples costumam ter nomes com um único `s' no final, enquanto listas de listas são nomeadas com ``ss" ao final.

Agora definimos como computar o inverso de uma lista.
Nossa primeira tentativa poderia ser algo como o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]
\end{lstlisting}

Essa definição, embora correta, não é a mais eficiente.
Perceba que o operador \texttt{(++)} tem um custo linear em relação ao número de elementos de seu primeiro argumento.
Se, para cada elemento de seu argumento, \texttt{reverse} usa \texttt{(++)}, usaríamos \texttt{(++)} um número linear de vezes.
Como \texttt{(++)} tem custo linear, essa definição de \texttt{reverse} tem custo quadrático (em relação ao número de elementos de seu argumento).

Podemos definir \texttt{reverse} com custo linear (percorrendo seu argumento uma única vez) se fizermos uso de uma função auxiliar, da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
reverse :: [a] -> [a]
reverse xs = f xs [] where
	f [] acc = acc
	f (x:xs) acc = f xs (x:acc)
\end{lstlisting}

Vamos dar um tempo com nosso arquivo \texttt{List.hs} e criar um outro, \texttt{Bool.hs}.
Nosso novo arquivo terá o seguinte conteúdo inicial.

\begin{lstlisting}[language=haskell, frame=single]
module Bool where

import Prelude(Bool(True, False), Applicative(pure))

import Control.Applicative (Alternative(empty))

import Functions
\end{lstlisting}

Infelizmente não poderemos desenvolver nosso próprio tipo booleano, pois diversas funções em Haskell que são implementadas em baixo nível referenciam o tipo booleano usado pelo compilador.
Por isso, importamos o tipo \texttt{Bool} e seus valores a partir de \texttt{Prelude}.

Em \texttt{Bool.hs}, vamos desenvolver duas funções bastante similares a operadores lógicos bem conhecidos.

\begin{lstlisting}[language=haskell, frame=single]
and :: [Bool] -> Bool
and [] = True
and (True:xs) = and xs
and (False:_) = False
\end{lstlisting}

A função \texttt{and} toma uma lista de valores booleanos e retorna um booleano.
Se a lista contém apenas valores \texttt{True}, então ela retorna \texttt{True}.
Do contrário, ela retorna \texttt{False}.
Perceba que, além de decompor a lista em cabeça e cauda, criamos casos de acordo com os possíveis valores da cabeça.
Essas decomposições de tipos em partes (lista em cabeça e cauda), bem como a criação de casos de acordo com os possíveis valores de uma certa parte, são chamadas de \emph{pattern matching}.
A seguir, definimos a função \texttt{or} de forma similar.

\begin{lstlisting}[language=haskell, frame=single]
or :: [Bool] -> Bool
or [] = False
or (True:_) = True
or (False:xs) = or xs
\end{lstlisting}

\begin{exercicio}
	Implemente os operadores \emph{\texttt{(\&\&)}} e \emph{\texttt{(||)}}, ambos com assinatura \emph{\texttt{Bool -> Bool -> Bool}}.
	Esses operadores funcionam de forma análoga a \emph{\texttt{and}} e \emph{\texttt{or}}, respectivamente, mas tomam necessariamente dois valores booleanos como argumentos.
\end{exercicio}

Voltando a editar \texttt{List.hs}, criamos duas operações muito usuais em programação funcional, que consistem em tomar ou descartar prefixos de una lista.
As funções \texttt{take} e \texttt{drop} fazem precisamente isso.

\begin{lstlisting}[language=haskell, frame=single]
take :: Int -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n - 1) xs
\end{lstlisting}

Dado um inteiro \texttt{n}, \texttt{take} retorna um prefixo de comprimento \texttt{n} da lista de entrada (caso essa seja vazia, apenas a lista vazia pode ser retornada como prefixo).
Observe, mais uma vez, o uso de \emph{pattern matching} por valores: o primeiro caso verifica se o inteiro \texttt{n} tem valor 0.
O último caso diz que, se \texttt{n} não é nulo (esperamos que seja positivo), e a lista não é vazia, então sua cabeça certamente faz parte do prefixo a ser retornado. Os \texttt{n - 1} elementos restantes do prefixo são tomados, de forma recursiva, da cauda da lista dada como entrada.

Antes de escrever a função \texttt{drop}, vamos criar um condicional, o que nos permitirá um outro estilo de escrita.
A função \texttt{cond} é bem simples de entender, e ficará escrita em \texttt{Bool.hs}.

\begin{lstlisting}[language=haskell, frame=single]
cond :: Bool -> a -> a -> a
cond True x _ = x
cond False _ y = y
\end{lstlisting}

\begin{lstlisting}[language=haskell, frame=single]
drop :: Int -> [a] -> [a]
drop _ [] = []
drop n xs = cond (n <= 0) xs (drop (n - 1) (tail xs))
\end{lstlisting}

Note que, nesse estilo de escrita, não usamos \emph{pattern matching} para determinar a nulidade de \texttt{n}, nem para atribuir nomes às partes de uma lista não vazia.
Usamos \texttt{cond} para tratar os valores de \texttt{n} (perceba que isso lida inclusive com o caso de \texttt{n} ter valor negativo) e \texttt{tail} para acessar a cauda da lista de entrada (graças ao primeiro caso, sabemos que \texttt{tail} nunca receberá uma lista vazia).

A função \texttt{splitAt} combina os resultados de \texttt{take} e \texttt{drop}. Para isso, ela faz uso de uma \emph{tupla}.

\begin{lstlisting}[language=haskell, frame=single]
splitAt :: Int -> [a] -> ([a], [a])
splitAt n xs = (take n xs, drop n xs)
\end{lstlisting}

Mais uma vez, essa definição simples não é a mais eficiente.
Como é percebido, chamar \texttt{take} e \texttt{drop} com os mesmos argumentos implica em ``passear" pelas mesmas posições da lista duas vezes.
Implementando \texttt{splitAt} independentemente de \texttt{take} e \texttt{drop}, conseguimos resolver esse problema.

\begin{lstlisting}[language=haskell, frame=single]
splitAt :: Int -> [a] -> ([a], [a])
splitAt 0 xs = ([], xs)
splitAt _ [] = ([], [])
splitAt n (x:xs) = (x:ps, qs) where
	(ps, qs) = splitAt (n - 1) xs
\end{lstlisting}

Dessa vez, fizemos uso de \texttt{where} para receber o resultado da chamada recursiva, que é um par.
Assim, podemos usar esse resultado para construir o retorno de \texttt{splitAt} de forma adequada.

Vamos criar nossa primeira função que exigirá uma restrição em sua assinatura.
A função \texttt{isPrefixOf} recebe duas listas, e determina se a primeira é prefixo da segunda.

\begin{lstlisting}[language=haskell, frame=single]
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isPrefixOf [] _ = True
isPrefixOf _ [] = False
isPrefixOf (x:xs) (y:ys) = cond (x == y) (isPrefixOf xs ys) False
\end{lstlisting}

Dessa vez, a função não recebe listas contendo um tipo qualquer.
O tipo dos elementos das listas deve implementar as funções da classe \texttt{Eq}.
Em Haskell, uma \emph{classe} é apenas um grupo de funções.
Um exemplo de classe é \texttt{Eq}, que contém os operadores \texttt{(==)} e \texttt{(/=)}.
Assim, se um tipo é \emph{instância} da classe \texttt{Eq}, podemos usar o operador \texttt{(==)} sobre seus valores.
Em \texttt{isPrefixOf}, isso é necessário para determinar se os elementos da primeira lista são iguais aos primeiros elementos da segunda.

\begin{exercicio}	\label{exercicioIsInfixOf}
	Implemente a função \emph{\texttt{isInfixOf :: Eq a => [a] -> [a] -> Bool}}, que decide se a primeira lista é sublista contínua da segunda.
\end{exercicio}

\begin{exercicio}
	Implemente a função \emph{\texttt{isSubsequenceOf :: Eq a => [a] -> [a] -> Bool}}, que decide se a primeira lista é uma subsequência da segunda, não necessariamente contínua.
\end{exercicio}

Por vezes, queremos percorrer duas listas simultaneamente.
Uma forma de fazer isso é transformar as duas listas numa lista de pares, onde as primeiras e segundas posições vêm, respectivamente, da primeira e da segunda lista.
A função \texttt{zip} faz justamente isso.

\begin{lstlisting}[language=haskell, frame=single]
zip :: [a] -> [b] -> [(a, b)]
zip [] _ = []
zip _ [] = []
zip (x:xs) (y:ys) = (x, y) : zip xs ys
\end{lstlisting}

Vamos apresentar agora as primeiras funções que tomam funções como argumento.
Por ser uma linguagem funcional, o sistema de tipos de Haskell é bastante robusto.
Isso se mostra no fato de que não apenas tipos simples, como \texttt{Int} e \texttt{Bool}, são recebidos e retornados por funções, mas também assinaturas de funções podem ser argumentos ou o valor de retorno de certas funções (funções de \emph{alta ordem}).
Dizemos que, em Haskell, as funções são \emph{habitantes de primeira classe}.

Lembra que a função \texttt{(++)} foi dita ``binária"?
Apesar de parecer que ela recebe dois argumentos, na verdade ela recebe um só.
O seu retorno, no entanto, não é uma lista, e sim uma função.
Em verdade, todas as funções em Haskell recebem apenas um argumento, e são portanto \emph{unárias}.
Particularmente, \texttt{(++)} recebe uma lista \texttt{xs} e retorna uma outra função.
Essa outra função, por sua vez, recebe uma lista \texttt{ys} e  retorna a lista que é a concatenação de \texttt{xs} e \texttt{ys}.
Devemos nos acostumar a ler as assinaturas na forma \texttt{(++) :: [a] -> ([a] -> [a])}.
Dessa forma, uma função é determinada pelo primeiro \texttt{->} de sua assinatura: antes dele, está o tipo de seu único argumento; após ele, o tipo de seu retormo.

Para receber uma função como argumento, escrevemos sua assinatura entre parênteses.
Temos, por exemplo, a função \texttt{takeWhile}.

\begin{lstlisting}[language=haskell, frame=single]
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs) = cond (p x) (x : takeWhile p xs) []
\end{lstlisting}

Note que \texttt{p} é um argumento do tipo \texttt{a -> Bool}.
Dizemos que \texttt{p} é um \emph{predicado}, isto é, uma função que recebe um valor de um certo tipo e retorna um valor booleano.
Por exemplo, tomando a assinatura \mbox{\texttt{(<=) :: Ord a => a -> a -> Bool}}, podemos criar o predicado \texttt{(0<=) :: (Ord a, Num a) => a -> Bool}, cujo argumento é um valor de um tipo numérico ordenável.

A função \texttt{takeWhile} toma um predicado e retorna uma função, que por sua vez toma uma lista e retorna seu maior prefixo cujos elementos satisfazem \texttt{p}.
Seu par é a função \texttt{dropWhile}, que descarta o maior prefixo cujos elementos satisfazem um certo predicado.

\begin{lstlisting}[language=haskell, frame=single]
dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p xs = cond (p (head xs)) (dropWhile p (tail xs)) xs
\end{lstlisting}

Para esse contexto, o análogo da função \texttt{splitAt} se chama \texttt{span}.
A função \texttt{span} combina os resultados de \texttt{takeWhile} e \texttt{dropWhile}, e já devemos ter uma ideia de como implementá-la de forma eficiente.

\begin{lstlisting}[language=haskell, frame=single]
span :: (a -> Bool) -> [a] -> ([a], [a])
span _ [] = ([], [])
span p l@(x:xs) = cond (p x) (x:ps, qs) ([], l) where
	(ps, qs) = span p xs
\end{lstlisting}

Na definição de \texttt{span}, temos mais uma novidade sintática.
Usamos \texttt{@} quando queremos nomear tanto um valor de um tipo composto quanto suas partes.
Nesse caso, usamos \texttt{l@(x:xs)} para indicar que a lista passada como argumento se chama \texttt{l}, e também que sua cabeça e cauda se chamam, respectivamente, \texttt{x} e \texttt{xs}.

Em vez de usar \texttt{@}, poderíamos simplesmente escrever \texttt{x:xs} onde ocorre \texttt{l} na definição do segundo caso.
No entanto, isso construiria uma nova lista igual a \texttt{l}.
Por mais que tivessem a cauda compartilhada, ainda assim haveria algum desperdício de memória, e portanto o uso de \texttt{@} é preferível.

\begin{exercicio}
	Implemente a função \emph{\texttt{insert :: Ord a => a -> [a] -> [a]}} que, dado um elemento de um tipo ordenável e uma lista ordenada, insere o elemento na lista, preservando a ordenação.
\end{exercicio}

\begin{exercicio}
	Implemente a função \emph{\texttt{insertionSort :: Ord a => [a] -> [a]}}, que toma uma lista de elementos ordenáveis e retorna uma versão ordenada dessa lista.
\end{exercicio}

Vamos criar um novo arquivo, \texttt{Functions.hs}, que terá o seguinte conteúdo inicial.

\begin{lstlisting}[language=haskell, frame=single]
module Functions where

import Prelude (Applicative(pure, (*>)), Monad((>>=)), seq)
\end{lstlisting}

Nele, definimos algo crucial para a expressividade e reuso em programação funcional: a composição de funções.
Em Haskell, como era de se esperar, a composição de funções também é uma função.

\begin{lstlisting}[language=haskell, frame=single]
comp :: (b -> c) -> (a -> b) -> a -> c
comp f g x = f (g x)

(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = comp f g
\end{lstlisting}

Definimos \texttt{comp} para determinar a composição como uma função.
Em seguida, definimos a composição como o operador \texttt{(.)}, que toma duas funções e retorna uma função (o resultado de passar \texttt{g} para a função retornada por \texttt{comp f}).

\begin{exercicio}
	Implemente a função \emph{\texttt{replicate :: Int -> a -> [a]}} que, dado um inteiro não-negativo \emph{\texttt{n}} e um elemento \emph{\texttt{x}}, cria uma lista de \emph{\texttt{n}} elementos, todos iguais a \emph{\texttt{x}}.
	Note que \emph{\texttt{replicate}} pode ser definida como uma composição de \emph{\texttt{take}} e \emph{\texttt{repeat}}, essa última função proposta na Subseção \ref{lab2}.
\end{exercicio}

Uma função bastante comum de ser composta com predicados é a função \texttt{not}.
Sua descrição não exige explicações, e é escrita em \texttt{Bool.hs}.

\begin{lstlisting}[language=haskell, frame=single]
not :: Bool -> Bool
not True = False
not False = True
\end{lstlisting}

Voltando a editar \texttt{List.hs}, podemos agora definir a função \texttt{break}, cujo comportamento se assemelha ao de \texttt{span}.
No entanto, \texttt{break} nega o predicado antes de particionar a lista recebida.

\begin{lstlisting}[language=haskell, frame=single]
break :: (a -> Bool) -> [a] -> ([a], [a])
break p xs = span (not . p) xs
\end{lstlisting}

Além de trabalhar apenas tomando prefixos de listas, é perfeitamente plausível que haja uma função que filtre uma lista com base em um predicado.
Essa função costuma ser chamada de \texttt{filter}.

\begin{lstlisting}[language=haskell, frame=single]
filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) = cond (p x) (x:xs') xs' where
	xs' = filter p xs
\end{lstlisting}

Apesar de todas as funções em Haskell serem unárias, conseguimos ``simular" funções com mais argumentos retornando outras funções unárias para receber os argumentos restantes.
Essa, no entanto, não é a única forma de fazer isso.
Como tuplas são tipos compostos, podemos criar funções unárias que recebem uma tupla como seu único argumento, e assim poderíamos tratar cada posição da tupla recebida como um argumento independente.
Quando usamos a primeira forma de ``simular" mais de um argumento, estamos usando \emph{curried functions} (como Curry é um sobrenome, uma tradução desse termo seria provavelmente tosca).
Quando utilizamos tuplas para o mesmo fim, criamos \emph{uncurried functions}.

\emph{Curried functions} costumam tornar a escrita em Haskell mais expressiva, permitindo um uso mais flexível das funções.
No entanto, algumas situações podem tornar desejável que certas funções não sejam aplicadas parcialmente, e daí as \emph{uncurried functions} ganham justificativa.
Nesse sentido, definimos a função \texttt{uncurry}, que recebe uma \emph{curried function} ``binária" e retorna a \emph{uncurried function} equivalente.
Ela deve ser escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y
\end{lstlisting}

Ironicamente, a função \texttt{uncurry} deve ser aplicada parcialmente para que retorne a \emph{uncurried function} correspondente ao seu argumento.
Assim, \texttt{uncurry (+)} seria equivalente a \texttt{(+)}, mas não permitiria aplicações parciais (como \texttt{(1+)}).
Para tornar \emph{uncurried} funções com mais de dois argumentos, seria preciso escrever a versão de \texttt{uncurry} apropriada.

\subsection{Abstraindo o conceito de \emph{loop}}

Vimos anteriormente a função \texttt{filter}, que filtra os elementos de uma lista conforme um predicado.
Em uma linguagem imperativa, teríamos usado um \emph{loop} (como um \emph{for}) e um condicional para obter um resultado similar.
Em Haskell, as diversas formas de se tratar o conteúdo de uma lista devem ser suficientes para fazer tudo que é possível com o auxílio de \emph{loops}.

A função \texttt{map} transforma o conteúdo de uma lista de acordo com uma função.
Ela pode ser implementada como segue, e sua definição será escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs
\end{lstlisting}

\begin{exercicio}
	Implemente a função \emph{\texttt{inits :: [a] -> [[a]]}}, que retorna todos os prefixos da lista dada como entrada.
\end{exercicio}

\begin{exercicio}
	Implemente a função \emph{\texttt{tails :: [a] -> [[a]]}}, que retorna todos os sufixos da lista dada como entrada.
\end{exercicio}

Caso \texttt{f} tivesse mais argumentos, a função \texttt{map} não serviria.
A função \texttt{zipWith} segue a mesma lógica de \texttt{map}, mas é usada para funções com ``dois" argumentos.
Também será escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f [] _ = []
zipWith f _ [] = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
\end{lstlisting}

Podemos inclusive utilizar \texttt{zipWith} para implementar \texttt{zip} como uma aplicação parcial usando \texttt{(,) :: a -> b -> (a, b)}.
Voltamos ao nosso arquivo \texttt{List.hs} e reescrevemos \texttt{zip} como segue.

\begin{lstlisting}[language=haskell, frame=single]
zip :: [a] -> [b] -> [(a, b)]
zip = zipWith (,)
\end{lstlisting}

Até agora, nossas funções tomam listas como argumentos e retornam listas, sejam estas sublistas ou transformações da lista de entrada.
Por vezes, é desejável fazer uma computação que envolva todos os elementos da lista.
Um somatório, por exemplo, tomaria uma lista de valores de um tipo numérico e retornaria um único valor desse tipo.
Em Haskell, o ato de transformar todos os elementos de uma lista \texttt{[a]} em um único elemento de um tipo \texttt{b} é chamado \emph{folding}, e costuma ser realizado com o auxílio de uma função.

Podemos começar a ``dobrar" os elementos de uma lista a partir de qualquer uma de suas duas extremidades.
A função \texttt{foldl} começa pela esquerda, emquamto \texttt{foldr} começa pela direita.
Manteremos a definição de ambas em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f acc [] = acc
foldl f acc (x:xs) = foldl f (f acc x) xs
\end{lstlisting}

Vamos explicar o que \texttt{foldl} está fazendo.
No caso base, não há elementos da lista para ``dobrar" e \texttt{foldl} retorna o acumulador, o argumento responsável por guardar o resultado das ``dobras" já feitas.
No segundo caso, a lista não está vazia, e \texttt{foldl} ``dobra" a cabeça da lista usando a função \texttt{f} para atualizar o acumulador, e o resultado é passado como acumulador para a chamada recursiva.

Uma coisa importante de se notar é que a definição recursiva de \texttt{foldl} é apenas uma chamada de \texttt{foldl}.
Funções com essa propriedade são ditas \emph{recursivas por cauda}, e são eficientes no uso de memória, devido a otimizações que os compiladores modernos são capazes de fazer. Agora definimos \texttt{foldr}.

\begin{lstlisting}[language=haskell, frame=single]
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f acc [] = acc
foldr f acc (x:xs) = f x (foldr f acc xs)
\end{lstlisting}

Não deve ser difícil perceber que a definição de \texttt{foldr} retorna um valor de um tipo como é proposto na assinatura.
O mais intrigante é entender como \texttt{foldl} e \texttt{foldr} ``dobram" os elementos na ordem que cada uma propõe.
Isso está relacionado à forma como a função \texttt{f} é utilizada.
Em \texttt{foldl}, \texttt{f} é usada para calcular um argumento de uma chamada de \texttt{foldl}, e como a definição recursiva é essencialmente essa chamada, \texttt{x} é o primeiro elemento da lista a ser computado por \texttt{f}.
Já em \texttt{foldr}, a definição recursiva tem seu resultado dado por uma chamada de \texttt{f}, cujo segundo argumento é dado por \texttt{foldr}, dessa vez aplicada à cauda. Assim, se o retorno de \texttt{f} for totalmente dependente de seu segundo argumento, \texttt{x} será o último elemento da lista a ser computado por \texttt{f}, uma vez que a chamada recursiva de \texttt{foldr} ocorrerá antes, e irá tratar de todos os elementos da cauda \texttt{xs}.

Como exemplos do uso de \texttt{foldl}, podemos descrever as seguintes funções em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
sum :: Num a => [a] -> a
sum = foldl (+) 0 
\end{lstlisting}

\begin{lstlisting}[language=haskell, frame=single]
prod :: Num a => [a] -> a
prod = foldl (*) 1 
\end{lstlisting}

Para ilustrar o uso de \texttt{foldr}, podemos reescrever \texttt{filter} da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
filter :: (a -> Bool) -> [a] -> [a]
filter p xs = foldr f [] xs where
	f x ys = cond (p x) (x:ys) ys
\end{lstlisting}

Note como a definição de \texttt{f} se assemelha à definição anterior de \texttt{filter}.
Perceba que, pela definição de \texttt{foldr}, \texttt{ys} pode ser vista como a cauda já filtrada de acordo com \texttt{p}.
Além disso, como o retorno de \texttt{f} (uma lista) não depende totalmente de \texttt{ys} (caso \texttt{p x == True}, a cabeça não é elemento de \texttt{ys}), \texttt{foldr} não cumpre o seu papel.
Ela sempre o cumpriria em uma linguagem de \emph{avaliação estrita}, isto é, numa linguagem em que a computação dos argumentos precede a chamada da função.

Aparentemente falha por conta das características de Haskell, \texttt{foldr} faz algo que \texttt{foldl} não pdoe fazer: o retorno parcial de seu resultado.
Isso é notável quanto ao retorno de listas: \texttt{foldl}, por ser recursiva por cauda, precisa computar a lista inteira antes de poder retornar seu primeiro elemento, enquanto \texttt{foldr} disponibiliza os elementos tão logo estejam computados.
O impacto disso fica evidente com o auxílio desta definição de \texttt{takeWhile}, que deixaremos escrita em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile p xs = foldr f [] xs where
	f x ys = cond (p x) (x:ys) []
\end{lstlisting}

Perceba que há uma única diferença dessa definição de \texttt{takeWhile} para a definição de \texttt{filter}.
Suponha que apenas os três primeiros elementos de uma lista satisfaçam um certo predicado.
\texttt{foldr} verificaria apenas os quatro primeiros elementos, não importa o tamanho da lista, enquanto que operações semelhantes com \texttt{foldl} precisariam percorrer a lista toda, pelo fato de \texttt{foldl} ser recursiva por cauda.

\begin{exercicio}
	Implemente as funções \emph{\texttt{and}}, \emph{\texttt{or}} e \emph{\texttt{map}} como chamadas de \emph{\texttt{foldr}}.
\end{exercicio}

\begin{exercicio} \label{exercicio:iterate}
	Um outro conceito de \emph{loop} é a iteração, que consiste em, dada uma função e um elemento inicial, aplicar a função a esse elemento, e repetir esse processo com o resultado dessa aplicação.
	Implemente a função \emph{\texttt{iterate :: (a -> a) -> a -> [a]}} que, dados uma função \emph{\texttt{f}} e um elemento \emph{\texttt{x}}, cria uma lista infinita com os resultados de sucessivas aplicações de \emph{\texttt{f}} em \emph{\texttt{x}}, isto é, \emph{\texttt{iterate f x == [x, f x, f (f x), \dots]}}.
	Perceba que \emph{\texttt{iterate}} não é muito útil por si só.
\end{exercicio}

\subsection{Usando tipos para o tratamento de erros}

Vimos anteriormente que \texttt{error} é capaz de indicar erros de execução, interrompendo o fluxo usual do programa com o lançamento de uma exceção.
No entanto, \texttt{error} não nos dá a oportunidade de tratar esses erros, muito menos fornece uma forma simples de indicar que uma função pdoe falhar.
Ao lermos a assinatura de \texttt{head}, por exemplo, nada nos diz que existe a chance de ela lançar uma exceção.
Vamos criar um tipo justamente com o propósito de representar uma computação que pode falhar.

Criamos o arquivo \texttt{Maybe.hs} com o conteúdo inicial a seguir.

\begin{lstlisting}[language=haskell, frame=single]
module Maybe where

import Prelude (Bool(True, False),
                Functor(fmap),
                Applicative((<*>)),
                Monad((>>=)))

import Bool
import Functions

data Maybe a = Nothing | Just a
\end{lstlisting}

Aqui, temos o primeiro uso de \texttt{data}, que serve para a definição de um tipo.
Criamos o tipo \texttt{Maybe} que, dado um tipo \texttt{a} como argumento, representa um conjunto de valores em dois casos: \texttt{Maybe a} pode estar vazio (\texttt{Nothing}) ou pode conter um único valor do tipo \texttt{a} (\texttt{Just a}).
A possibilidade de \texttt{Maybe a} conter nenhum valor do tipo \texttt{a} nos permite representar uma falha com \texttt{Nothing}, pois se uma computação não é bem sucedida, ela produz nenhum valor.

Como exemplo de seu uso, podemos importar o módulo \texttt{Maybe} em \texttt{List.hs} e definir versões bem comportadas de \texttt{head} e \texttt{tail}.

\begin{lstlisting}[language=haskell, frame=single]
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (_:xs) = Just xs
\end{lstlisting}

\begin{exercicio}
	Implemente a função \emph{\texttt{uncons :: [a] -> Maybe (a, [a])}} que, dada uma lista, retorna uma tupla composta, respectivamente, por sua cabeça e sua cauda.
	Note que a função \emph{\texttt{uncons}} evita lançar uma exceção caso receba uma lista vazia.
\end{exercicio}

Vemos que \texttt{safeHead} e \texttt{safeTail} não lançam exceções, mas representam seus casos falhos retornando \texttt{Nothing}.
É sempre preferível usar o sistema de tipos para tratar os erros, em vez de apenas lançar uma exceção.
Como a validação dos tipos de um programa é feita em tempo de compilação, o compilador consegue nos dizer se todas as possibildiades de erro estão tratadas antes de executarmos nosso programa.

Vamos agora desenvolver um aparato para facilitar o tratamento de valores do tipo \texttt{Maybe a}.
Os seguintes predicados são úteis para facilitar futuras definições.

\begin{lstlisting}[language=haskell, frame=single]
isNothing :: Maybe a -> Bool
isNothing Nothing = True
isNothing _ = False

isJust :: Maybe a -> Bool
isJust = not . isNothing
\end{lstlisting}

Agora definimos a função \texttt{maybe}.

\begin{lstlisting}[language=haskell, frame=single]
maybe :: b -> (a -> b) -> Maybe a -> b
maybe y f Nothing = y
maybe _ f (Just x) = f x
\end{lstlisting}

Pela assinatura de \texttt{maybe}, podemos entender seu objetivo.
A função \texttt{maybe} recebe um valor do tipo \texttt{b} e uma função \texttt{f}, além de um valor do tipo \texttt{Maybe a}.
Com a ajuda de \texttt{y}, \texttt{maybe} consegue tratar uma possível falha em seu ``terceiro" argumento: caso esse seja \texttt{Nothing}, \texttt{y} é retornado como um valor padrão; caso contrário, \texttt{x} é aplicado a \texttt{f} para produzir o valor de retorno.

Perceba ainda que \texttt{maybe} é feita para ser aplicada parcialmente.
Uma vez aplicados \texttt{y} e \texttt{f}, \texttt{maybe} retorna uma versão de \texttt{f} que tolera falhas em seu argumento.

\begin{lstlisting}[language=haskell, frame=single]
fromMaybe :: a -> Maybe a -> a
fromMaybe y Nothing = y
fromMaybe _ (Just x) = x
\end{lstlisting}

A função \texttt{fromMaybe} também serve para definir um valor padrão em caso de falha, mas de forma mais simples.
Por não receber uma função, é útil para definir valores padrão quando um valor do tipo \texttt{Maybe a} deveria ser usado em uma expressão.

\begin{lstlisting}[language=haskell, frame=single]
catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (Nothing:xs) = catMaybes xs
catMaybes ((Just x):xs) = x : catMaybes xs
\end{lstlisting}

A função \texttt{catMaybes} remove os valores \texttt{Nothing} de uma lista de elementos do tipo \texttt{Maybe a}, enquanto também extrai os valores agregados aos \texttt{Just}.

\begin{lstlisting}[language=haskell, frame=single]
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
mapMaybe f = catMaybes . map f
\end{lstlisting}

Por fim, a função \texttt{mapMaybe} transforma uma lista de elementos do tipo \texttt{a} usando uma função que pode falhar, e em seguida remove as transformações que falharam.
Repare como a divisão entre esses dois passos é evidenciada com \texttt{(.)}, e mais uma vez, a composição de funções promove o reuso de código.

\subsection{Representando valores disjuntivos}

Nesta subseção, implementamos o tipo \texttt{Either a b}, cujos valores representam uma disjunção entre valores dos tipos \texttt{a} e \texttt{b}.
Escrevemos suas definições em \texttt{Either.hs}, que tem o seguinte conteúdo inicial.

\begin{lstlisting}[language=haskell, frame=single]
module Either where

import Prelude (Bool(True, False))

import Bool
import Functions

data Either a b = Left a | Right b
\end{lstlisting}

Por vezes, percebe-se o uso de \texttt{Either} apenas como um \texttt{Maybe} ``informativo'', já que \mbox{\texttt{Either [Char] b}} pode representar um erro com \texttt{Left [Char]}, permitindo uma string que o descreva.
Esse, no entanto, é um uso muito limitado de \texttt{Either}, que facilita a descrição de alguns algoritmos.

Desenvolvemos facilidades para a manipulação de \texttt{Either}.
As funções que seguem são escritas também em \texttt{Either.hs}.

\begin{lstlisting}[language=haskell, frame=single]
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left x) = f x
either _ g (Right y) = g y
\end{lstlisting}

A função \texttt{either} toma duas funções para ``resolver'' a disjunção provocada por \texttt{Either}.
É irresistível traçar uma analogia com construções como \emph{switch} e \emph{case}, típicas de linguagens procedurais.
No entanto, o \emph{switching} não ocorre entre valores de um certo tipo, mas sim entre dois tipos.

\begin{lstlisting}[language=haskell, frame=single]
lefts :: [Either a b] -> [a]
lefts [] = []
lefts (Left x : xs) = x : lefts xs
lefts (Right _ : xs) = lefts xs

rights :: [Either a b] -> [b]
rights [] = []
rights (Left _ : xs) = rights xs
rights (Right x : xs) = x : rights xs
\end{lstlisting}

A função \texttt{lefts} (\texttt{rights}) filtra os elementos de tipo \texttt{a} (\texttt{b}) e os retorna em uma lista.
Usa-se \emph{pattern matching} para isso, e as definições são imediatas.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
isLeft :: Either a b -> Bool
isLeft (Left _) = True
isLeft _ = False

isRight :: Either a b -> Bool
isRight = not . isLeft
\end{lstlisting}

As definições de \texttt{isLeft} e \texttt{isRight} são elementares.
Partimos para as próximas definições.

\begin{lstlisting}[language=haskell, frame=single]
fromLeft :: a -> Either a b -> a
fromLeft _ (Left x) = x
fromLeft x (Right _) = x

fromRight :: b -> Either a b -> b
fromRight x (Left _) = x
fromRight _ (Right x) = x
\end{lstlisting}

As funções \texttt{fromLeft} e \texttt{fromRight} retornam valores padrão caso não recebam o caso correspondente, do contrário retornam o valor nele contido.

\begin{exercicio}
	Implemente a função \emph{\texttt{partitionEithers :: [Either a b] -> ([a], [b])}}.
\end{exercicio}

\subsection{Árvores binárias de busca}

Em programação funcional, definimos o conceito das operações sem levar em conta como seria sua implementação na arquitetura que utilizamos.
Isso é suficiente para caracterizar as linguagens desse paradigma como de alto nível, o que lhes confere muita expressividade, já que a escrita de código não menciona detalhes alheios à lógica das definições.
Há, no entanto, um preço a se pagar por essa característica.

Por se distanciar dos detalhes da arquitetura e abordar a programação por um viés matemático, as linguagens funcionais não têm contato com estruturas de dados cujo conceito é dependente da arquitetura.
É o caso, por exemplo, dos \emph{arrays}, que são dotados de acesso em tempo constante a qualquer uma de suas posições.
Uma lista, por outro lado, garante apenas acesso em tempo linear a seus elementos, o que é uma desvantagem séria.
Para garantir a eficiência dos programas funcionais, é preciso construir uma estrutura de dados que alivie esse problema.

Vamos criar um arquivo \texttt{BSTree.hs}, que conterá as definições necessárias para o uso de árvores binárias de busca.
Apesar de não terem acesso em tempo constante a seus elementos, mas apenas em tempo logarítmico (quando balanceadas), elas proporcionam um tempo de acesso muito superior ao das listas.
É verdade que esse tempo de acesso ainda não é tão bom quanto o de um \emph{array}, mas é eficiente o bastante (e o obtemos sem nos incomodar com detalhes da arquitetura).

\begin{lstlisting}[language=haskell, frame=single]
module BSTree where

import Prelude (Ord, Ordering(LT, EQ, GT), compare,
                Eq, (==),
                Bool(True, False),
                Functor(fmap)
               )

import Bool
import Functions ((.))
import Maybe

data BSTree k v = Empty
                | Branch (k, v) (BSTree k v) (BSTree k v)
\end{lstlisting}

Isso define uma árvore binária de busca, com chaves do tipo \texttt{k} e valores do tipo \texttt{v}.
Temos dois casos para nossa árvore: ela pode ser vazia (\texttt{Empty}) ou pode ser ramificada (\texttt{Branch}), contendo um par de chave e valor (\texttt{(k, v)}) e duas sub-árvores, sendo assim definida recursivamente.

Estamos definindo um \emph{tipo parametrizado}, isto é, um tipo que precisa de outros tipos para estar completo.
Apenas \texttt{BSTree} não é um tipo bem definido.
Para completar a definição desse tipo, é preciso informar que tipo servirá de chave (\texttt{k}) e que tipo servirá de valor (\texttt{v}).
Como exemplo, \texttt{BSTree Int [Char]} é uma árvore binária de busca chaveada por inteiros e valorada por strings.
A lista, inclusive, é outro tipo parametrizado, já que precisa determinar o tipo de seus elementos para estar bem definida.
O tipo \texttt{Maybe a} também ilustra o uso de um parâmetro para a definição de um tipo.

Vamos escrever uma função que retorna uma árvore vazia.
Faremos com que este seja o único modo de criar uma \texttt{BSTree} fora desse módulo.

\begin{lstlisting}[language=haskell, frame=single]
empty :: BSTree k v
empty = Empty
\end{lstlisting}

É apenas isso.
Basta retornar o valor do primeiro caso.
Agora, definimos como deve ocorrer uma inserção em nossa árvore.

\begin{lstlisting}[language=haskell, frame=single]
insert :: Ord k => BSTree k v -> (k, v) -> BSTree k v
insert Empty (key', val') = Branch (key', val') empty empty
insert bst@(Branch (key, val) ltree rtree) (key', val') =
	decide (compare key' key) where
		decide LT = Branch (key, val) ltree' rtree
		decide EQ = bst
		decide GT = Branch (key, val) ltree rtree'
		ltree' = insert ltree (key', val')
		rtree' = insert rtree (key', val')
\end{lstlisting}

No seu primeiro caso, \texttt{insert} transforma uma árvore vazia em uma árvore ramificada com as duas sub-árvores vazias.
No segundo caso, é preciso tratar a inserção de forma a preservar as invariantes de uma árvore binária de busca: não pode haver chaves duplicadas e todas as chaves contidas na sub-árvore esquerda (direita) devem ser menores (maiores) que a chave presente na raiz.
A função auxiliar \texttt{decide} compara a chave a ser inserida (\texttt{key'}) com a chave da raiz (\texttt{key}) por meio de \texttt{compare}, que por sua vez retorna um valor do tipo \texttt{Ordering}: \texttt{LT} (\emph{less than}), \texttt{EQ} (\emph{equals}) ou \texttt{GT} (\emph{greater than}).
Caso \texttt{decide} receba \texttt{EQ}, a nova chave é duplicada e retorna-se \texttt{bst}, o que não modifica a árvore.
Caso \texttt{decide} receba \texttt{LT} (\texttt{GT}), a operação de inserção é feita recursivamente na sub-árvore esquerda (direita), conforme a definição de \texttt{ltree'} (\texttt{rtree'}).

Note como a preguiça de Haskell afeta a definição de \texttt{insert}.
Apesar de ambas \texttt{ltree'} e \texttt{rtree'} estarem definidas, no máximo uma delas será computada.
Isso ocorre porque, em todos os três casos, no máximo uma delas é utilizada para definir o retorno.

Além disso, é preciso chamar a atenção para a natureza \emph{imutável} dos valores de tipos em Haskell.
Uma função nunca altera o valor associado aos identificadores de seus argumentos.
Dessa forma, \texttt{insert} não altera a árvore recebida, mas retorna uma nova árvore com o par de chave e valor inserido.

A propriedade de que valores associados a identificadores são imutáveis não quer dizer que uma implementação de Haskell seja necessariamente um desastre em termos de consumo de memória.
Como os valores são imutáveis, não há prejuízo em tipos compostos (como listas e árvores) partilharem alguns de seus campos, como listas partilharem caudas ou árvores partilharem sub-árvores, já que essas partes em comum nunca serão alteradas.
A imutabilidade, inclusive, permite que um compilador pratique otimizações muito agressivas, mesmo em programas com múltiplas \emph{threads}.

Definimos agora uma forma de consultar um valor do tipo \texttt{BSTree k v}.
A função \texttt{lookup} toma uma árvore e uma chave, e verifica se a árvore contém a chave.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
lookup :: Ord k => BSTree k v -> k -> Maybe v
lookup Empty _ = Nothing
lookup (Branch (key, val) ltree rtree) key' =
	decide (compare key' key) where
		decide LT = lookup ltree key'
		decide EQ = Just val
		decide GT = lookup rtree key'
\end{lstlisting}

Como não há garantias de que a árvore contém a chave, e portanto um valor associado a ela, \texttt{lookup} deve retornar \texttt{Maybe v}.
A lógica de busca também baseia-se nas invariantes de uma árvore binária de busca, o que torna a estrutura dessa definição similar à da definição de \texttt{insert}.
Podemos definir rapidamente uma função que verifica se uma árvore contém uma certa chave.

\begin{lstlisting}[language=haskell, frame=single]
contains :: Ord k => BSTree k v -> k -> Bool
contains bst = isJust . lookup bst
\end{lstlisting}

Além de inserir valores associados a chaves em nossa árvore, é interessante que possamos atualizar o valor de uma chave.
Isso nos permitiria utilizar mais facilmente a \texttt{BSTree} em certas situações.

\begin{lstlisting}[language=haskell, frame=single]
update :: Ord k => BSTree k v -> k -> (v -> v) -> BSTree k v
update Empty _ _ = empty
update (Branch (key, val) ltree rtree) key' f =
	decide (compare key' key) where
		decide LT = Branch (key, val) ltree' rtree
		decide EQ = Branch (key, f val) ltree rtree
		decide GT = Branch (key, val) ltree rtree'
		ltree' = update ltree key' f
		rtree' = update rtree key' f
\end{lstlisting}

Vamos escrever funções para determinar as chaves máximas e mínimas de uma árvore, junto com seu valor.

\begin{lstlisting}[language=haskell, frame=single]
maxKey :: BSTree k v -> Maybe (k, v)
maxKey Empty = Nothing
maxKey (Branch keyval _ Empty) = Just keyval
maxKey (Branch _ _ rtree) = maxKey rtree

minKey :: BSTree k v -> Maybe (k, v)
minKey Empty = Nothing
minKey (Branch keyval Empty _) = Just keyval
minKey (Branch _ ltree _) = minKey ltree
\end{lstlisting}

Note como não precisamos restringir \texttt{k} a ser instância da classe \texttt{Ord} nessas duas funções.
Isso é possível porque não fazemos comparações.
A busca pela chave máxima (mínima) utiliza apenas a estrutura da árvore e suas invariantes: caso a sub-árvore direita (esquerda) não seja vazia, a chave máxima (mínima) tem de estar lá.
Ambas as funções sequer ``abrem" o conteúdo do par \texttt{keyval}, usando esse identificador para a tupla inteira em vez de associar identificadores individuais às componentes do par.

Vamos agora definir como é feita a remoção de uma chave da \texttt{BSTree}.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
remove :: Ord k => BSTree k v -> k -> BSTree k v
remove Empty _ = empty
remove bst@(Branch (key, val) ltree rtree) key' =
	decide (compare key' key) where
		decide LT = Branch (key, val) ltree' rtree
		decide GT = Branch (key, val) ltree rtree'
		decide EQ = removeRoot bst
		ltree' = remove ltree key'
		rtree' = remove rtree key'
		removeRoot Empty = Empty
		removeRoot (Branch _ lt Empty) = lt
		removeRoot (Branch _ Empty rt) = rt
		removeRoot (Branch _ lt rt) =
			Branch (keyMinR, valMinR) lt rt' where
				Just (keyMinR, valMinR) = minKey rt
				rt' = remove rt keyMinR
\end{lstlisting}

Essa função não é tão complexa quanto parece.
Basicamente, \texttt{remove} busca pela chave a ser removida e, se ela é encontrada, a sub-árvore da qual ela é raiz é passada para a função \texttt{removeRoot}.
A função \texttt{removeRoot} faz exatamente o que seu nome diz, e para isso há quatro casos (referentes ao número de sub-árvores não vazias).
O primeiro caso nunca será usado (por quê?), e apenas deixa completa a definição de \texttt{removeRoot}.
Os dois próximos casos são imediatos, e temos o último caso, onde a árvore em questão tem suas duas sub-árvores não vazias: tomamos o par de menor chave na sub-árvore direita para substituir o par da raiz, e em seguida o removemos da sub-árvore direita, para não haver chaves duplicadas.
Dessa forma, a antiga chave da raiz não estará presente na árvore a ser retornada.

Há duas observações interessantes.
A primeira é que \texttt{keyMinR} nunca usará o último caso de \texttt{removeRoot}.
Para perceber isso mais claramente, basta ver a definição de \texttt{minKey}.
A segunda observação é sobre como o retorno de \texttt{minKey} é tomado.
Temos a liberdade de admitir que seu retorno será um \texttt{Just (k, v)} pelo fato de que \texttt{removeRoot} nunca passa uma árvore vazia para \texttt{minKey}.

Assim como definimos \texttt{map} (em \texttt{Functions.hs}) para aplicar uma função em uma lista, podemos declarar uma função \texttt{map} dentro de \texttt{BSTree.hs} com o mesmo propósito.
Mais adiante, veremos como evitar conflitos entre funções homônimas.

\begin{lstlisting}[language=haskell, frame=single]
map :: (v1 -> v2) -> BSTree k v1 -> BSTree k v2
map _ Empty = empty
map f (Branch (key, val) ltree rtree) =
	Branch (key, f val) ltree' rtree' where
		ltree' = map f ltree
		rtree' = map f rtree
\end{lstlisting}

É interessante que a lista e \texttt{BSTree} possam ambas ter seu conteúdo transformado.
Inclusive, isso é esperado de tipos que representam estruturas de dados.
Mais adiante, veremos que essa propriedade ocorre com frequência em diversos tipos.

Se quisermos comparar duas árvores por igualdade, devemos fazer \texttt{BSTree k v} ser uma instância da classe \texttt{Eq}.
Isso pode ser feito da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
instance (Eq k, Eq v) => Eq (BSTree k v) where
	Empty == Empty = True
	Empty == _     = False
	_     == Empty = False
	(Branch (key, val) ltree rtree) == (Branch (key', val') ltree' rtree') =
		and [key == key', val == val', ltree == ltree', rtree == rtree']
\end{lstlisting}

Nessa definição, exigimos que \texttt{k} e \texttt{v} sejam comparáveis por igualdade para determinar o comparador de igualdade de \texttt{BSTree k v}.
Sua definição não deve ser difícil de entender.
O que deve chamar a atenção aqui é o fato de que essa não é a única definição plausível de igualdade entre árvores.
É possível pensar, por exemplo, que duas árvores são estruturalmente iguais se têm o mesmo conjunto de chaves, dispostas da mesma forma.
Nesses casos, onde há mais de uma definição (semanticamente) plausível para tornar um tipo instância de uma classe, existe um recurso da linguagem para ``encapsular" um tipo como outro, de forma que ele possa ser instância de uma classe mais de uma vez.
Isso será abordado futuramente.

Por fim, para concluir o módulo \texttt{BSTree.hs}, definimos sua lista de exportação, ou seja, as definições do módulo que serão visíveis para quem o importa.
Essa é uma prática usual para esconder a definição de um tipo e funções auxiliares.
Modificamos o começo de \texttt{BSTree.hs} da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
module BSTree (BSTree, empty,
               insert, update, remove, map,
               lookup, contains) where
\end{lstlisting}

Módulos como \texttt{BSTree.hs}, que contém a definição de um tipo, costumam ter funções homônimas às definidas para outros tipos.
Para evitar conflitos entre nomes de funções, é sempre bom importar esses módulos como \texttt{qualified}.
Assim, \mbox{\texttt{import qualified BSTree as BST}} deixa vísiveis as definições exportadas de \texttt{BSTree.hs} a partir do símbolo \texttt{BST}.
Quando formos utilizar a função \texttt{empty}, por exemplo, ela será referenciada como \texttt{BST.empty}.
Perceba que essa prefixação é suficiente para resolver conflitos entre funções homônimas definidas em módulos distintos.

\begin{exercicio}
	Escreva a função \emph{\texttt{breadth :: BSTree k v -> [(k, v)]}} que, dada uma árvore binária de busca, retorna seus pares de chave e valor em largura.
	Isso quer dizer que os elementos são retornados, a cada nível, da esquerda para a direita, começando pelo nível da raiz.
	Use a concatenação de listas para simular o comportamento de uma fila.
\end{exercicio}

\begin{exercicio}
	Escreva a função \emph{\texttt{leaves :: BSTree k v -> Int}}, que retorna o número de folhas da árvore binária de busca dada como entrada.
\end{exercicio}

\begin{exercicio}
	Escreva as funções \emph{\texttt{inOrder}}, \emph{\texttt{preOrder}} e \emph{\texttt{postOrder}}, todas com assinatura \emph{\texttt{BSTree k v -> [(k, v)]}}, que retornam uma lista com os pares de chave e valor contidos na árvore de entrada.
	A ordem dos pares nas listas é dada de acordo com o passeio sugerido pelo nome da função.
\end{exercicio}

\subsection{Representando sequências de forma eficiente}

Como sabemos, listas são a estrutura de dados padrão para se trabalhar em Haskell e cumprem o papel de representar sequências de elementos.
Sua definição simples, no entanto, não nos permite operar com tais sequências de forma eficiente.
Se quisermos acessar o \texttt{k}-ésimo elemento de uma lista, precisamos fazer um número de operações proporcional a \texttt{k}.
Isso fica evidente na definição do operador \texttt{(!!) :: [a] -> Int -> a}, que se encontra em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
(!!) :: [a] -> Int -> a
[] !! _ = error "(!!): empty list"
(x:_) !! 0 = x
(_:xs) !! k = xs !! (k - 1)
\end{lstlisting}

\begin{exercicio}
	Implemente \emph{\texttt{(!?) :: [a] -> Int -> Maybe a}}, que deve ser uma versão segura de \emph{\texttt{(!!)}}.
\end{exercicio}

Sempre que é necessário acessar elementos de uma sequência em ordem arbitrária, o tempo linear de acesso torna as listas representações indesejáveis.
Assim, devemos propor uma representação que permita um acesso mais eficiente.
Embora não possamos garantir acesso em tempo constante, como nas linguagens imperativas, podemos garantir acesso em tempo logarítmico.

Uma ideia seria usar uma \texttt{BSTree} onde as chaves representam as posições da sequência.
No entanto, o nosso tipo \texttt{BSTree} não garante um balanceamento em sua definição.
Pior ainda, se inserirmos a sequência em ordem crescente (ou decrescente) de posições, teremos uma representação linear da sequência (tal como é a lista, mas gastando ainda mais memória).
Devemos lembrar que uma árvore binária de busca sem operações de balanceamento é razoavelmente eficiente apenas quando sua construção se dá de maneira arbitrária.

No entanto, como temos uma ideia clara do que queremos representar de forma arbórea, é perfeitamente possível que consigamos garantir um balanceamento baseado na ordem em que as chaves são inseridas.
Por exemplo, podemos admitir a inserção das chaves apenas em ordem crescente e conceber uma representação em árvore que seja naturalmente balanceada.

Vamos definir nossa estrutura de dados no arquivo \texttt{SeqTree.hs}, que terá o seguinte conteúdo inicial.

\begin{lstlisting}[language=haskell, frame=single]
module SeqTree where

import Prelude (Int, (+), (-), (^),
                Ord, (<), (<=), max)

import Bool
import Maybe

data SeqTree a = Empty
               | Leaf a
               | Branch Int Int (SeqTree a) (SeqTree a)
\end{lstlisting}

A primeira coisa notável em nossa definição é que não usamos um tipo para representar nossas chaves, uma vez que sequências são todas indexadas por inteiros.
Outra observação está no fato de que apenas as folhas contém elementos do tipo \texttt{a}, enquanto os nós internos da árvore contém dois valores inteiros.
Isso quer dizer que o conteúdo de todas as posições de nossa sequência estará armazenado em folhas, e os nós internos terão informações para garantir o balanceamento da árvore.

De fato, é preciso explicar o que representam os valores inteiros em \texttt{Branch}.
O primeiro valor representa a altura do nó, e nos auxilia a determinar quantos elementos cabem em sua sub-árvore.
Se um nó tem altura \texttt{h}, e \texttt{SeqTree a} representa uma árvore binária, então sua sub-árvore pode ter no máximo $2^h$ folhas, e portanto pode conter no máximo $2^h$ elementos do tipo \texttt{a}.
Já o segundo valor determina a quantidade de folhas que a sub-árvore daquele nó contém.
Dessa forma, podemos determinar se uma sub-árvore está cheia comparando esses dois valores, o que vai permitir que nossa operação de inserção garanta algum balanceamento para a árvore.

Antes de prosseguir, vamos definir alguns \emph{getters} para \texttt{SeqTree}, que serão bastante úteis para estabelecer algumas conveções.

\begin{lstlisting}[language=haskell, frame=single]
height :: SeqTree a -> Int
height Empty = 0
height (Leaf _) = 0
height (Branch h l ltree rtree) = h
\end{lstlisting}

Usamos \texttt{height} para convencionar que a altura de árvores vazias e de árvores com um único nó é 0.
À primeira vista parece estranho que folhas não tenham altura 1, mas perceba: se permitirnos que folhas tenham altura 1, estaremos admitindo que elas comportam $2^1 = 2$ elementos, o que não faz sentido.
Por fim, o terceiro caso estabelece o primeiro valor inteiro de \texttt{Branch} como sua altura.

\begin{lstlisting}[language=haskell, frame=single]
leaves :: SeqTree a -> Int
leaves Empty = 0
leaves (Leaf _) = 1
leaves (Branch h l ltree rtree) = l
\end{lstlisting}

A função \texttt{leaves} retorna o número de folhas de uma \texttt{SeqTree}.
\texttt{Empty} não tem folhas e \texttt{Leaf} tem exatamente uma folha.
O terceiro caso estabelece que o segundo valor inteiro de \texttt{Branch} representa seu número de folhas.

Para construir valores de \texttt{SeqTree}, podemos usar seus três construtores (\texttt{Empty}, \texttt{Leaf} e \texttt{Branch}).
Vamos, no entanto, evitar o uso do construtor \texttt{Branch} e preferir o uso da função \texttt{makeBranch}, com a finalidade de encapsular alguns cálculos.

\begin{lstlisting}[language=haskell, frame=single]
makeBranch :: SeqTree a -> SeqTree a -> SeqTree a
makeBranch tx ty = Branch h' l' tx ty where
	h' = max (height tx) (height ty) + 1
	l' = leaves tx + leaves ty
\end{lstlisting}

Utilizar \texttt{makeBranch} é mais simples que utilizar \texttt{Branch}, pois altura e número de folhas já estão determinados.
A altura da árvore criada é a altura da maior de suas sub-árvores, mais um.
Já o número de folhas da árvore é a soma do número de folhas de suas sub-árvores.

Vamos criar agora \emph{getters} para tomar as sub-árvores de uma \texttt{SeqTree}.
Suas definições não exigem muitas explicações, mas observamos que há a convenção de que árvores vazias ou com apenas um nó têm ambas as suas sub-árvores vazias.

\begin{lstlisting}[language=haskell, frame=single]
leftTree :: SeqTree a -> SeqTree a
leftTree Empty = Empty
leftTree (Leaf _) = Empty
leftTree (Branch h l ltree rtree) = ltree

rightTree :: SeqTree a -> SeqTree a
rightTree Empty = Empty
rightTree (Leaf _) = Empty
rightTree (Branch h l ltree rtree) = rtree
\end{lstlisting}

Agora precisamos definir a inserção de forma a garantir um balanceamento para \texttt{SeqTree}.
Vamos fazer isso permitindo a inserção de elementos apenas após o último elemento da sequência representada por uma \texttt{SeqTree}. 

Antes de definirmos a operação de inserção em uma \texttt{SeqTree}, faz-se necessário criar um tipo para representar a comparação de um elemento de um tipo ordenável em relação a dois outros elementos do mesmo tipo.

\begin{lstlisting}[language=haskell, frame=single]
data Ordering = LL | LG | GL | GG

compare :: Ord a => a -> a -> a -> Ordering
compare x p q = cond (x < p)
                     (cond (x < q) LL LG)
                     (cond (x < q) GL GG)
\end{lstlisting}

Basicamente, criamos esse \texttt{Ordering} personalizado e sua função \texttt{compare} com o objetivo estético de expressar essa lógica de comparação fora de \texttt{insert}.
A função \texttt{insert} é definida a seguir.

\begin{lstlisting}[language=haskell, frame=single]
insert :: SeqTree a -> a -> SeqTree a
insert Empty x = Leaf x
insert ltree@(Leaf _) x = makeBranch ltree (Leaf x)
insert branch x = decide (compare (leaves branch) halfCapacity capacity) where
	decide LL = makeBranch lbranch' rbranch
	decide GL = makeBranch lbranch rbranch'
	decide GG = makeBranch branch (Leaf x)
	lbranch = leftTree branch
	rbranch = rightTree branch
	lbranch' = insert lbranch x
	rbranch' = insert rbranch x
	halfCapacity = 2^(height branch - 1)
	capacity = 2^(height branch)
\end{lstlisting}

Os dois primeiros casos de \texttt{insert} lidam com \texttt{Empty} e \texttt{Leaf}: inserir um elemento em uma árvore vazia resulta em uma única folha; inserir um elemento em uma folha resulta em uma árvore de altura 1 com duas folhas.
Em seu último caso, \texttt{insert} tem de se preocupar com o número de folhas de \texttt{branch}:
se \texttt{branch} tem menos folhas que o máximo de folhas que pode haver em \texttt{lbranch} (\texttt{halfCapacity}), então a inserção é feita em \texttt{lbranch};
caso \texttt{branch} não esteja com seu número máximo de folhas, a inserção é feita em \texttt{rbranch};
caso \texttt{branch} tenha atingido seu número máximo de folhas, \texttt{branch} torna-se a sub-árvore esquerda de uma nova \texttt{SeqTree}, cuja sub-árvore direita consiste de uma folha.

Agora, definimos a função \texttt{lookup}, cujo objetivo é retornar o valor associado a uma posição da sequência.
Note que consideramos nossas sequências indexadas a partir de 1, e não de 0.

\begin{lstlisting}[language=haskell, frame=single]
lookup :: SeqTree a -> Int -> Maybe a
lookup Empty _ = Nothing
lookup (Leaf x) 1 = Just x
lookup (Leaf _) _ = Nothing
lookup branch n = cond  (n <= halfCapacity)
                        (lookup lbranch n)
                        (lookup rbranch n') where
	halfCapacity = 2^(height branch - 1)
	lbranch = leftTree branch
	rbranch = rightTree branch
	n' = n - halfCapacity
\end{lstlisting}

Primeiro, temos os três casos elementares.
No último caso, \texttt{lookup} verifica se o índice da posição buscada (\texttt{n}) é limitado pelo número máximo de folhas que uma sub-árvore de \texttt{branch} pode ter.
Caso seja, e como \texttt{insert} garante que \texttt{branch} tem elementos em \texttt{rbranch} apenas se \texttt{lbranch} estiver cheia, então a busca pelo valor da posição \texttt{n} continua em \texttt{lbranch}.
Do contrário, o valor associado a \texttt{n} não pode estar em uma das folhas de \texttt{lbranch}, e a busca deve continuar em \texttt{rbranch}, mas com uma modificação: \texttt{rbranch} representa uma subsequência que começa após os \texttt{halfCapacity} primeiros elementos da sequência representada por \texttt{branch}; dessa forma, o \texttt{n}-ésimo elemento da sequência de \texttt{branch} deverá estar na posição \texttt{n - halfCapacity} da subsequência de \texttt{rbranch}.

\begin{lstlisting}[language=haskell, frame=single]
update :: SeqTree a -> Int -> (a -> a) -> SeqTree a
update Empty _ _ = Empty
update (Leaf x) 1 f = Leaf (f x)
update leaf@(Leaf _) _ _ = leaf
update branch n f = cond (n <= halfCapacity)
                         (makeBranch lbranch' rbranch)
                         (makeBranch lbranch rbranch') where
	halfCapacity = 2^(height branch - 1)
	lbranch = leftTree branch
	rbranch = rightTree branch
	lbranch' = update lbranch n f
	rbranch' = update rbranch n' f
	n' = n - halfCapacity
\end{lstlisting}

Acima, temos a função \texttt{update}, que atualiza o conteúdo de uma posição da sequência.
A decisão sobre qual sub-árvore irá sofrer a atualização é a mesma de \texttt{lookup}.
No entanto, em vez de retornar o elemento da posição \texttt{n}, \texttt{update} reconstrói as sub-árvores necessárias para que \texttt{f x} torne-se o valor da posição \texttt{n} da sequência representada por \texttt{branch}.

\begin{lstlisting}[language=haskell, frame=single]
remove :: SeqTree a -> SeqTree a
remove Empty = Empty
remove (Leaf _) = Empty
remove (Branch _ _ ltree Empty) = remove ltree
remove (Branch _ _ ltree rtree) = makeBranch ltree (remove rtree)
\end{lstlisting}

Temos agora nossa função \texttt{remove}, que sempre remove o último elemento da sequência.
Perceba que \texttt{remove} apenas deleta a folha que estiver mais à direita, o que a torna bem simples.
Além disso, perceba que o terceiro caso de \texttt{remove} é responsável por reduzir a estrutura de uma \texttt{SeqTree}, eliminando sub-árvores vazias.

Aproveitamos também para definir como transformar uma sequência de elementos.
A função \texttt{map} explora a estrutura de \texttt{SeqTree}, alterando o conteúdo de suas folhas.

\begin{lstlisting}[language=haskell, frame=single]
map :: (a -> b) -> SeqTree a -> SeqTree b
map _ Empty = Empty
map f (Leaf x) = Leaf (f x)
map f (Branch _ _ ltree rtree) = makeBranch ltree' rtree' where
	ltree' = map f ltree
	rtree' = map f rtree
\end{lstlisting}

Antes de preparar a lista de exportação de nosso módulo, fornecemos uma maneira de criar uma \texttt{SeqTree} vazia.

\begin{lstlisting}[language=haskell, frame=single]
empty :: SeqTree a
empty = Empty
\end{lstlisting}

Por fim, definimos nossa lista de exportação, alterando o começo de \texttt{SeqTree.hs} da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
module SeqTree (SeqTree, empty, insert, update, lookup, remove, map) where
\end{lstlisting}

Assim, temos concluído as definições necessárias para \texttt{SeqTree}.
Futuramente, utilizaremos essa estrutura para resolver alguns problemas.

\subsection{Compilando um programa}	\label{subsec:compiling}

Até o presente momento, escrevemos alguns módulos com definições úteis e os testamos utilizando um interpretador, o \texttt{ghci}.
Nesta breve subseção, mostramos quais os passos necessários para se compilar um programa em Haskell.

Dado um arquivo \texttt{Module.hs}, utilizamos o seguinte comando para compilá-lo.

\begin{lstlisting}[language=haskell, frame=single]
ghc Module -W
\end{lstlisting}

Esse comando compila \texttt{Module.hs}, produzindo um tipo de saída conforme seu conteúdo.
Aqui, \texttt{-W} habilita os \emph{warnings} do \texttt{ghc} que, em suas últimas versões, tornaram-se opcionais.
Certamente, é sempre bom usar \texttt{-W}.

Se \texttt{Module.hs} tem em sua primeira linha algo como \texttt{module Module where}, então o comando acima produz um arquivo \texttt{Module.o}.
Como exemplo, temos a compilação de \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
$ ghc List -W
[1 of 4] Compiling Bool             ( Bool.hs, Bool.o )
[2 of 4] Compiling Functions        ( Functions.hs, Functions.o )
[3 of 4] Compiling Maybe            ( Maybe.hs, Maybe.o )
[4 of 4] Compiling List             ( List.hs, List.o )
$
\end{lstlisting}

Podemos perceber que, como \texttt{List} importa outros módulos, esses foram recursivamente compilados.
Assim, a rotina de compilação do \texttt{ghc} usualmente dispensa o uso de ferramentas como \texttt{make}.
Note ainda que nenhum executável foi criado, mas apenas arquivos objeto.

Se \texttt{Module.hs} tem \texttt{module Main where} como sua primeira linha, então o \texttt{ghc} espera que haja uma função \texttt{main :: IO ()} definida em \texttt{Module.hs} (\texttt{IO} será explicada futuramente).
Caso haja, \texttt{ghc} gera um executável \texttt{Module}.
Como exemplo, vamos criar um arquivo \texttt{Hello.hs} com o seguinte conteúdo.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (IO, putStrLn, getLine, (>>=))

import Functions
import List

main :: IO ()
main = getLine >>= putStrLn . reverse
\end{lstlisting}

Há muitas coisas novas sendo usadas em \texttt{Hello.hs}.
Basicamente, \texttt{IO} representa um valor que surge de operações de entrada e saída.
Essa é a forma de Haskell separar funções com retorno \emph{impuro} de funções com retorno simples.
O valor \mbox{\texttt{getLine :: IO [Char]}} retorna uma string, obtida a partir do teclado, dentro de \texttt{IO}.
Como o valor \texttt{getLine} pode mudar, a depender do que se digita no teclado, ele não é considerada puro.
A função \mbox{\texttt{putStrLn :: String -> IO ()}} recebe uma string e a imprime na tela, retornando uma tupla vazia dentro de \texttt{IO}.
Como isso envolve uma operação de entrada e saída, o retorno de \texttt{putStrLn} é representado por \texttt{IO}.
Por fim, o operador \mbox{\texttt{(>>=) :: Monad m => m a -> (a -> m b) -> m b}} pode ser visto como uma composição de funções mais sofisticada (entraremos em detalhes sobre ele futuramente).

Agora, compilamos \texttt{Hello.hs}.

\begin{lstlisting}[language=haskell, frame=single]
$ ghc Hello -W
[1 of 5] Compiling Bool             ( Bool.hs, Bool.o )
[2 of 5] Compiling Functions        ( Functions.hs, Functions.o )
[3 of 5] Compiling Maybe            ( Maybe.hs, Maybe.o )
[4 of 5] Compiling List             ( List.hs, List.o )
[5 of 5] Compiling Main             ( Hello.hs, Hello.o )
Linking Hello ...
$
\end{lstlisting}

Observe que, dessa vez, o processo de compilação se estende até a fase de \emph{linking}.
Mais uma vez, \texttt{ghc} compila os módulos necessários recursivamente.
Podemos testar o que o executável \texttt{Hello} faz.

\begin{lstlisting}[language=haskell, frame=single]
$ ./Hello
Hello
olleH
$
\end{lstlisting}

Isso deve ser suficiente para que possamos compilar programas, em um primeiro momento.

\subsection{Implementando um grafo}

Aqui, desenvolvemos em \texttt{Graph.hs} algumas definições para lidar com grafos.
Nosso objetivo é ilustrar o uso de \texttt{SeqTree}.
Um grafo \mbox{$G = (V, E)$} tem um conjunto de vértices $V$ e um conjunto de arestas $E$, sendo que uma aresta relaciona dois vértices.
Seu conteúdo inicial se encontra a seguir.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
module Graph where

import Prelude (Int, (+), (-), Bool(True, False),
                (==), (<=))

import Bool
import Functions
import List
import Maybe
import qualified SeqTree as Seq

type Vertex = Int

data Graph = G Int (Seq.SeqTree [Vertex])
\end{lstlisting}

Usamos valores inteiros para representar nossos vértices, e deixamos isso expresso de forma clara com o uso de \texttt{type}, que apenas cria sinônimos para tipos já existentes.
Dessa forma, um grafo com $n$ vértices tem seus vértices numerados de 1 a $n$.
Nosso tipo \texttt{Graph} tem dois campos: um inteiro, indicando seu número de vértices; uma \texttt{SeqTree [Vertex]}, que associa a cada vértice $v$ uma lista com os outros vértices das arestas relacionadas a $v$.
Vamos desenvolver uma função para criar um grafo com nenhum vértice.

\begin{lstlisting}[language=haskell, frame=single]
empty :: Graph
empty = G 0 Seq.empty
\end{lstlisting}

A função \texttt{empty} é bem simples.
Ela apenas cria um grafo com 0 vértices e, portanto, com uma \texttt{SeqTree} vazia.
A seguir, criamos um modo de adicionar um vértice ao grafo.

\begin{lstlisting}[language=haskell, frame=single]
addVertex :: Graph -> Graph
addVertex (G n adj) = G (n + 1) (Seq.insert adj [])
\end{lstlisting}

Ao adicionar um vértice, \texttt{addVertex} precisa atualizar o número de vértices do grafo.
Além disso, o vértice recém-criado faz parte de nenhuma aresta, portanto inserimos \texttt{[]} em \texttt{adj}.
Aproveitamos \texttt{addVertex} para criar uma função que retorna grafos sem arestas.

\begin{lstlisting}[language=haskell, frame=single]
edgeless :: Int -> Graph
edgeless n = cond (n <= 0) empty (addVertex g) where
	g = edgeless (n - 1)
\end{lstlisting}

A função a seguir verifica se um grafo tem um certo vértice.

\begin{lstlisting}[language=haskell, frame=single]
hasVertex :: Graph -> Vertex -> Bool
hasVertex (G n _) v = and [1 <= v, v <= n]
\end{lstlisting}

Como consideramos que um grafo tem seus \texttt{n} vértices numerados entre 1 e \texttt{n}, \texttt{hasVertex} verifica justamente isso.
Vale notar também que, se um grafo tem nenhum (zero) vértices, então \texttt{hasVertex} retorna \texttt{False} para qualquer vértice recebido como entrada.

Definimos a função \texttt{vertices}, que retorna uma lista com os vértices do grafo, por uma questão de conveniência.
Fazemos uso de \texttt{iterate}, proposta no Exercício \ref{exercicio:iterate}.

\begin{lstlisting}[language=haskell, frame=single]
vertices :: Graph -> [Vertex]
vertices (G n _) = take n (iterate (+1) 1)
\end{lstlisting}

Agora vamos definir a adição de uma aresta.

\begin{lstlisting}[language=haskell, frame=single]
addEdge :: Graph -> Vertex -> Vertex -> Graph
addEdge g@(G n adj) u v = cond verticesExist g' g where
	verticesExist = and [g `hasVertex` u, g `hasVertex` v]
	g' = G n adj'
	adj' = Seq.update adj u (v:)
\end{lstlisting}

Primeiro, \texttt{addEdge} verifica se o grafo \texttt{g} tem os vértices \texttt{u} e \texttt{v}.
Aqui, notamos mais uma novidade sintática: funções ``binárias'' podem ser usadas como operadores infixos, isto é, entre seusa argumentos.
Para isso, o nome da função deve estar entre crases (no código acima, o nome da função aparece entre aspas simples porque o \LaTeX\, interpreta crases soltas como aspas simples (mas olha só, ele tem um comando para imprimir seu próprio nome de um jeito bem bizarro)).
Caso \texttt{u} e \texttt{v} sejam vértices de \texttt{g}, a lista de \texttt{u} é atualizada de forma que \texttt{v} seja vizinho de \texttt{u}.
Isso indica que há uma aresta de \texttt{u} para \texttt{v}, já que \texttt{v} aparece na lista de \texttt{u}.
Com isso, estamos implementando um grafo onde as arestas têm direção, isto é, estamos implementando um grafo direcionado.

Os vizinhos de um vértice \texttt{v} são os vértices que aparecem em sua lista.
Note que, a partir de \texttt{v}, podemos ir para qualquer vértice de sua lista, enquanto que o contrário nem sempre é verdade.
A função \texttt{neighbors} retorna os vizinhos de um vértice em um grafo, aproveitando o fato de que \texttt{adj}, de acordo com a definição anterior, armazena justamente os vizinhos de cada vértice.

\begin{lstlisting}[language=haskell, frame=single]
neighbors :: Graph -> Vertex -> [Vertex]
neighbors (G _ adj) v = fromMaybe [] (Seq.lookup adj v)
\end{lstlisting}

Na definição acima, note o uso de \texttt{fromMaybe} para tratar o caso de \texttt{v} não ser um vértice do grafo.
Nesse caso, convencionamos que se um vértice não pertence ao grafo, ele não tem vizinhos.
Para verificar se é possível ir de um vértice \texttt{u} para um certo vértice \texttt{v}, é preciso verificar se \texttt{v} é vizinho de \texttt{u}.

\begin{lstlisting}[language=haskell, frame=single]
hasEdge :: Graph -> Vertex -> Vertex -> Bool
hasEdge g u v = f (neighbors g u) where
	f = isJust . find (==v)
\end{lstlisting}

Na definição acima, tomamos os vizinhos do vértice \texttt{u}.
Em seguida, verificamos se \texttt{v} se encontra dentre os vizinhos de \texttt{u}.
A função \texttt{isJust}, por fim, retorna o valor booleano apropriado.
Perceba que, pela definição de \texttt{addEdge}, \mbox{\texttt{hasEdge g u v == hasEdge g v u}} nem sempre é \texttt{True}.
Fizemos uso de \texttt{find}, proposta na Subseção \ref{lab2}.

Essas operações são suficientes para a construção de grafos.
Sobre elas, seria possível definir algumas operações mais sofisticadas.

É preciso observar, ainda, que como \texttt{SeqTree} é limitada em sua remoção, nossa implementação de grafo não pode ter uma remoção elementar de vértices.
Perceba também que, como cada vértice tem seus vizinhos representados como uma lista, a remoção de uma aresta não seria eficiente.
O mais adequado seria representar os vizinhos de um vértice como uma árvore binária de busca balanceada, mas não temos implementado tal estrutura.

Após a constatação de que \texttt{Graph} não pode ter operações de remoção viáveis, fechamos nosso módulo com a seguinte alteração em seu início.

\begin{lstlisting}[language=haskell, frame=single]
module Graph (Graph, empty, edgeless,
              addVertex, hasVertex, vertices,
              addEdge, neighbors, hasEdge) where
\end{lstlisting}

Isso conclui as operações básicas em \texttt{Graph.hs}.

\subsection{Filas de prioridade}

Vamos desenvolver em \texttt{Heap.hs} as definições necessárias para a manipulação de filas de prioridade.
Vamos desenvolver uma fila de prioridade mínima.

O conteúdo inicial de \texttt{Heap.hs} é dado a seguir.

\begin{lstlisting}[language=haskell, frame=single]
module Heap where

import Prelude (Ord, (<=))

import Bool
import Maybe

data Heap k v = Empty
              | Heap (k, v) [Heap k v]
\end{lstlisting}

Nosso tipo \texttt{Heap k v} representa uma \emph{pairing heap}.
\texttt{Heap k v} associa a cada valor de tipo \texttt{v} uma chave de tipo \texttt{k}, que é tratada como sua prioridade.
Em sua definição, temos dois casos: \texttt{Heap} pode ser vazia, representada por \texttt{Empty}; pode ter um par de chave e valor em sua raiz, bem como uma lista de \emph{heaps}.
Assim, \texttt{Heap} pode ser vista como uma árvore (não necessariamente binária, já que uma lista pode ter qualquer número de elementos).

A ideia de manter uma lista de \emph{heaps} permite que a execução de certas operações seja postergada o máximo possível.
Com isso, o custo de execução de uma sequência de (digamos $n$) operações pode ser desbalanceado: por exemplo, as $n - 1$ primeiras operações podem ser postergadas, enquanto a $n$-ésima precisa realizar o trabalho de todas as $n$ operações.
Em cenários como esse, é preciso considerar o \emph{custo amortizado} de cada operação, isto é, considerar a média dos custos de todas as operações.
Logo teremos ilustrações disso.

A função \texttt{lookup} retorna o elemento da raiz de \texttt{Heap}, que deve ser seu elemento prioritário.
Sua definição não exige esclarecimentos e se encontra a seguir.

\begin{lstlisting}[language=haskell, frame=single]
lookup :: Heap k v -> Maybe (k, v)
lookup Empty = Nothing
lookup (Heap keyval _) = Just keyval
\end{lstlisting}

Agora, definimos \texttt{merge}, que combina os elementos de duas filas de prioridade.

\begin{lstlisting}[language=haskell, frame=single]
merge :: Ord k => Heap k v -> Heap k v -> Heap k v
merge Empty h2 = h2
merge h1 Empty = h1
merge h1@(Heap x@(key1, _) hs1) h2@(Heap y@(key2, _) hs2) =
	cond (key1 <= key2) h1' h2' where
		h1' = Heap x (h2:hs1)
		h2' = Heap y (h1:hs2)
\end{lstlisting}

Perceba que \texttt{merge} é muito peculiar.
Independente do tamanho das filas de prioridade que \texttt{merge} recebe, ela executa em tempo constante!
Ela sequer é recursiva.
O que \texttt{merge} faz é muito simples: dadas duas filas de prioridade, a fila com o elemento mais prioritário passa a conter a outra.
Observe ainda que ``colocar'' uma fila dentro da outra consiste apenas em adicionar uma fila à lista de filas da outra (essas ficam ``esperando'' que seus elementos sejam processados).

Agora que temos definido \texttt{merge}, podemos definir \texttt{insert} como a combinação de duas \emph{heaps}.
A função \texttt{insert} é descrita abaixo e faz exatamente isso.

\begin{lstlisting}[language=haskell, frame=single]
insert :: Ord k => Heap k v -> (k, v) -> Heap k v
insert h keyval = merge (Heap keyval []) h
\end{lstlisting}

Para implementar a remoção, precisamos criar uma função que faça todo o trabalho que \texttt{merge} decidiu ``procrastinar''.
A função \texttt{mergeAll} cumpre esse papel, e faz uso de \texttt{merge} para isso.

\begin{lstlisting}[language=haskell, frame=single]
mergeAll :: Ord k => [Heap k v] -> Heap k v
mergeAll [] = Empty
mergeAll [h] = h
mergeAll (h1:h2:hs) = merge (merge h1 h2) (mergeAll hs)
\end{lstlisting}

\begin{exercicio}
	A função \emph{\texttt{mergeAll}} poderia ser definida como \emph{\texttt{mergeAll = foldl merge Empty}}.
	Existe alguma desvantagem em definí-la dessa forma mais sucinta?
	Pense nas estruturas que as duas definições produzem.
\end{exercicio}

Aqui, \texttt{mergeAll} cria uma estrutura arbórea, combinando diversas \emph{heaps} em uma só.
Podemos ver sua definição em dois tempos: primeiro, ela define a combinação das \emph{heaps} duas a duas, da esquerda para a direita; depois, ela faz a combinação cumulativa desses pares, combinando a \emph{heap} mais à direita com as demais \emph{heaps}, uma de cada vez e da direita para a esquerda.

Agora estamos aptos a definir a remoção do elemento mais prioritário.
A função \texttt{pop} apenas remove a raiz da \emph{heap}, em seguida combinando sua lista de \emph{heaps} em uma só, que é retornada pela função.
Sua  definição elementar é dada abaixo.

\begin{lstlisting}[language=haskell, frame=single]
pop :: Ord k => Heap k v -> Heap k v
pop Empty = Empty
pop (Heap _ hs) = mergeAll hs
\end{lstlisting}

Podemos entender agora que existe um motivo para a definição de \texttt{mergeAll}.
Em uma operação de remoção, o fato de \texttt{mergeAll} combinar as \emph{heaps} aos pares faz com que o número de \emph{heaps} a serem combinadas em uma remoção futura seja em torno da metade do número de \emph{heaps} combinadas nessa remoção.

Com isso, podemos analisar o seguinte cenário, que começa com uma \emph{heap} vazia:
após uma sequência de $n$ inserções de elementos (no pior caso, em ordem decrescente de prioridade), a primeira remoção custa $O(n)$ e, por conta do ``segundo tempo'' de \texttt{mergeAll}, as $\lceil\frac{n}{2}\rceil$ remoções seguintes custam $O(1)$;
graças ao ``primeiro tempo'' de \texttt{mergeAll}, a próxima remoção custa $O(n)$, mas agora apenas as $\lceil\frac{n}{4}\rceil$ remoções seguintes custam $O(1)$;
assim, uma sequência de $n$ remoções tem $O(\log n)$ remoções custando $O(n)$, enquanto as demais custam $O(1)$, e portanto as $n$ remoções custam, juntas, $O(n \log n)$;
em média, cada uma das $n$ remoções custa $O(\frac{n \log n}{n}) = O(\log n)$, e esse é o custo amortizado da remoção em nossa \texttt{Heap}.

Nossa última operação serve para alterar a chave do elemento mais prioritário de uma \emph{heap}.
Com isso, \texttt{Heap} permite remoções e alterações apenas no elemento mais prioritário.
A definição de \texttt{changeKey} consiste em remover o elemento da raiz e reinserí-lo com uma nova chave.

\begin{lstlisting}[language=haskell, frame=single]
changeKey :: Ord k => Heap k v -> k -> Heap k v
changeKey Empty _ = Empty
changeKey h@(Heap (_, val) _) key' = insert (pop h) (key', val)
\end{lstlisting}

Para permitir que o usuário crie uma fila de prioridades vazia, encapsulamos \texttt{Empty} como segue.

\begin{lstlisting}[language=haskell, frame=single]
empty :: Heap k v
empty = Empty
\end{lstlisting}

Para encerrar o módulo, definimos a lista de exportação de \texttt{Heap.hs}, alterando seu início.

\begin{lstlisting}[language=haskell, frame=single]
module Heap (Heap, empty, lookup, insert, pop, changeKey) where
\end{lstlisting}

Isso deve ser o bastante para termos uma fila de prioridade bem definida. 

\begin{exercicio}
	Uma lista pode ser utilizada como uma pilha, dado que permite inserção e remoção em $O(1)$ na sua extremidade esquerda.
	Tome o tipo \emph{\texttt{Queue a}}, definido como segue.
	\begin{lstlisting}[language=haskell, frame=single]
module Queue(Queue, empty, enqueue, dequeue) where

import Prelude ()

data Queue a = Q [a] [a]

empty :: Queue a
empty = Q [] []

enqueue :: Queue a -> a -> Queue a
enqueue = undefined

dequeue :: Queue a -> Maybe (a, Queue a)
dequeue = undefined
	\end{lstlisting}
	Implemente \emph{\texttt{enqueue}} e \emph{\texttt{dequeue}}, e argumente que \emph{\texttt{dequeue}} tem custo amortizado $O(1)$.
	Escreva sua implementação em \emph{\texttt{Queue.hs}}.
\end{exercicio}

\subsection{Classes}

Nesta subseção, tratamos de descrever algumas classes importantes de Haskell.
Lembramos que uma classe é apenas um conjunto de funções, e dizemos que um tipo é instância de uma classe quando implementa suas funções.
Por força de analogia, o conceito de classe em Haskell muito se assemelha ao de interface em Java.

Começamos com uma classe bem simples, \texttt{Eq}.
Essa classe já foi vista anteriormente, e contém comparadores relacionados com o conceito de igualdade.
Usando \texttt{:info Eq} no \texttt{ghci}, obtemos uma saída parecida com essa.

\begin{lstlisting}[language=haskell, frame=single]
class Eq a where
	(==) :: a -> a -> Bool
	x == y = not (x /= y)
	
	(/=) :: a -> a -> Bool
	x /= y = not (x == y)
	{-# MINIMAL (==) | (/=) #-}
\end{lstlisting}

A despeito do que vínhamos fazendo (reimplementando quase tudo), não estamos aptos a redefinir as classes padrão de Haskell.
Isso se dá porque há tipos cuja definição é intrínseca ao compilador, e assim não podemos ``abrir'' esses tipos e torná-los instâncias de classes.
Por exemplo, não seria muito prático tornar \texttt{Int} uma instância de \texttt{Eq} sem usar sua representação binária (e como tentamos nos manter fiéis ao paradgma, temos de abstrair a representação de \texttt{Int} (apesar disso, Haskell tem operações a nível de \emph{bit})).

Dito isso, não escreveremos as definições de classe aqui apresentadas em nenhum arquivo.
Elas apenas servem para ilustrar as definições padrão das funções.

Voltando à classe \texttt{Eq}, percebemos que ambas as suas funções têm definições padrão.
Nesse caso, basta implementar uma delas para que um tipo se torne instância de \texttt{Eq}.
Isso é dito explicitamente no comentário logo abaixo da classe.
Como exemplo, tornar as listas instâncias de \texttt{Eq} poderia ser feito como segue.

\begin{lstlisting}[language=haskell, frame=single]
instance Eq a => Eq [a] where
	[] == [] = True
	[] == _ = False
	_ == [] = False
	(x:xs) == (y:ys) = and [x == y, xs == ys]
\end{lstlisting}

Podemos ver que duas listas são comparáveis por igualdade apenas quando o tipo de seus elementos também é.
Isso é dito explicitamente na restrição feita sobre \texttt{a}, na primeira linha.

Algo interessante de se notar é que, na definição acima, o comparador \texttt{(==)} é usado de duas formas distintas.
No último caso, \texttt{x == y} faz menção à implementação de \texttt{(==)} que é definida em \texttt{Eq a}, enquanto \texttt{xs == ys} é referente à instância que está sendo definida (é uma chamada recursiva), já que \texttt{xs} e \texttt{ys} são listas.

\begin{exercicio}
	Faça de \emph{\texttt{Maybe}} uma instância de \emph{\texttt{Eq}}.
\end{exercicio}

A classe \texttt{Ord} contém os comparadores relacionados com o conceito de ordenação.
Sua definição pode ser vista a seguir.

\begin{lstlisting}[language=haskell, frame=single]
class Eq a => Ord a where
	compare :: a -> a -> Ordering
	compare x y = cond (x <= y) (cond (x == y) EQ LT) GT
	
	(<) :: a -> a -> Bool
	x < y = (compare x y) == LT
	
	(<=) :: a -> a -> Bool
	x <= y = (compare x y) /= GT
	
	(>) :: a -> a -> Bool
	(>=) :: a -> a -> Bool
	max :: a -> a -> a
	min :: a -> a -> a
	{-# MINIMAL compare | (<=) #-}
\end{lstlisting}

\begin{exercicio}
	Complete as definições padrão da classe \emph{\texttt{Ord}}.
	Tente fazê-las em termos de \emph{\texttt{compare}} ou \emph{\texttt{(<=)}}.
\end{exercicio}

Como exemplo de uma de suas instâncias, mostramos como a lista pdoe ser descrita como uma instância de \texttt{Ord}.

\begin{lstlisting}[language=haskell, frame=single]
instance Ord a => Ord [a] where
	[] <= _ = True
	_ <= [] = False
	(x:xs) <= (y:ys) = cond (x == y) (xs <= ys) (x < y)
\end{lstlisting}

\begin{exercicio}
	Faça de \emph{\texttt{Maybe}} uma instância de \emph{\texttt{Ord}}.
\end{exercicio}

Tratamos agora de duas classes, ambas relacionadas com a conversão de valores.
A classe \texttt{Show} contém funções relacionadas com a conversão de tipos em strings.
As instâncias de \texttt{Show}, portanto, podem todas ser representadas como strings.
A classe \texttt{Read}, por sua vez, agrupa as funções relacionadas com a conversão de strings em valores de outros tipos.
Assim, as instâncias de \texttt{Read} podem ter seus valores obtidos a partir de strings.

\begin{lstlisting}[language=haskell, frame=single]
class Show a where
	showsPrec :: Int -> a -> ShowS
	show :: a -> String
	showList :: [a] -> ShowS
	{-# MINIMAL showsPrec | show #-}

class Read a where
	readsPrec :: Int -> ReadS a
	readList :: ReadS [a]
	GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
	GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec [a]
	{-# MINIMAL readsPrec | readPrec #-}
\end{lstlisting}

Enquanto podemos criar instâncias da classe \texttt{Show} de forma simples, o mesmo não pode ser dito de \texttt{Read}.
Utilizamos as instâncias já existentes de \texttt{Read} para converter strings em valores dos tipos básicos de Haskell.
Para isso, usamos \texttt{read :: Read a => String -> a}, uma função que nem mesmo faz parte da classe \texttt{Read}.
Exemplificamos a seguir o uso de \texttt{show} e \texttt{read}.

\begin{lstlisting}[language=haskell, frame=single]
$ ghci
Prelude> show 25
"25"
Prelude> show [1, 2, 3]
"[1,2,3]"
Prelude> read "4"
*** Exception: Prelude.read: no parse
Prelude> read "4" :: Int
4
Prelude> read "4" :: Double
4.0
Prelude> read "[1, 2, 3]"
*** Exception: Prelude.read: no parse
Prelude> read "[1, 2, 3]" :: Int
*** Exception: Prelude.read: no parse
Prelude> read "[1, 2, 3]" :: [Int]
[1,2,3]
Prelude> read "[1, 2, 3]" :: [Double]
[1.0,2.0,3.0]
Prelude> :q
Leaving GHCi.
$
\end{lstlisting}

Podemos perceber que \texttt{show} e \texttt{read} são úteis principalmente quando operando com arquivos (vamos aprender a utilizar arquivos em algum laboratório).
Exemplificamos como lista poderia ser feita instância de \texttt{Show}.

\begin{lstlisting}[language=haskell, frame=single]
instance Show a => Show [a] where
	show [] = "[]"
	show xs = "[" ++ f xs ++ "]" where
		f = concat . intercalate "," . map show
\end{lstlisting}

Nessa definição, apenas o segundo caso precisa de atenção.
A função \texttt{f} transforma todos os elementos da lista em strings (podemos fazer isso por conta de \texttt{Show a}), em seguida intercala a lista resultante com \texttt{","}, e por fim concatena todas as strings da lista.
A nossa implementação de \texttt{show} apenas chama \texttt{f} e cerca seu resultado com colchetes.

\begin{exercicio}
	Faça de \emph{\texttt{Maybe}} uma instância de \emph{\texttt{Show}}.
\end{exercicio}

Em seguida, temos a classe \texttt{Bounded}, com as funções \texttt{minBound} e \texttt{maxBound}.
Os tipos que são instâncias de \texttt{Bounded} têm limites inferior e superior.
São poucos os tipos que instanciam \texttt{Bounded}: \texttt{Word}, \texttt{Ordering}, \texttt{Int}, \texttt{Char} e \texttt{Bool}.
Além desses, tuplas com componentes desse tipo instanciam \texttt{Ordering}.

Para tipos numéricos, temos a classe \texttt{Num}.

\begin{lstlisting}[language=haskell, frame=single]
class Num a where
	(+) :: a -> a -> a
	(-) :: a -> a -> a
	(*) :: a -> a -> a
	negate :: a -> a
	abs :: a -> a
	signum :: a -> a
	fromInteger :: Integer -> a
	{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
\end{lstlisting}

Os tipos \texttt{Word}, \texttt{Integer}, \texttt{Int}, \texttt{Float} e \texttt{Double} são instâncias de \texttt{Num}, e suas definições são dadas em baixo nível.
Observe ainda que \texttt{Integer} não é instância de \texttt{Bounded}.
Isso se dá porque \texttt{Integer} é um tipo que representa inteiros com precisão arbitrária, isto é, o limite de representação de \texttt{Integer} é dado pela memória do computador em uso, e não por uma quantidade constante de \emph{bits}.
A desvantagem de \texttt{Integer} é que suas operações são mais custosas que as de \texttt{Int}.

Note ainda que \texttt{Num} não contém a operação de divisão, já que nem todos os tipos numéricos conseguem representar precisamente resultados de divisões arbitrárias.
Para isso existe a classe \texttt{Fractional}.

\begin{lstlisting}[language=haskell, frame=single]
class Num a => Fractional a where
	(/) :: a -> a -> a
	recip :: a -> a
	fromRational :: Rational -> a
	{-# MINIMAL fromRational, (recip | (/)) #-}
\end{lstlisting}

Em \texttt{Fractional}, estão contidas as operações de divisão, inversa e conversão a partir de \texttt{Rational}, e esse representa racionais em precisão arbitrária usando dois \texttt{Integer}s.
Estendendo \texttt{Fractional}, temos a classe \texttt{Floating}, que agrupa operações envolvendo trigonometria, potências e logaritmos.
Como seu nome sugere, \texttt{Floating} tem como instâncias apenas representações numéricas de pontos flutuantes: \texttt{Float} e \texttt{Double}.

A classe \texttt{Real} trata de conversões para o tipo \texttt{Rational}, e portanto contém apenas a função \texttt{toRational}.
Já a classe \texttt{Integral} trata de divisões com restos em inteiros.
A classe \texttt{RealFrac}, por sua vez, cuida de truncamentos e arredondamentos.

\begin{lstlisting}[language=haskell, frame=single]
class (Real a, Fractional a) => RealFrac a where
	properFraction :: Integral b => a -> (b, a)
	truncate :: Integral b => a -> b
	round :: Integral b => a -> b
	ceiling :: Integral b => a -> b
	floor :: Integral b => a -> b
	{-# MINIMAL properFraction #-}
\end{lstlisting}

Das funções de \texttt{RealFrac}, apenas \texttt{properFraction} exige esclarecimentos.
Essa função retorna um valor numérico decomposto em sua parte inteira e sua parte fracionária.
Encerrando as classes de tipos numéricos, temos \texttt{RealFloat}, que reúne diversas funções a respeito de representação em ponto flutuante.

Na próxima subseção, tratamos de classes que abstraem o uso de funções, atribuindo semânticas a estruturas de dados.

\subsection{\texttt{Functor}, \texttt{Applicative} e \texttt{Alternative}}

Aqui, tratamos das três classes mencionadas no título.
Antes de prosseguir, contudo, vamos adicionar a seguinte definição a \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
($) :: (a -> b) -> a -> b
f $ x = f x

infixl 0 $
\end{lstlisting}

É isso mesmo.
O operador \texttt{(\$)} aplica seu segundo argumento à função recebida como primeiro argumento.
Embora pareça fútil, o fato de Haskell permitir aplicações parciais de funções dá utilidade a \texttt{(\$)}.
A última linha atribui nível de precedência 0 a \texttt{(\$)} (o mais baixo possível), e também o faz associativo pela esquerda.

O operador \texttt{(\$)} é apresentado nesse contexto por representar aplicações ``normais'' de função.
No texto a seguir, veremos operadores que representam aplicações ``especiais'' de função.

Tratamos inicialmente de \texttt{Functor}, que tem a seguinte definição.

\begin{lstlisting}[language=haskell, frame=single]
class Functor (f :: * -> *) where
	fmap :: (a -> b) -> f a -> f b
	(<$) :: a -> f b -> f a
	{-# MINIMAL fmap #-}
\end{lstlisting}

Precisamos fazer uma pausa para explicar o que significa \texttt{* -> *}.
Em Haskell, valores têm tipos (\texttt{1} pode ser do tipo \texttt{Int} ou \texttt{Integer}, por exemplo), assim como tipos têm \emph{kinds} (\emph{kind} pode significar tipo, então seria estranho traduzir).
Basicamente, um \emph{kind} é um tipo de tipo, e cada \emph{kind} é caracterizado pelo número e \emph{kinds} de seus parâmetros.
Há os tipos que não são parametrizados (têm 0 parâmetros), como \texttt{Int} e \texttt{Char}.
Esses já estão completos e têm \emph{kind} \texttt{*}.
Há os tipos que têm exatamente um tipo completo como parâmetro.
Esses têm \emph{kind} \texttt{* -> *}.
Listas, \texttt{Maybe} e \texttt{SeqTree} têm \emph{kind} \mbox{\texttt{* -> *}}, e se tornam completos apenas quando parametrizados por um tipo completo (\texttt{[Char]}, \texttt{Maybe Int}, \texttt{SeqTree (Maybe Char)}).

Podemos interpretar o \emph{kind} \texttt{* -> *} como a classe de tipos que precisam de um tipo completo (\texttt{*}) para produzir (\texttt{->}) um tipo completo (\texttt{*}).
Podemos entender \texttt{* -> * -> *} de forma análoga, e esse é o \emph{kind} de \texttt{BSTree}.

Há mais detalhes a se explicar sobre \emph{kinds}.
Como esses não são necessários aqui, os desconsideramos.

Voltando a falar de \texttt{Functor}, vemos que há duas funções.
A função \texttt{fmap} aplica uma função aos elementos contidos em um valor de um tipo parametrizado.
O operador \texttt{(<\$)}, por sua vez, substitui todos os elementos de um valor de um tipo parametrizado por um certo elemento.
Como exemplo de \texttt{Functor}, temos as listas, e sua instanciação é ilustrada a seguir.

\begin{lstlisting}[language=haskell, frame=single]
instance Functor [] where
	fmap = map
\end{lstlisting}

Essa definição é padrão de Haskell, e não precisamos implementá-la.
Devemos, no entanto, instanciar \texttt{Maybe} como \texttt{Functor}, e a definição seguinte deve se encontrar em \texttt{Maybe.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Functor Maybe where
	fmap _ Nothing = Nothing
	fmap f (Just x) = Just (f x)
\end{lstlisting}

Perceba que não é preciso definir \texttt{(<\$)}, uma vez que existe a implementação padrão \mbox{\texttt{(x <\$) = fmap f where f \_ = x}}.
Fazemos também de \texttt{BSTree k} uma instância de \texttt{Functor}, pondo o código que segue em \texttt{BSTree.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Functor (BSTree k) where
	fmap = map
\end{lstlisting}

\begin{exercicio}
	Faça de \emph{\texttt{SeqTree}} uma instância de \emph{\texttt{Functor}}.
\end{exercicio}

\begin{exercicio}
	Como \emph{\texttt{Either}} poderia instanciar \emph{\texttt{Functor}}?
\end{exercicio}

Uma vez que temos visto algumas instâncias da classe \texttt{Functor}, apresentamos o operador \mbox{\texttt{(<\$>) :: Functor f => (a -> b) -> f a -> f b}}.
Esse operador equivale à função \texttt{fmap}, e sua assinatura sugere uma comparação com \texttt{(\$)}.
Trazemos uma breve ilustração de seu uso.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
Prelude> :t ($)
($) :: (a -> b) -> a -> b
Prelude> :t (<$>)
(<$>) :: Functor f => (a -> b) -> f a -> f b
Prelude> (*2) $ 3
6
Prelude> (*2) $ [1,2,3]

<interactive>:4:1: error:
	* Non type-variable argument in the constraint: Num [a]
	  (Use FlexibleContexts to permit this)
	* When checking the inferred type
		it :: forall a. (Num a, Num [a]) => [a]
Prelude> (*2) <$> [1,2,3]
[2,4,6]
Prelude> (*2) <$> Nothing
Nothing
Prelude> (*2) <$> (Just 4)
Just 8
\end{lstlisting}

Vemos a distinção entre \texttt{(\$)} e \texttt{(<\$>)}.
Enquanto \texttt{(\$)} permite a aplicação de uma função a valores ``soltos'', o operador \texttt{(<\$>)} aplica a função a valores ``contidos'' em instâncias de \texttt{Functor}.
Com isso, damos os primeiros passos para interpretar estruturas de dados como ``contextos''.

Como Haskell tem suas funções como habitantes de primeira classe, é perfeitamente possível que funções sejam guardadas em estruturas de dados.
Podemos imaginar que essas funções estão sob um certo ``contexto'', e definitivamente queremos utilizá-las (senão não faria sentido guardá-las).
Essa é a motivação básica de \texttt{Applicative}: aplicar funções contidas em estruturas de dados.

\begin{lstlisting}[language=haskell, frame=single]
class Functor f => Applicative (f :: * -> *) where
	pure :: a -> f a
	(<*>) :: f (a -> b) -> f a -> f b
	GHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c
	(*>) :: f a -> f b -> f b
	(<*) :: f a -> f b -> f a
	{-# MINIMAL pure, ((<*>) | liftA2) #-}
\end{lstlisting}

Percebemos que instâncias de \texttt{Applicative} devem ter o mesmo \emph{kind} de instâncias de \texttt{Functor}.
Mais ainda: instâncias de \texttt{Applicative} devem ser também instâncias de \texttt{Functor}.

A função \texttt{pure} é responsável por ``contextualizar'' um valor, de acordo com a expressão em que é usada.
O operador \texttt{(<*>)} aplica as funções contidas em seu primeiro argumento aos valores contidos no segundo.
Trataremos das demais funções de \texttt{Applicative} em breve.

Como exemplo, listas são instância de \texttt{Applicative}.

\begin{lstlisting}[language=haskell, frame=single]
instance Applicative [] where
	pure x = [x]
	
	[] <*> _ = []
	_ <*> [] = []
	(f:fs) <*> xs = f <$> xs ++ fs <*> xs
\end{lstlisting}

Enquanto instância de \texttt{Applicative}, o tipo lista representa computações não-determinísticas.
Ilustramos esse conceito a seguir.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
Prelude> xs = [1,2,3]
Prelude> ys = [10,20,30]
Prelude> (+) <$> xs <$> ys

<interactive>:8:1: error:
	* Couldn't match expected type 'Integer -> b'
			with actual type '[Integer -> Integer]'
	* Possible cause: '(<$>)' is applied to too many arguments
	In the first argument of '(<$>)', namely '(+) <$> xs'
	In the expression: (+) <$> xs <$> ys
	In an equation for 'it': it = (+) <$> xs <$> ys
	* Relevant bindings include it :: [b] (bound at <interactive>:8:1)
Prelude> (+) <$> xs <*> ys
[11,21,31,12,22,32,13,23,33]
Prelude> xs = []
Prelude> (+) <$> xs <*> ys
[]
Prelude> xs = [2]
Prelude> (+) <$> xs <*> ys
[12,22,32]
Prelude> (+) <$> pure 5 <*> ys
[15,25,35]
Prelude> (+) <$> pure 5 <*> pure 7
12
\end{lstlisting}

Vemos que a expressão \texttt{(+) <\$> xs <*> ys} retorna os resultados de todas as aplicações possíveis de \texttt{(+)} aos elementos de \texttt{xs} (como primeiro argumento) e \texttt{ys} (como segudo argumento).
Primeiro, \mbox{\texttt{(+) <\$> xs}} é uma lista de funções, mais precisamente as aplicações parciais de \texttt{(+)} aos elementos de \texttt{xs}.
Com isso, \mbox{\texttt{(+) <\$> xs}} é mais que um \texttt{Functor}, o que fica evidente com a expressão \texttt{(+) <\$> xs <\$> ys}, rejeitada pelo interpretador.

Se pensarmos em \texttt{xs} e \texttt{ys} como resultados de computações não-determinísticas, isto é, de computações que poden ter um número arbitrário de resultados (inclusive nenhum), passamos a ver a expressão \texttt{(+) <\$> xs <*> ys} como a soma de dois valores não-determinísticos, e tal expressão deve representar todas as possibilidades de resultado.

\begin{exercicio}
	Implemente a função \emph{\texttt{sequences :: [a] -> [[a]]}} que, dada uma lista de elementos \emph{\texttt{xs}}, retorna a lista de todas as sequências possíveis formadas por elementos de \emph{\texttt{xs}}.
	As funções \emph{\texttt{iterate}} e \emph{\texttt{concat}} são úteis aqui.
	Pensar de forma indutiva e não-determinística nos leva a definir \emph{\texttt{sequences}} em uma linha!
\end{exercicio}

\begin{exercicio} \label{exercicio:subsets}
	Implemente a função \emph{\texttt{subsets :: [a] -> [[a]]}} que, dada uma lista \emph{\texttt{xs}} sem elementos repetidos, retorna uma lista de listas, onde cada sublista representa um subconjunto de \emph{\texttt{xs}}.
	Pense de forma indutiva: como se obtém os subconjuntos de \emph{\texttt{x:xs}} a partir dos subconjuntos de \emph{\texttt{xs}}?
\end{exercicio}

\begin{exercicio}	\label{exercicio:sequenceA}
	Implemente a função \emph{\texttt{sequenceA :: Applicative f => [f a] -> f [a]}}, que toma uma lista de valores \emph{\texttt{f a}} e constrói uma lista de valores \emph{\texttt{a}}, que é retornada dentro de \emph{\texttt{f}}.
\end{exercicio}

Essa, no entanto, não é a única interpretação plausível que tornaria listas uma instância de \texttt{Applicative}.
É possível pensar, por exemplo, que listas poderiam instanciar \texttt{Applicative} em termos de \texttt{zipWith}.
Como um tipo pode instanciar uma classe no máximo uma vez, adicionamos as seguintes definições a \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
newtype ZipList a = ZL [a]

zipList :: [a] -> ZipList a
zipList xs = ZL xs

getZipList :: ZipList a -> [a]
getZipList (ZL xs) = xs
\end{lstlisting}

Aqui, vemos nosso primeiro uso de \texttt{newtype}.
A palavra \texttt{newtype} permite a construção de tipos muito simples, com um único caso e um único campo.
Com essas restrições, os tipos criados com \texttt{newtype} não são compostos, mas apenas encapsulamentos de tipos já existentes.
Isso não é útil para criar estruturas de dados, mas é muito conveniente para permitir que um tipo instancie uma classe mais de uma vez, agora em suas versões encapsuladas.
Melhor ainda: como \texttt{newtype} pode apenas criar tipos dessa forma, o encapsulamento é desfeito em tempo de compilação, portanto o uso de tipos criados com \texttt{newtype} não traz custos adicionais para a execução de um programa.

Agora, devemos fazer de \texttt{ZipList} uma instância de \texttt{Functor} e \texttt{Applicative}, nessa ordem.

\begin{lstlisting}[language=haskell, frame=single]
instance Functor ZipList where
	fmap f (ZL xs) = ZL (fmap f xs)

instance Applicative ZipList where
	pure = zipList . repeat
	(ZL fs) <*> (ZL xs) = ZL (zipWith ($) fs xs)
\end{lstlisting}

Note que \texttt{ZipList} torna-se instância de \texttt{Functor} com a mesma semântica das listas.
No entanto, \texttt{ZipList} é instância de \texttt{Applicative} com uma semântica iterativa, tornando-se distinta das listas nesse aspecto.
Ilustramos o uso de \texttt{ZipList} a seguir.

\begin{lstlisting}[language=haskell, frame=single]
*List> xs = [1,2,3]
*List> ys = [10,20,30]
*List> (+) <$> xs <*> ys
[11,21,31,12,22,32,13,23,33]
*List> getZipList ((+) <$> zipList xs <*> zipList ys)
[11,22,33]
*List> getZipList ((+) <$> pure 5 <*> zipList ys)
[15,25,35]
\end{lstlisting}

Um outro exemplo de \texttt{Applicative} é \texttt{Maybe}.
Definimos \texttt{Maybe} como \texttt{Applicative} pelo código que segue, escrito em \texttt{Maybe.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Applicative Maybe where
	pure x = Just x
	
	Nothing <*> _ = Nothing
	_ <*> Nothing = Nothing
	(Just f) <*> (Just x) = Just (f x)
\end{lstlisting}

Claramente, \texttt{Maybe} representa computações que podem falhar, tendo nenhum ou exatamente um resultado.
Ilustramos esse conceito a seguir.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> (+) <$> Just 3 <*> Just 4
Just 7
Prelude> (+) <$> Just 3 <*> pure 4
Just 7
Prelude> (+) <$> Just 3 <*> Nothing
Nothing
Prelude> (+) <$> Nothing <*> pure 4
Nothing
\end{lstlisting}

Com isso, vemos que o uso de \texttt{Maybe} enquanto \texttt{Applicative} nos permite criar, a partir de computações que podem falhar, computações maiores com essa mesma semântica.
O uso de \texttt{(<\$>)} e \texttt{(<*>)} nos poupa do trabalho de tratar os casos de \texttt{Maybe}, e nos diz que computações com partes que podem falhar são computações que podem falhar como um todo.

Destacamos o papel de \texttt{pure}, evidenciado por esses exemplos.
Mesmo que uma de nossas computações tenha uma semântica especial, pode haver partes dela que sejam simples computações determinísticas, feitas com o uso de valores \emph{puros}.
A função \texttt{pure} é usada justamente para ``promover'' valores puros para os contextos de funções com semânticas especiais.
Seu uso é indispensável, uma vez que a função \texttt{main} de um programa em Haskell é necessariamente uma função com semântica especial.

O operador \texttt{(<*)} tem o mesmo comportamento de \texttt{(*>)}, porém o papel de seus argumentos é permutado.
Dito isso, nos concentramos em \texttt{(*>)}, cujo papel é aplicar a semântica de seu primeiro argumento (ignorando seus valores) no segundo.
Vamos exemplificar o que isso significa.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> [] *> pure 3
[]
Prelude> [1,2,3] *> pure 3
[3,3,3]
Prelude> [1,2,3] *> [10,20]
[10,20,10,20,10,20]
Prelude> pure 3 *> pure 5
5
Prelude> Just 3 *> pure 5
Just 5
Prelude> Nothing *> pure 5
Nothing
Prelude> Just 3 *> Nothing
Nothing
Prelude> pure 3 *> Nothing
Nothing
\end{lstlisting}

Isso evidencia que \texttt{(*>)} é definido como \texttt{x *> y = f <\$> x <*> y where f \_ q = q}.
O operador \texttt{(*>)} costuma ser utilizado quando se quer tomar apenas o valor semântico de uma computação, ignorando seu resultado.
Por exemplo, \texttt{find p xs *> f xs} vale \texttt{Nothing} ou \texttt{Just (f xs)}, a depender se  há um elemento em \texttt{xs} (ignorado por \texttt{(*>)}) satisfazendo \texttt{p}.

Por fim, a função \texttt{liftA2} traz uma outra forma de se utilizar \texttt{Applicative}.
\texttt{liftA2} encapsula a aplicação explícita de \texttt{(<\$>)} e \texttt{(<*>)}.
Assim, as expressões \texttt{f <\$> x <*> y} e \mbox{\texttt{liftA2 f x y}} são equivalentes.

\begin{exercicio}
	Faça de \emph{\texttt{BSTree k}} uma instância de \emph{\texttt{Applicative}}.
	Qual seria uma semântica adequada para esse tipo?
	Lembre-se de produzir uma árvore binária de busca válida.
\end{exercicio}

\begin{exercicio}
	Faça de \emph{\texttt{SeqTree}} uma instância de \emph{\texttt{Applicative}}.
	Como se trata de uma representação linear de dados, \emph{\texttt{SeqTree}} sofre do mesmo dilema que as listas.
\end{exercicio}

\begin{exercicio}
	Faça de \emph{\texttt{Either a}} uma instância de \emph{\texttt{Applicative}}.
\end{exercicio}

Uma função muito interessante de se implementar é \texttt{when}, que modifica a semântica de um \texttt{Applicative} conforme um valor booleano.
Basicamente, \texttt{when} pode ser usada para condicionar a realização de uma certa computação.
Sua definição é escrita em \texttt{Bool.hs}.

\begin{lstlisting}[language=haskell, frame=single]
when :: Applicative f => Bool -> f () -> f ()
when True x = x
when False _ = pure ()

unless :: Applicative f => Bool -> f () -> f ()
unless = when . not
\end{lstlisting}

Além de \texttt{when}, definimos também sua versão negada, \texttt{unless}.
Por fim, temos \texttt{forever :: Applicative f => f a -> f b}, que repete uma computação indefinidamente.

\begin{lstlisting}[language=haskell, frame=single]
forever :: Applicative f => f a -> f b
forever x = x *> forever x
\end{lstlisting}

Agora vamos falar sobre \texttt{Alternative}, definida em \texttt{Control.Applicative}.

\begin{lstlisting}[language=haskell, frame=single]
class Applicative f => Alternative (f :: * -> *) where
	empty :: f a
	(<|>) :: f a -> f a -> f a
	some :: f a -> f [a]
	many :: f a -> f [a]
	{-# MINIMAL empty, (<|>) #-}
\end{lstlisting}

A classe \texttt{Alternative} é instanciada por tipos que, de alguma forma, trazem o conceito de ser vazio ou não.
A função \texttt{empty} retorna a representação ``vazia'' de um tipo, que geralmente é inferido pela expressão em que \texttt{empty} é utilizada.
O operador \texttt{(<|>)} representa uma espécie de união, e combina dois valores com a propriedade de que \texttt{x <|> y == empty} sse \mbox{\texttt{x == y == empty}}.

As listas são instância de \texttt{Alternative}, da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
instance Alternative [] where
	empty = []
	(<|>) = (++)
\end{lstlisting}

Com isso, podemos instanciar \texttt{ZipList} como \texttt{Alternative} com a seguinte definição, que se encontra em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Alternative ZipList where
	empty = zipList empty
	(ZL xs) <|> (ZL ys) = ZL (xs <|> ys)
\end{lstlisting}

Em se tratando de listas ou \texttt{ZipLists}, a definição de \texttt{Alternative} é bem simples e intuitiva.
O tipo \texttt{Maybe} é instanciado como \texttt{Alternative} com as seguintes definições, que se encontram em \texttt{Maybe.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Alternative Maybe where
	empty = Nothing
	
	Nothing <|> y = y
	x <|> _ = x
\end{lstlisting}

As instâncias de \texttt{Alternative} são particularmente úteis para representar os resultados de computações que podem falhar.
Enquanto computações não-determinísticas, representadas por listas, apenas têm seus resultados mesclados, o tipo \texttt{Maybe} apresenta um comportamento mais interessante:
o segundo argumento de \texttt{(<|>)} é utilizado apenas quando o primeiro argumento representa uma falha.
Dessa forma, podemos criar uma sequência de computações que podem falhar, de tal forma que cada uma delas é executada apenas quando todas as anteriores têm falhado.

\begin{exercicio}
	Escreva a função \emph{\texttt{asum :: Alternative f => [f a] -> f a}}.
	\emph{\texttt{foldr}} é útil para isso.
\end{exercicio}

Descrevemos a função \texttt{guard}, que permite ``traduzir'' um valor booleano, \texttt{True} ou \texttt{False}, para um valor semântico de \texttt{Alternative}, não-vazio ou \texttt{empty}, respectivamente.
Essa definição é escrita em \texttt{Bool.hs}.

\begin{lstlisting}[language=haskell, frame=single]
guard :: Alternative f => Bool -> f ()
guard True = pure ()
guard False = empty
\end{lstlisting}

Numa seção futura, tratarenos de \texttt{Monad}, que leva adiante as abstrações definidas em \texttt{Functor} e \texttt{Applicative}.

\subsection{\texttt{fix} e Programação Dinâmica}

Em Haskell, fazemos uso de recursão tanto para definir tipos como para controlar operações.
É usual que as definições recursivas tenham um caso base, em que há uma expressão simples.
No entanto, temos nos deparado com funções recursivas que não têm um caso base e que, não fosse a preguiça de Haskell, teriam suas chamadas sempre resultando em estouros de pilha.
É o caso das funções \texttt{repeat} e \texttt{cycle}, propostas na Subseção \ref{lab2}.

Temos em \texttt{nats} mais um exemplo desse tipo de definição.

\begin{lstlisting}[language=haskell, frame=single]
nats :: [Int]
nats = 1 : map (+1) nats
\end{lstlisting}

Claramente, \texttt{nats} é baseada na definição indutiva dos naturais, e de fato representa uma lista infinita contendo os naturais.
Observamos o seguinte comportamento:
uma vez que \mbox{\texttt{map (+1)}} retorne uma lista, essa será a cauda da lista retornada por \texttt{(1:)};
além disso, a lista retornada por \texttt{(1:)} é justamente o argumento passado para \texttt{map (+1)}.
Podemos fazer uma análise similar para \texttt{repeat} e \texttt{cycle}.
Reescrevemos \texttt{nats} de forma que isso fique evidente.

\begin{lstlisting}[language=haskell, frame=single]
nats :: [Int]
nats = ((1:) . (map (+1))) nats
\end{lstlisting}

Se admitirmos que \texttt{f = (1:) . (map (+1))}, temos que \texttt{nats = f nats}.
Nesse momento, pode ser bastante estranho e desconfortável perceber que a definição de \texttt{nats} depende exclusivamente de \texttt{f}, uma vez que \texttt{nats}, por mais que seja o argumento passado para \texttt{f}, é o retorno de \texttt{f (f (f (f (...))))}.
Isso pode dar um nó na mente, mas é útil a ponto de generalizarmos esse conceito para funções com argumento e retorno de mesmo tipo.
Escrevemos a seguinte definição em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
fix :: (a -> a) -> a
fix f = f (fix f)
\end{lstlisting}

Embora simples, \texttt{fix} é um tanto estranha.
Ela toma \texttt{f} e deve retornar um elemento de tipo \texttt{a}.
Para isso, ela passa um elemento de tipo \texttt{a} para \texttt{f}, que é justamente \texttt{fix f}.
No fim das contas, \texttt{fix f == f (f (f (f (...))))}.

Bem, não seria muito interessante passar uma função de assinatura \texttt{Int -> Int} para \texttt{fix}, por exemplo, afinal não poderíamos usar seu retorno.

\begin{lstlisting}[language=haskell, frame=single]
*Functions Prelude> fix (+1)
*** Exception: stack overflow
*Functions Prelude>
\end{lstlisting}

Para usá-la de forma útil, é interessante que o retorno de \texttt{f} possa ser construído incrementalmente.
O retorno de \texttt{nats}, por exemplo, cumpre esse requisito por ser uma lista.

\begin{lstlisting}[language=haskell, frame=single]
nats :: [Int]
nats = fix $ (1:) . (map (+1))
\end{lstlisting}

Embora \texttt{fix} não tenha caso base, \texttt{nats} pode ser usada mesmo que seja escrita dessa forma, por conta da preguiça de Haskell.

\begin{exercicio}
	Escreva as funções \emph{\texttt{repeat}} e \emph{\texttt{cycle}} em termos de \emph{\texttt{fix}}.
\end{exercicio}

\begin{exercicio}
	Defina \emph{\texttt{iterate}} em termos de \emph{\texttt{fix}}.
\end{exercicio}

\begin{exercicio}
	Implemente \emph{\texttt{forever}} em termos de \emph{\texttt{fix}}.
\end{exercicio}

\pagebreak

\begin{exercicio}
	Tome a função \emph{\texttt{range}} definida como segue.
\begin{lstlisting}[language=haskell, frame=single]
range :: Int -> [Int]
range 0 = [0]
range x = x : range (x - 1)
\end{lstlisting}
	Escreva \emph{\texttt{range}} em termos de \emph{\texttt{fix}}.
\end{exercicio}

\begin{exercicio}	\label{exercicioFixFactorial}
	Tome a seguinte função.
\begin{lstlisting}[language=haskell, frame=single]
f :: (Int -> Int) -> Int -> Int
f _ 0 = 1
f rec n = n * rec (n - 1)
\end{lstlisting}
A função \emph{\texttt{f}} parece estar calculando fatorial, mas é bizarra.
Ela ``conhece'' a definição de fatorial, mas não podemos dizer que ela é recursiva, pois se define em termos de \emph{\texttt{rec}}.
No entanto, se \emph{\texttt{rec}} calculasse fatorial, \emph{\texttt{f rec}} seria umaa definição plausível de fatorial.
Defina \mbox{\emph{\texttt{fact :: Int -> Int}}}, que calcula fatorial, em termos de \emph{\texttt{f}} e \emph{\texttt{fix}}.
\end{exercicio}

No Exercício \ref{exercicioFixFactorial}, nos deparamos com uma prática um tanto peculiar: criar uma versão não-recursiva de uma função recursiva, fazendo sua chamada recursiva em termos de uma outra função de mesma assinatura, recebida como argumento.
Embora o Exercício \ref{exercicioFixFactorial} use essa ``decomposição'' de maneira fútil, podemos ir mais adiante.
É possível, por exemplo, ``decompor'' uma função recursiva \texttt{f} e deixar suas chamadas recursivas a cargo de uma versão ``especial'' de \texttt{f}.
Esse conceito pode ser utilizado para, dentre outras coisas, implementar versões memoizadas de funções recursivas.

Para ilustrar essa ideia, vamos tomar um caso clássico.

\begin{lstlisting}[language=haskell, frame=single]
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
\end{lstlisting}

Basta uma verificação superficial para constatar que \texttt{fib} retorna o \texttt{n}-ésimo número de Fibonacci, e que essa não é uma boa implementação.
Por diversão, vamos tomar medidas do quão ruim ela é.
Para isso, vamos criar um arquivo \texttt{Memo.hs}, com o seguinte conteúdo inicial (provisório), e escrever a definição de \texttt{fib} nesse arquivo.

\begin{lstlisting}[language=haskell, frame=single]
module Memo where

import Prelude (Int, (-), (+))

import Functions
import List
\end{lstlisting}

Agora vamos aos testes.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
Prelude> :l Memo
[1 of 1] Compiling Memo             ( Memo.hs, interpreted )
Ok, one module loaded.
*Memo> :set +s
*Memo> fib 10
55
(0.01 secs, 92,888 bytes)
*Memo> fib 15
610
(0.01 secs, 388,032 bytes)
*Memo> fib 20
6765
(0.01 secs, 3,655,320 bytes)
*Memo> fib 25
75025
(0.12 secs, 39,882,672 bytes)
*Memo> fib 30
832040
(0.79 secs, 441,642,736 bytes)
*Memo> fib 35
9227465
(8.21 secs, 4,897,222,696 bytes)
*Memo>
\end{lstlisting}

Vamos analisar rapidamente o uso de tempo e espaço.
Observamos que, da chamada \mbox{\texttt{fib 25}} para \texttt{fib 30}, o tempo de execução aumentou cerca de $6,5$ vezes, enquanto de \texttt{fib 30} para \mbox{\texttt{fib 35}} o aumento foi de aproximadamente $10,4$ vezes.
Isso não é muito animador.
Quanto ao uso de espaço, não é preciso muita experiência para estranhar o fato de \texttt{fib 35} ter gasto quase cinco gigabytes de memória.
Nesse pequeno experimento, a única coisa boa que aprendemos foi o uso de \texttt{:set +s} para exibir tempo de execução e uso de memória.

\begin{exercicio}	\label{exercicio:fix2}
	Considere a seguinte definição.
	\begin{lstlisting}[language=haskell, frame=single]
	fix2 :: (a -> a) -> a
	fix2 f = y where y = f y
	\end{lstlisting}
	Observe o seguinte experimento.
	\begin{lstlisting}[language=haskell, frame=single]
	*Functions Prelude> :set +s
	*Functions Prelude> f x = fix (x:)
	(0.00 secs, 0 bytes)
	*Functions Prelude> g x = fix2 (x:)
	(0.00 secs, 0 bytes)
	*Functions Prelude> head (drop 10000000 (f 2))
	2
	(1.21 secs, 640,063,368 bytes)
	*Functions Prelude> head (drop 10000000 (g 2))
	2
	(0.07 secs, 63,416 bytes)
	\end{lstlisting}
	Explique o que torna \emph{\texttt{fix2}} mais eficiente que \emph{\texttt{fix}}.
\end{exercicio}

Em vista do desastre que é a atual implementação de \texttt{fib}, propomos uma solução eficiente e elegante, que é praticamente um mascote da linguagem Haskell.

\begin{lstlisting}[language=haskell, frame=single]
fib :: Int -> Int
fib = (fibs !!) where
	fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{lstlisting}

Nessa implementação, \texttt{fib} recebe \texttt{n} e toma o \texttt{n}-ésimo elemento de uma lista.
Essa lista é justamente uma definição recursiva para a sequência de Fibonacci.

Escrita dessa forma, \texttt{fib} é eficiente porque, uma vez que os elementos de \texttt{fibs} são calculados, não há a necessidade de recalculá-los.
Note como a primeira versão de \texttt{fib} precisa calcular um número de Fibonacci mais de uma vez.
Enfim, vamos aos testes.

\begin{lstlisting}[language=haskell, frame=single]
*Memo> :set +s
*Memo> fib 35
9227465
(0.14 secs, 84,040 bytes)
*Memo> fib 35
9227465
(0.00 secs, 71,760 bytes)
*Memo>
\end{lstlisting}

Perceba que, na primeira chamada \texttt{fib 35}, o elemento correspondente em \texttt{fibs} ainda não havia sido calculado.
Como a segunda chamada não precisava calcular esse elemento, mas apenas retorná-lo, seu tempo de execução é irrisório.

Essa refatoração de \texttt{fib} exibe uma maneira muito elegante de se determinar a sequência de Fibonacci, e com isso armazená-la como uma lista na memória, produzindo uma espécie de \emph{cache} para \texttt{fib}.
No entanto, essa abordagem não se generaliza para outras funções, já que usa algo característico dos números de Fibonacci para produzir uma \emph{cache}.

Uma terceira forma de escrever \texttt{fib} é apresentada abaixo.

\begin{lstlisting}[language=haskell, frame=single]
fib :: Int -> Int
fib = fix f where
	f _ 0 = 0
	f _ 1 = 1
	f rec n = rec (n - 1) + rec (n - 2)
\end{lstlisting}

É aqui que entramos na toca do coelho.
Primeiro, \texttt{fix} permite que a função \texttt{f} receba \mbox{\texttt{f (f (f (f (...))))}} como seu primeiro argumento.
Segundo, isso é equivalente à nossa primeira definição de \texttt{fib}.
Então por que escrevê-la de uma forma mais complicada?
Antes de responder a essa pergunta, testamos essa definição.

\begin{lstlisting}[language=haskell, frame=single]
*Memo> :set +s
*Memo> fib 35
9227465
(22.00 secs, 11,892,075,208 bytes)
*Memo>
\end{lstlisting}

Essa versão é ainda pior!
Mas não tiramos proveito da ``decomposição'' da primeira versão de \texttt{fib}, aqui expressa como \texttt{f}.
%Ao usarmos \texttt{fix} para fazer \texttt{f} ser seu próprio primeiro argumento, apenas obtemos uma pequena evidência de que essa definição é equivalente à original.
%No entanto,
Se \texttt{rec} fosse uma versão eficiente de \texttt{f}, teríamos obtido uma implementação eficiente para \texttt{fib}.

Como \texttt{fib} tem assinatura \texttt{Int -> Int} e espera um argumento não-negativo, tratamos de criar um esquema de \emph{cache} adequado para funções com essas características.

\begin{lstlisting}[language=haskell, frame=single]
memo :: (Int -> b) -> Int -> b
memo f = (ys !!) where
	xs = iterate (+1) 0
	ys = map f xs
\end{lstlisting}

A definição de \texttt{memo} é bastante ingênua, estúpida até.
Para uma função \mbox{\texttt{f :: Int -> Int}} que espere argumentos não-negativos, \texttt{f} e \texttt{memo f} são equivalentes.
No entanto, há uma diferença na forma como produzem seus retornos.
Dado um argumento \texttt{n}, todas as chamadas \mbox{\texttt{f n}} teriam o mesmo custo computacional.
Por outro lado, fazendo \texttt{g = memo f}, a primeira chamada \texttt{g n} teria o mesmo custo de \texttt{f n}, valor esse que ficaria salvo em \texttt{ys}, de forma que as chamadas seguintes \texttt{g n} apenas buscariam pelo valor salvo.

Tomando a primeira versão de \texttt{fib}, é tentador considerar que \mbox{\texttt{memofib = memo fib}} seja eficiente.
Perceba, todavia, que \texttt{memofib} tem o mesmo custo de \texttt{fib} sempre que chamada para um novo argumento.

\begin{lstlisting}[language=haskell, frame=single]
*Memo> memofib = memo fib
*Memo> :set +s
*Memo> memofib 35
9227465
(8.17 secs, 4,897,239,864 bytes)
*Memo> memofib 35
9227465
(0.00 secs, 71,760 bytes)
*Memo> memofib 36
14930352
(13.08 secs, 7,923,836,624 bytes)
*Memo> memofib 37
24157817
(21.13 secs, 12,820,992,200 bytes)
*Memo>
\end{lstlisting}

Esse experimento evidencia outra coisa muito chata sobre \texttt{memofib}.
As duas chamadas \texttt{memofib 35} nos mostram que os retornos de \texttt{fib} realmente estão sendo salvos por \texttt{memo}.
Porém, uma vez salvos \texttt{fib 35} e \texttt{fib 36}, era de se esperar que \texttt{memofib 37} tivesse um custo bem mais baixo que o apresentado.
É por isso que precisamos de \texttt{fix}.

Tomando \texttt{f} como a versão ``decomposta'' de \texttt{fib}, \texttt{f rec} é uma implementação eficiente de \texttt{fib} desde que \texttt{rec} também seja.
Ora, nesse caso \texttt{memo (f rec)} é uma implementação eficiente de \texttt{fib}.
Usamos \texttt{fix} para ligar as duas pontas.

\begin{lstlisting}[language=haskell, frame=single]
fib :: Int -> Int
fib = fix (memo . f) where
	f _ 0 = 0
	f _ 1 = 1
	f rec n = rec (n - 1) + rec (n - 2)
\end{lstlisting}

E aqui começa a festa do chá.
Vamos usar a sanidade que nos resta para testar essa definição de \texttt{fib}.

\begin{lstlisting}[language=haskell, frame=single]
*Memo> :set +s
*Memo> fib 35
9227465
(0.02 secs, 1,366,096 bytes)
*Memo> fib 35
9227465
(0.00 secs, 71,760 bytes)
*Memo> fib 36
14930352
(0.00 secs, 255,872 bytes)
*Memo> fib 36
14930352
(0.00 secs, 72,616 bytes)
*Memo> fib 37
24157817
(0.00 secs, 265,512 bytes)
*Memo> fib 37
24157817
(0.00 secs, 72,736 bytes)
*Memo>
\end{lstlisting}

Conseguimos mais uma versão de \texttt{fib} verdadeiramente eficiente.
Para entender como ela funciona, note que \texttt{f} ignora seu primeiro argumento nos casos base.
Isso e a preguiça de Haskell impedem \texttt{fix} de provocar um estouro de pilha.
Observe também que, graças a \texttt{fix}, \mbox{\texttt{g = memo . f}} recebe \texttt{g (g (g (g (...))))} como primeiro argumento.
Para entender a importância disso, perceba que \texttt{memo . f} retorna uma versão eficiente de \texttt{f} quando recebe uma versão eficiente de \texttt{f}.
Nesse caso, basta passar para \texttt{memo . f} a função \texttt{memo . f} recebendo uma versão eficiente de \texttt{f}.
Mas isso contém o mesmo problema da situação anterior!
É aí que entra \texttt{fix}, permitindo passar \texttt{memo . f} para \texttt{memo . f} infinitamente.
%, resultando em uma função \mbox{\texttt{Int -> Int}} que sempre salva os valores que computa (via \texttt{memo}) e segue a lógica recursiva dos números de Fibonacci (via \texttt{f}).

Com tudo isso, criamos uma boa implementação para \texttt{fib} baseada em \emph{cache}, mas dessa vez a implementação da \emph{cache} é genérica.
Bem, genérica para funções \texttt{f :: Int -> Int} que esperam argumentos não-negativos: ``decompomos'' \texttt{f} em \mbox{\texttt{f' :: (Int -> Int) -> Int -> Int}} e fazemos \texttt{fix (memo . f')}.
Mas e quanto a funções quaisquer \texttt{a -> b}?

Antes de abordar essa questão, vamos resolver uma mais simples.
Representar a \emph{cache} como uma lista infinita não é a abordagem mais eficiente, por conta de seu acesso em tempo linear.
Vamos, portanto, representar a \emph{cache} como uma árvore binária.
Para isso, precisamos de uma árvore binária infinita, definida em \texttt{InfinityTree.hs} como segue.

\begin{lstlisting}[language=haskell, frame=single]
module InfinityTree (InfinityTree(Branch), find) where

import Prelude (Int, (==), (-), divMod,
                Functor(fmap), Applicative(pure, (<*>)))

import Bool

data InfinityTree a = Branch a (InfinityTree a) (InfinityTree a)

instance Functor InfinityTree where
	fmap f (Branch x lt rt) = Branch (f x) (fmap f lt) (fmap f rt)

instance Applicative InfinityTree where
	pure x = Branch x (pure x) (pure x)

	(Branch f flt frt) <*> (Branch x xlt xrt) =
		Branch (f x) (flt <*> xlt) (frt <*> xrt)

find :: InfinityTree a -> Int -> a
find (Branch x _ _) 0 = x
find (Branch _ lt rt) n = cond (r == 1)
                               (find lt q)
                               (find rt (q - 1)) where
    (q, r) = divMod n 2
\end{lstlisting}

A definição de \texttt{InfinityTree} representa uma árvore infinita, já que não permite folhas em sua estrutura.
A única função de acesso a seus elementos é \texttt{find}, que ``passeia'' pela árvore conforme a paridade de um \texttt{Int} dado como entrada:
um número ímpar (par) leva a busca para a esquerda (direita).

Com isso, podemos escrever uma versão mais eficiente de \texttt{memo}, que representa a \emph{cache} em uma estrutura arbórea.

\begin{lstlisting}[language=haskell, frame=single]
memo :: (Int -> b) -> Int -> b
memo f = find ftree where
	natTree = Branch 0 oddTree evenTree where
		oddTree = ((+1) . (*2)) <$> natTree
		evenTree = ((+2) . (*2)) <$> natTree
	ftree = f <$> natTree
\end{lstlisting}

Perceba que apenas a estrutura utilizada internamente sofreu modificações.
Com isso, a nova implementação de \texttt{memo} tem a mesma assinatura da anterior, e portanto nossa definição de \texttt{fib} não precisa de alterações.
Vamos fazer novos testes.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
*Memo> :set +s
*Memo> fib 35
9227465
(0.01 secs, 1,440,632 bytes)
*Memo> fib 35
9227465
(0.00 secs, 69,872 bytes)
*Memo> fib 36
14930352
(0.00 secs, 240,064 bytes)
*Memo> fib 36
14930352
(0.00 secs, 70,680 bytes)
*Memo> fib 37
24157817
(0.00 secs, 246,248 bytes)
*Memo> fib 37
24157817
(0.00 secs, 70,680 bytes)
*Memo>
\end{lstlisting}

\begin{exercicio}
	Verifique se existe ganho de desempenho em definir \emph{\texttt{fib}} em termos de \emph{\texttt{fix2}}, definida no Exercício \ref{exercicio:fix2}.
\end{exercicio}

Isso evidencia que a nova implementação de \texttt{memo} traz algum ganho.
Infelizmente, como é preciso planejar as próximas aulas, não abordaremos memoização para funções \texttt{a -> b}.
Isso fica para a próxima versão da disciplina.

\begin{exercicio}
	Escreva uma função \emph{\texttt{decomp37 :: Int -> Maybe (Int, Int)}} que, dada uma entrada não-negativa $n$, decide se existem $x, y \in \mathbb{N}$ tais que $n = 3x + 7y$, e caso existam, retorna o par $(x, y)$.
	É fácil escrever essa função tirando proveito de \emph{\texttt{Maybe}} ser instância de \emph{\texttt{Applicative}} e \emph{\texttt{Alternative}}.
	Use \emph{\texttt{memo}} e \emph{\texttt{fix}} para criar uma implementação eficiente.
\end{exercicio}

\begin{exercicio}
	Escreva uma função \emph{\texttt{primeFactors :: Int -> [Int]}}, que retorna a decomposição em fatores primos de uma entrada não-negativa $n$.
	Para facilitar, crie uma lista infinita com todos os primos.
	Basta encontrar o menor primo $p$ divisor de $n$ e retorná-lo como cabeça, fazendo da cauda a chamada recursiva para $n / p$.
	Use \emph{\texttt{memo}} e \emph{\texttt{fix}} para implementar memoização em \emph{\texttt{primeFactors}}.
\end{exercicio}

\begin{exercicio}
	Dadas moedas de $2, 3$ e $7$ centavos, vamos expressar $x$ centavos, se possível, com o menor número de moedas.
	A função \mbox{$f(x) = 1 + \min \{f(x - 2), f(x - 3), f(x - 7)\}$} representa uma relação de recorrência que resolve esse problema.
	Determine os casos base e desenvolva uma função \emph{\texttt{minCoins :: Int -> Maybe Int}}.
	Note que, para valores altos de $x$, a função $f$ é computada mais de uma vez para alguns argumentos.
	Use \emph{\texttt{memo}} e \emph{\texttt{fix}} para evitar computar $f$ mais de uma vez para o mesmo argumento.
	Tire proveito de \emph{\texttt{Maybe}} ser \emph{\texttt{Applicative}}.
\end{exercicio}

\subsection{Mônadas}

Já temos visto aplicações simples de funções, que costumam ser representadas pelo operador \mbox{\texttt{(\$) :: (a -> b) -> a -> b}}.
Vimos também aplicações de funções simples a elementos contidos em um certo contexto.
Esse tipo de aplicação é representado pelo operador \mbox{\texttt{(<\$>) :: Functor f => (a -> b) -> f a -> f b}}.
Inclusive, quando uma estrutura de dados permite que seu conteúdo seja trnsformado por uma função simples, ela pode ser vista como uma instância de \texttt{Functor}.
Por último, nos deparamos com aplicações de funções, em um certo contexto, a elementos em um contexto semelhante.
Essa forma de aplicação está associada ao operador \mbox{\texttt{(<*>) :: Applicative f => f (a -> b) -> f a -> f b}}.
Quando uma estrutura de dados permite que seu conteúdo seja operado por funções contidas em uma estrutura similar, ela pode ser feita uma instância de \texttt{Applicative}.

Agora, vamos analisar funções que produzem um contexto a partir de elementos simples.
Tais funções são ditas \emph{monádicas}, e contextos que podem ser criados a partir de elementos simples são representados por estruturas que chamamos de \emph{mônadas}.
Tais tipos são agrupados na seguinte classe.

\begin{lstlisting}[language=haskell, frame=single]
class Applicative m => Monad (m :: * -> *) where
	(>>=) :: m a -> (a -> m b) -> m b
	(>>) :: m a -> m b -> m b
	return :: a -> m a
	fail :: String -> m a
	{-# MINIMAL (>>=) #-}
\end{lstlisting}

Aqui, vemos um operador que utilizamos bastante nos laboratórios.
Finalmente vamos entender \texttt{(>>=)}!

Em linhas gerais, o operador \texttt{(>>=)} toma valores do tipo \texttt{a} contidos em \texttt{m a}, onde \texttt{m} é uma mônada, e transforma cada um deles em \texttt{m b}, produzindo uma estrutura de tipo \texttt{m (m b)}.
Vale ressaltar que isso também seria possível com um \texttt{Functor}, mas \texttt{Functor} não é o bastante para lidar com esse aninhamento de contextos.
Em seguida, \texttt{(>>=)} ``combina'' os contextos interno e externo, produzindo a saída de tipo \texttt{m b}.

Antes de entendermos essa ``combinação'', vamos falar a respeito das demais funções que compõem a classe \texttt{Monad}.
O operador \texttt{(>>)} ignora o conteúdo de \texttt{m a}, mas faz com que seu valor semântico influencie \texttt{m b}, produzindo a saída.
Não há diferença entre \texttt{(>>)} e \texttt{(*>)}.
Como \texttt{Applicative} é mais abrangente que \texttt{Monad}, preferimos fazer uso de \texttt{(*>)}.

A função \texttt{return} é equivalente a \texttt{pure}, e sua presença em \texttt{Monad} apenas cumpre o papel de não ``quebrar'' \emph{legacy code}.
Isso se deve a uma época em que as instâncias de \texttt{Monad} não precisavam ser instâncias de \texttt{Applicative}.
Preferimos sempre o uso de \texttt{pure}, pois \texttt{return} leva esse nome para, dada a forma como é usada em \emph{do notation}, fazer analogia ao paradigma imperativo.
Por fim, a presença de \texttt{fail} em \texttt{Monad} é depreciada, e portanto a ignoramos.

Uma função muito importante para a concepção matemática de mônadas, mas que não faz parte de \texttt{Monad}, é \texttt{join :: Monad m => m (m a) -> m a}.
Dificilmente precisaremos utilizá-la para instanciar \texttt{Monad}, mas conhcê-la pode nos permitir um melhor entendimento da ``combinação'' de contextos.
Inclusive, a única finalidade de \texttt{join} é ``combinar'' contextos.

Vamos apresentar nossa primeira mônada, fazendo com que \texttt{Maybe} instancie \texttt{Monad}.
As definições que seguem devem ser escritas em \texttt{Maybe.hs}.

\begin{lstlisting}[language=haskell, frame=single]
instance Monad Maybe where
	Nothing >>= _ = Nothing
	(Just x) >>= f = f x
\end{lstlisting}

Analisar uma instância de \texttt{Monad} nos permite ver com mais clareza o que faz \texttt{(>>=)}, e porque ele costuma ser chamado de \emph{binding operator}.
Para \texttt{Maybe}, \texttt{(>>=)} retorna \texttt{Nothing} tão logo seu primeiro argumento é \texttt{Nothing}, do contrário aplica seu conteúdo a \texttt{f}, produzindo a saída.

\begin{exercicio}
	Faça de \emph{\texttt{Maybe}} uma instância de \emph{\texttt{Monad}}, definindo \emph{\texttt{(>>=)}} como uma chamada de \emph{\texttt{maybe}}.
\end{exercicio}

No contexto de \texttt{Maybe}, o operador \texttt{(>>=)} permite a criação de uma cadeia de computações que falha quando uma de suas partes falha.
Com o uso de \texttt{pure}, podemos encadear computações determinísticas, que produzem exatamente um resultado, com computações que podem falhar.
Dessa forma, uma computação que produz \texttt{m a} pode ter seu resultado passado como entrada para uma computação que produz \texttt{m b}, e essa pode ser ``encaixada'' na entrada de uma terceira computação.
Dizemos que \texttt{(>>=)} permite o \emph{binding} de computações.

Agora, vamos ilustrar como o tipo lista instancia a classe \texttt{Monad}.

\begin{lstlisting}[language=haskell, frame=single]
instance Monad [] where
	xs >>= f = concat $ f <$> xs
\end{lstlisting}

Podemos perceber que essa implementação de \texttt{(>>=)} evidencia a ``combinação'' de contextos, isto é, transforma uma lista de listas em uma lista simples.
Primeiro, \texttt{f <\$> xs} tem tipo \texttt{[[b]]}, e depois esse aninhamento de contextos é resolvido com \texttt{concat}.
Para listas, portanto, \mbox{\texttt{join = concat}}.

Para o exercício que segue, vamos precisar da função identidade.
Sua definição é escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
id :: a -> a
id x = x
\end{lstlisting}

\begin{exercicio}
	Defina \emph{\texttt{join}} em termos de \emph{\texttt{(>>=)}} e \emph{\texttt{id}}.
\end{exercicio}

\begin{exercicio}
	Aqui, assumimos que são dadas implementações para as funções \mbox{\emph{\texttt{fmap}}} e \mbox{\emph{\texttt{join}}}.
	Escreva uma implementação para \emph{\texttt{(>>=)}} em termos de \emph{\texttt{fmap}} e \emph{\texttt{join}}.
\end{exercicio}

Como listas representam computações não-determinísticas, chamamos a atenção para o impacto de \texttt{concat} quando usamos \texttt{(>>=)} para construir uma cadeia de computações não-determinísticas.
Tome, por exemplo, uma cadeia de $k$ computações não-determinísticas, em que cada uma produz dois resultados.
O uso de um \texttt{concat} por \emph{binding} vai produzir, ao final da cadeia, uma lista representando os $2^k$ resultados possíveis.

\begin{exercicio} \label{exercicio:foldM}
	De forma similar a \emph{\texttt{foldl :: (b -> a -> b) -> b -> [a] -> b}}, implemente a função \emph{\texttt{foldM :: Monad m => (b -> a -> m b) -> b -> [a] -> m b}}.
\end{exercicio}

\begin{exercicio}
	Tome a função \emph{\texttt{f xs x = [xs, x:xs]}}.
	Podemos interpretar \emph{\texttt{f}} como uma computação não-determinística, que pode retornar tanto \emph{\texttt{xs}} como \emph{\texttt{x:xs}}.
	Reimplemente \emph{\texttt{subsets}}, proposta inicialmente no Exercício \ref{exercicio:subsets}, como uma chamada de \emph{\texttt{foldM}}.
\end{exercicio}

É natural nos perguntarmos o porquê dessa tendência de Haskell interpretar estruturas como semânticas, encapsulando-as em aplicadores especiais de funções.
Haskell poderia muito bem deixar mais explícita a pureza de suas funções se não usasse tal artifício, e em troca escreveríamos definições mais extensas.
No entanto, é esse artifício que permite uma representação para a impureza.
Vamos falar da mônada \texttt{IO}.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> :info IO
newtype IO a
	= GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
		-> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
-- Defined in 'GHC.Types'
instance Applicative IO -- Defined in 'GHC.Base'
instance Functor IO -- Defined in 'GHC.Base'
instance Monad IO -- Defined in 'GHC.Base'
instance Monoid a => Monoid (IO a) -- Defined in 'GHC.Base'
instance Semigroup a => Semigroup (IO a) -- Defined in 'GHC.Base'
\end{lstlisting}

Não entre em pânico.
Basicamente, isso significa que \texttt{IO a} encapsula uma função que, dado um estado do mundo real, retorna um (possivelmente novo) estado mundo real junto de um valor do tipo \texttt{a}.
Dessa forma, não devemos esperar que, dada \texttt{f :: a -> IO b}, \texttt{f x} tenha sempre o mesmo valor, uma vez que o valor contido em \texttt{IO b} depende também do estado do mundo real.
Inclusive, \texttt{IO b} não apenas depende, mas pode alterar o estado do mundo real.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> f _ = getLine
Prelude> :t f
f :: p -> IO String
Prelude> :t (==) <$> f 1 <*> f 1
(==) <$> f 1 <*> f 1 :: IO Bool
Prelude> (==) <$> f 1 <*> f 1
aaa
aaa
True
Prelude> (==) <$> f 1 <*> f 1
aaa
bbb
False
\end{lstlisting}

Perceba que não é verdade que \texttt{f 1} é sempre igual a \texttt{f 1}.
O conteúdo da \texttt{IO} que \texttt{f} retorna pode mudar, mesmo que seja usado o mesmo argumento.
Mas como isso pode ser possível?
As função de Haskell são puras!
A função \texttt{f}, inclusive, é pura, mas seu retorno não é o valor de um tipo simples.
O retorno de \texttt{f} traz consigo a semântica da impureza, representada pela mônada \texttt{IO}.
Em suma, \texttt{f} é pura como qualquer outra função, mas seu retorno é impuro.
É como se \texttt{IO} fosse mais uma advertência do que um tipo.

A necessidade prática de se trabalhar com impurezas obriga Haskell a ter uma forma de lidar com elas, do contrário Haskell seria inútil, incapaz de interagir com as coisas do mundo real (como a arquitetura de um computador).
Em seus anos iniciais, havia diversas propostas de como as impurezas deveriam estar presentes em Haskell.
Em algum momento houve o consenso de atribuir semântica a tipos de \emph{kind} \texttt{* -> *}, e um tipo com esse \emph{kind} teria o papel de indicar a impureza de seu conteúdo.
Assim, houve a adoção das classes \texttt{Functor}, \texttt{Applicative} e \texttt{Monad}, representando conceitos que já existiam na Matemática.

Como sua implementação envolve elementos de baixo nível do compilador, não podemos ``abrir'' \texttt{IO} da mesma forma que fazemos com \texttt{Maybe} ou listas.
Aí vem a outra sacada da adoção de \texttt{Functor}, \texttt{Applicative} e \texttt{Monad}:
com as funções definidas nessas classes, não precisamos ``abrir'' nenhuma de suas instâncias.
Embora possamos ``abrir'' \texttt{Maybe}, é mais coveniente usar as funções de \texttt{Functor}, \texttt{Applicative} e \texttt{Monad} para tratar esse tipo.
No caso de \texttt{IO}, não se trata de coveniência.
Essas três classes permitem que trabalhemos com valores impuros sem nos preocupar de onde vem sua impureza, ou como tais valores são implementados.
Assim, \texttt{IO} é uma espécie de mônada ``mágica'', e o encapsulamento que promove permite que as definições de Haskell não se atenham a detalhes de baixo nível.

Agora, vamos lidar com algumas funções que nos auxiliam no tratamento de mônadas.
Primeiro, definimos \texttt{mapM} em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f [] = pure []
mapM f (x:xs) = f x >>= \x' ->
                mapM f xs >>= \xs' ->
                pure  (x' : xs')
\end{lstlisting}

Nessa definição, fizemos uso de \emph{funções anônimas}.
Essencialmente, podemos definir uma função sem dá-la um nome utilizando \texttt{\char`\\} seguido de seus argumentos, com \texttt{->} indicando a definição da função.
Por exemplo, podemos definir uma função sem dá-la um nome por meio de uma aplicação parcial, como em \texttt{(+1)}, ou através de um função anônima, como em \mbox{\texttt{\char`\\x -> x + 1}}.

Funções anônimas são especialmente úteis para definir o segundo argumento de \texttt{(>>=)}.
Quando \texttt{(>>=)} ``abre'' seu primeiro argumento, é interessante podermos referenciar o seu ``conteúdo''.
Usamos uma função anônima para receber esse ``conteúdo'', e assim podemos referenciá-lo através do argumento da função.
Na definição de \texttt{mapM}, existem duas funções anônimas:
a primeira recebe um argumento \texttt{x'} (``conteúdo'' de \texttt{f x}) e é definida como uma chamada de \texttt{(>>=)};
a segunda, que ocorre dentro da primeira, recebe um argumento \texttt{xs'} (``conteúdo'' de \texttt{mapM f xs}) e retorna \texttt{x':xs'} no contexto adequado.
Note que, devido a essas duas funções anônimas serem aninhadas, podemos usar o argumento da primeira dentro da segunda.

Preferimos essa definição de \texttt{mapM}, pois com ela podemos falar de funções anônimas e evidenciá-las como um bom recurso ao utilizar-se \texttt{(>>=)}.
Existe, no entanto, uma definição bem mais simples de \texttt{mapM}.

\begin{exercicio} \label{exercicio:mapM}
	Defina \emph{\texttt{mapM}} em termos de \emph{\texttt{map}} e \emph{\texttt{sequenceA}}, proposta no Exercício \ref{exercicio:sequenceA}.
\end{exercicio}

O Exercício \ref{exercicio:mapM} pode nos deixar pensando que \texttt{mapM} não precisa ser restrita a \texttt{Monad}, mas apenas a \texttt{Applicative}.
De fato, isso é verdade.
No entanto, como o primeiro argumento de \texttt{mapM} é uma função \texttt{a -> m b}, uma função que cria um contexto a partir de um elemento simples, ela é restrita a \texttt{Monad} não por necessidade, mas pelo fato de receber uma função monádica.

Vamos definir \texttt{mapM\char`_ \quad:: Monad m => (a -> m b) -> [a] -> m ()}, que ignora os resultados produzidos pela função monádica.
A definição que segue deve ser escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f [] = pure ()
mapM_ f (x:xs) = f x *> mapM_ f xs
\end{lstlisting}

Eis uma breve ilustração do uso de \texttt{mapM\char`_}.

\begin{lstlisting}[language=haskell, frame=single]
*Functions> import Prelude (putStrLn)
*Functions Prelude> mapM_ putStrLn ["aaa", "bbb", "ccc"]
aaa
bbb
ccc
\end{lstlisting}

\begin{exercicio}
	Implemente \emph{\texttt{sequenceA\char`_ \quad:: Applicative f => [f a] -> f ()}}, que é similar a \emph{\texttt{sequenceA}}, proposta no Exercício \ref{exercicio:sequenceA}, mas ignora os resultados das computações.
\end{exercicio}

\begin{exercicio}
	Defina \emph{\texttt{mapM\char`_}} em termos de \emph{\texttt{sequenceA\char`_}} e \emph{\texttt{map}}.
\end{exercicio}

Após uma longa sequência de abstrações, tratamos de coisas mais concretas.
Vamos lidar com aspectos da linguagem que tem impacto direto no desempenho de nossos programas.

\subsection{Avaliação estrita e Paralelismo}

\epigraph{O conteúdo desta subseção é baseado no livro \emph{Parallel and Concurrent Programming in Haskell}, de Simon Marlow.}{}

Como bem sabemos, Haskell é uma linguagem de programação com avaliação preguiçosa, isto é, as definições de valores são avaliadas apenas quando esses são necessários.
Podemos verificar isso.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> x = 1 + 1 :: Int
Prelude> :sprint x
x = _
Prelude> x
2
Prelude> :sprint x
x = 2
\end{lstlisting}

Aqui, observamos o uso de \texttt{:sprint}, um comando especial do \texttt{ghci} que não faz parte da linguagem Haskell.
A função de \texttt{:sprint} é verificar o valor associado a um identificador, sem forçar sua avaliação: quando o identificador já foi avaliado, seu valor é exibido; caso contrário, exibe-se \texttt{\char`_}.
Percebemos, portanto, que \texttt{x} não foi avaliado assim que foi definido.
Quando exibimos o valor de \texttt{x}, no entanto, ele precisa ser avaliado.
Vamos tentar algo um pouco mais elaborado.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> x = 1 + 1 :: Int
Prelude> y = x + 1 :: Int
Prelude> :sprint x
x = _
Prelude> :sprint y
y = _
Prelude> seq y "eita"
"eita"
Prelude> :sprint x
x = 2
Prelude> :sprint y
y = 3
\end{lstlisting}

Claramente, \texttt{x} e \texttt{y} não foram avaliados assim que definidos.
Vamos dizer que \texttt{x} e \texttt{y} estavam \emph{suspensos}.
Jamais chegamos a exibir os valores de \texttt{x} e \texttt{y}, e mesmo assim eles foram avaliados.

Isso aconteceu por conta de \texttt{seq :: a -> b -> b}, que faz a avaliação do segundo argumento implicar na avaliação do primeiro.
Assim, quando o segundo argumento de \texttt{seq} precisa ser avaliado, a avaliação do primeiro é forçada.
Apesar do que seu nome sugere, \texttt{seq} não garante que, uma vez que seja necessário avaliar o segundo argumento, o primeiro argumento seja avaliado antes (embora, na prática, isso costume acontecer).
Vale ressaltar que \texttt{seq} não pode ser definida em Haskell, já que é implementada a baixo nívvel pelo compilador.

Utilizando \texttt{seq}, podemos criar um operador que representa a avaliação estrita em Haskell.
A definição que segue deve ser escrita em \texttt{Functions.hs}.

\begin{lstlisting}[language=haskell, frame=single]
($!) :: (a -> b) -> a -> b
f $! x = seq x (f x)

infixl 0 $!
\end{lstlisting}

Vamos testar o nosso novo operador.

\begin{lstlisting}[language=haskell, frame=single]
*Functions Prelude> import Prelude (Int, (+))
*Functions Prelude> f _ = 0
*Functions Prelude> x = 1 + 1 :: Int
*Functions Prelude> :sprint x
x = _
*Functions Prelude> f x
0
*Functions Prelude> :sprint x
x = _
*Functions Prelude> f $ x
0
*Functions Prelude> :sprint x
x = _
*Functions Prelude> f $! x
0
*Functions Prelude> :sprint x
x = 2
\end{lstlisting}

Vemos que \texttt{f} recebe um argumento, mas o ignora e apenas retorna \texttt{0}.
Assim, \texttt{f x} é avaliada sem que \texttt{x} deixe de estar suspenso.
O mesmo pode ser dito de \texttt{f \$ x}.
Já \texttt{f \$! x} usa \texttt{seq} para garantir que o argumento passado para \texttt{f} tem sua avaliação forçada assim que \texttt{f x} é requerido.

É necessário justificar a existência de um aplicador de função que representa avaliação estrita, ou seja, um operador que faz a avaliação do argumento ser forçada, tão logo seja forçada a chamada da função.
Em resumo, a preguiça de Haskell tem um custo de espaço.
De forma mais elaborada, isso quer dizer que representar um valor suspenso demanda mais memória que avaliá-lo imediatamente.
É fácil entender o porquê: enquanto suspenso, o valor é representado por um \emph{thunk}, uma estrutura de dados que guarda a referência da função que o define, assim como referências para os argumentos que devem ser passados para essa função.
Essas referências podem também estar apontando para valores suspensos (lembre-se que funções, inclusive, são valores como quaisquer outros), representados por outros \emph{thunks}.
No fim das contas, um valor suspenso pode acabar sendo representado por uma estrutura arbórea, construída a partir de \emph{thunks} que apontam para novos \emph{thunks}.

Um bom estudo de caso é \texttt{foldl}, que como bem sabemos é recursiva por cauda.
Isso quer dizer que \texttt{foldl} executa em espaço constante, certo?
Na pilha, sim, mas não na \emph{heap}.
Como é recursiva por cauda, \texttt{foldl} tem sua chamada corrente substituida por sua chamada recursiva, nunca ocupando mais que um \emph{frame} na pilha.
No entanto, a atualização do acumulador de \texttt{foldl} fica suspensa, afinal ele só poderia ser utilizado após \texttt{foldl} atingir seu caso base.
Como os \emph{thunks} são armazenados na \emph{heap}, o acumulador final acaba sendo representado por uma cadeia de \emph{thunks}, localizada na \emph{heap}.
Há uma surpresa desagradável, no entanto: quando o acumulador final precisa ser avaliado, a função registrada em seu \emph{thunk} volta para a pilha, para ser avaliada com os devidos argumentos, e ao menos um desses (o valor anterior do acumulador) está suspenso e agora precisa ser avaliado.
Isso implica que a cadeia de \emph{thunks} que \texttt{foldl} produziu na \emph{heap} volta para a pilha, convertida agora em uma pilha de chamadas de função.
Precisamos consertar \texttt{foldl}.
Escrevemos a seguinte definição em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' _ acc [] = acc
foldl' f acc (x:xs) = foldl' f $! (f acc x) $ xs
\end{lstlisting}

Temos o uso de \texttt{(\$!)} para forçar a avaliação de \texttt{f acc x} junto com a chamada de \texttt{foldl'}.
Isso faz com que \texttt{foldl'} não construa uma cadeia de \emph{thunks}, uma vez que as atualizações do acumulador são avaliadas imediatamente, já que \texttt{foldl'} é recursiva por cauda.
Preferimos sempre o uso de \texttt{foldl'} a \texttt{foldl}.

Vamos lidar agora com tipos parametrizados.
Tome o seguinte exemplo.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> x = 1 + 1 :: Int
Prelude> y = 2 + 2 :: Int
Prelude> p = (x, y)
Prelude> :sprint p
p = _
Prelude> :t fst
fst :: (a, b) -> a
Prelude> fst p
2
Prelude> :sprint p
p = (2,_)
\end{lstlisting}

Assim que definido, o par \texttt{p} fica suspenso.
Ao utilizarmos \texttt{fst} (a assinatura deixa claro o que ela faz), a primeira componente de \texttt{p} é avaliada.
Como não foi necessário avaliar a segunda componente, \texttt{p} é avaliado parcialmente.
Tome este outro exemplo.

\begin{lstlisting}[language=haskell, frame=single]
Prelude> x = 1 + 1 :: Int
Prelude> p = (x, x)
Prelude> :sprint p
p = _
Prelude> fst p
2
Prelude> :sprint p
p = (2,2)
\end{lstlisting}

Observa-se que, para avaliar a primeira componente de \texttt{p}, é necessário avaliar \texttt{x}.
No entanto, como as componentes de \texttt{p} são ambas referências para o \emph{thunk} de \texttt{x}, \texttt{p} acaba sendo avaliado por completo.
Vamos brincar um pouco com listas.

\begin{lstlisting}[language=haskell, frame=single]
*List> xs = map (+1) [1..10] :: [Int]
*List> :sprint xs
xs = _
*List> f _ = 0
*List> f xs
0
*List> :sprint xs
xs = _
*List> f $! xs
0
*List> :sprint xs
xs = _ : _
*List> length xs
10
*List> :sprint xs
xs = [_,_,_,_,_,_,_,_,_,_]
*List> sum xs
65
*List> :sprint xs
xs = [2,3,4,5,6,7,8,9,10,11]
\end{lstlisting}

Nota-se que \texttt{xs}, como esperado, não é avaliada assim que definida.
Logo após \texttt{f \$! xs}, \texttt{xs} é parcialmente avaliada.
Como \texttt{f} ignora \texttt{xs}, sabemos que a forma como \texttt{xs} foi avaliada em \texttt{f \$! xs} é fruto apenas de \texttt{seq}.
Isso indica que, se o primeiro argumento de \texttt{seq} é um tipo parametrizado, ela não o avalia completamente, mas apenas evidencia sua estrutura.

Após \texttt{length xs}, percebemos que a estrutura de \texttt{xs} é avaliada por completo, uma vez que \texttt{length} precisa decompor seu argumento e, recursivamente, sua cauda.
O conteúdo de \texttt{xs}, no entanto, é avaliado apenas depois de \texttt{sum xs}.

Agora, vamos tratar de \texttt{par :: a -> b -> b}, definida em \texttt{Control.Parallel}.
Assim como \texttt{seq}, \texttt{par} é definida a baixo nível.
A função \texttt{par} põe a avaliação de seu primeiro argumento para ocorrer paralelamente à avaliação de seu segundo, quando essa ocorrer.
Vamos ilustrar seu uso.

\begin{lstlisting}[language=haskell, frame=single]
*List> import Control.Parallel
*List Control.Parallel> import Prelude (seq)
*List Control.Parallel Prelude> sum' = foldl' (+) 0
*List Control.Parallel Prelude> x = sum' [1..10000000] :: Int
*List Control.Parallel Prelude> y = sum' [1..10000000] :: Int
*List Control.Parallel Prelude> :set +s
*List Control.Parallel Prelude> seq x y
50000005000000
(9.68 secs, 8,640,075,072 bytes)
*List Control.Parallel Prelude> x = sum' [1..10000000] :: Int
(0.00 secs, 0 bytes)
*List Control.Parallel Prelude> y = sum' [1..10000000] :: Int
(0.00 secs, 0 bytes)
*List Control.Parallel Prelude> par x y
50000005000000
(4.28 secs, 4,320,073,040 bytes)
\end{lstlisting}

No exemplo acima, \texttt{seq x y} força a avaliação de \texttt{x} assim que a de \texttt{y} é forçada.
Como \texttt{y} é o retorno de \mbox{\texttt{seq x y}}, e esse é exibido no terminal, a avaliação de \texttt{x} precisa também ser feita, já que a de \texttt{y} é forçada.
No caso de \texttt{par x y}, a avaliação de \texttt{x} ocorre simultaneamente a de \texttt{y}.
Isso não é toda a explicação da redução de tempo apresentada.

É preciso esclarecer algo: se o processador que rodou o exemplo acima tivesse apenas um \emph{core}, as avaliações de \texttt{x} e \texttt{y} seriam feitas em simultâneo, mas iriam concorrer pelo uso do único \emph{core}, e daí não haveria redução de tempo.
No entanto, o \texttt{ghc} é esperto o bastante para distribuir o trabalho em paralelo de forma equilibrada entre os \emph{cores}.
Usamos o comando \texttt{lscpu} para saber as características de nosso processador.

\begin{lstlisting}[language=haskell, frame=single]
$ lscpu
Arquitetura:                x86_64
Modo(s) operacional da CPU: 32-bit, 64-bit
Ordem dos bytes:            Little Endian
Tamanhos de endereco:       39 bits physical, 48 bits virtual
CPU(s):                     4
Lista de CPU(s) on-line:    0-3
Thread(s) per nucleo:       2
Nucleo(s) por soquete:      2
Soquete(s):                 1
...
\end{lstlisting}

Vamos entender a parte que nos importa da saída de \texttt{lscpu}:
o sistema operacional ``enxerga'' quatro CPU's;
um pouco abaixo, vemos que há dois \emph{cores} no processador, cada um com duas \emph{threads}.
O sistema operacional nos diz que as quatro \emph{threads} do processador são CPU's.
No entanto, cada par de \emph{threads} disputa os recursos de um mesmo \emph{core}.
Daí, o número de trabalhos que esse processador consegue executar verdadeiramente em paralelo não é o número de CPU's, mas o número de \emph{cores}.
Isso significa que, nesse processador, fazer uso de paralelismo nos traria um fator de redução de tempo limitado por $2$.
Chamamos esse fator de \emph{speedup}.

No entanto, há tecnologias de certos processadores que podem distorcer a noção básica de \emph{speedup}.
Por exemplo, é possível estruturar um \emph{core} de tal forma que as \emph{threads} que o dividem, quando executando certos tipos de operação, concorram minimamente pelos recursos do \emph{core}.
Assim, o \emph{speedup} poderia, na prática, ter um limite um pouco menor que o número de \emph{threads}.

Junto de \texttt{par}, \texttt{Control.Parallel} também define \texttt{pseq :: a -> b -> b}.
Além do comportamento herdado de \texttt{seq}, \texttt{pseq} assegura que a avaliação de seu primeiro argumento vai ocorrer necessariamente antes da avaliação de seu segundo.
Essa diferença sutil entre \texttt{seq} e \texttt{pseq} permite um maior controle quando paralelizamos nosso código.

Para entender a necessidade de \texttt{pseq}, devemos estar cientes de que Haskell deixa em aberto a ordem de avaliação das partes de uma expressão.
Isso é sensato, inclusive, já que uma expressão simples (sem a semântica de impureza) deve ter o mesmo valor, independente da ordem em que suas partes são avaliadas.
Postergar a escolha de uma ordem pode abrir algumas oportunidades de otimizar o código.
Uma preocupação a menos para o programador, certo? Em aplicações de execução serial, sim.

Tomemos um exemplo bem simples: \texttt{x + y}.
Quando da avaliação de \texttt{x + y}, o compilador não nos dá garantias de quem será avaliado primeiro: \texttt{x} ou \texttt{y}.
Para o resultado dessa soma, a ordem de avaliação de fato não importa.
Mas e quanto a \texttt{par x (x + y)}?

Quando escreve-se \texttt{par x (x + y)}, a intenção é que \texttt{x} seja avaliado paralelamente a \mbox{\texttt{x + y}}, e assim poderia haver ganho de desempenho:
caso a avaliação de \texttt{x + y} comece por \texttt{y}, temos ganho;
caso comece por \texttt{x}, temos feito em vão a avaliação de \texttt{x} em paralelo, já que essa acaba sendo feita duas vezes.
Assim, apenas o uso de \texttt{par} nos entrega o risco de gastar o tempo de um \emph{core} com trabalho redundante.

Vamos analisar \texttt{par x (pseq y (x + y))}.
Aqui, a avaliação de \texttt{x} é feita em paralelo com a avaliação de \texttt{pseq y (x + y)}, e essa força a avaliação de \texttt{y} a ocorrer antes da avaliação de \mbox{\texttt{x + y}}.
Assim, temos que, quando \texttt{x + y} for avaliado, \texttt{y} já deve ter sido avaliada, assim como \texttt{x}, que deve ter sido avaliado em paralelo.
Vemos, pois, que o uso de \texttt{pseq} para controlar a ordem de avaliação de expressões nos permite fazer avaliações em paralelo que não serão redundantes.

No caso de \texttt{x + y}, sabemos que \texttt{x} e \texttt{y} são tipos numéricos, o que indica que eles devem ser avaliados por completo.
Mas quando se toma algo como \texttt{xs ++ ys}, em que \texttt{xs} e \texttt{ys} são duas listas, o uso de \texttt{seq} e \texttt{pseq} poderia forçar apenas uma avaliação superficial desses valores.
Assim, uma simples combinação de \texttt{par} e \texttt{pseq} poderia apenas determinar, em paralelo, se \texttt{xs} é vazia ou tem cabeça e cauda.
Isso faria quase nenhum trabalho ser feito em paralelo.
Para remediar essa situação, vamos criar uma função que força a avaliação completa de uma lista.
A definição a seguir deve ficar em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
force :: [a] -> [a]
force [] = []
force l@(x:xs) = seq x (seq (force xs) l)
\end{lstlisting}

Vamos entender o que \texttt{force} está fazendo.
A chamada mais externa de \texttt{seq} garante que seu primeiro argumento (a cabeça de \texttt{l}) vai ser avaliada quando seu segundo argumento for avaliado.
Esse segundo argumento é outra chamada de \texttt{seq}, e essa garante que \texttt{force xs} vai ser avaliada quando \texttt{l} for avaliada.
Isso quer dizer que, quando \texttt{l} for avaliada, serão avaliadas tanto sua cabeça como sua cauda, e essa última de forma recursiva.
Vale ressaltar que \texttt{force} não cria novas listas, uma vez que sempre retorna a mesma referência que recebe.
Testamos o comportamento de \texttt{force}.

\begin{lstlisting}[language=haskell, frame=single]
*List> xs = map (+1) [1..10] :: [Int]
*List> head xs
2
*List> :sprint xs
xs = 2 : _
*List> xs = map (+1) [1..10] :: [Int]
*List> ys = force xs
*List> head ys
2
*List> :sprint ys
ys = [2,3,4,5,6,7,8,9,10,11]
*List> :sprint xs
xs = [2,3,4,5,6,7,8,9,10,11]
\end{lstlisting}

Com \texttt{force} em mãos, estamos aptos a processar listas em paralelo, com a certeza de que essas serão avaliadas por completo.
Com a próxima ferramenta, poderemos ``quebrar'' uma lista em ``pedaços'' iguais.
Essa definição deve ficar em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
chunks :: Int -> [a] -> [[a]]
chunks _ [] = []
chunks k xs = ps : chunks k qs where
    (ps, qs) = splitAt k xs
\end{lstlisting}

A essa altura, a definição de \texttt{chunks} não deve ser difícil de entender.
Está claro que \mbox{\texttt{chunks k xs}} retorna \texttt{xs} dividida em partes, todas (talvez não a última) com \texttt{k} elementos.

Usando \texttt{chunks} e \texttt{force}, podemos criar uma estratégia para paralelizar a avaliação de uma lista.
Vamos supor que a lista \texttt{xs} tem muitos elementos, e todos eles são caros de avaliar.
Definimos, inicialmente, \texttt{ys = concat \$ chunks 10 xs}, supondo que avaliar um grupo de \texttt{10} elementos de \texttt{xs} é custoso o bastante.
Claramente, \texttt{xs == ys}, mas \texttt{ys} oferece uma oportunidade evidente de paralelismo.
Poderíamos fazer com que a avaliação de cada um dos ``pedaços'' de \texttt{xs} ocorresse em paralelo.
A definição que segue deve ser escrita em \texttt{List.hs}.

\begin{lstlisting}[language=haskell, frame=single]
parChunks :: Int -> [a] -> [[a]]
parChunks k = parallel . chunks k where
    parallel [] = []
    parallel l@(xs:xss) = par (force xs) (pseq (parallel xss) l)
\end{lstlisting}

Vamos explicar o que \texttt{parChunks} está fazendo.
Primeiro, \texttt{chunks} ``quebra'' a lista em diversas partes, e em seguida \texttt{parallel} força a avaliação de cada uma delas em paralelo: a chamada de \texttt{par} faz com que a avaliação de \mbox{\texttt{force xs}} ocorra paralelamente à avaliação de \texttt{pseq (parallel xss) l}, e essa garante que a avaliação de \texttt{parallel xss} (que vai forçar os demais ``pedaços'' em paralelo) vai ser feita antes da avaliação de \texttt{l}.

Em vez de \texttt{ys = concat \$ chunks 10 xs}, usamos \mbox{\texttt{ys = concat \$ parChunks 10 xs}}, que força a avaliação de cada ``pedaço'' de \texttt{xs} em paralelo, antes de concatená-los.
Esse \texttt{10} que utilizamos é apenas ilustrativo.
É preciso fazer testes com diversos valores para esse parâmetro, e assim descobrir qual valor traz o maior ganho de tempo.
Vamos aplicar essa ideia em um exemplo bem artificial.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Int, (+), (^), IO, print)

import List

sum' :: [Int] -> Int
sum' = foldl' (+) 0

xs :: [Int]
xs = [sum' [1..10^9], sum' [2..10^9], sum' [3..10^9], sum' [4..10^9]]

ys :: [Int]
ys = concat (parChunks 1 xs)

main :: IO ()
main = print ys
\end{lstlisting}

Como \texttt{xs} tem quatro elementos, \texttt{parChunks 1 xs} cria quatro trabalhos paralelos para avaliar \texttt{xs}.
Criamos um arquivo \texttt{Test.hs} com essas definições.
Vamos compilar esse arquivo com o seguinte comando.

\begin{lstlisting}[language=haskell, frame=single]
$ ghc -O2 -threaded Test -W
\end{lstlisting}

Esse comando faz o compilador gerar código muito otimizado (\texttt{-O2}), e acoplar um \emph{runtime system} (\texttt{-threaded}), que gerencia os trabalhos feitos em paralelo.
Agora, realizamos alguns testes com o executável criado.

\begin{lstlisting}[language=haskell, frame=single]
$ time ./Test +RTS -N1
[500000000500000000,500000000499999999,500000000499999997,500000000499999994]

real	0m39,523s
user	0m38,978s
sys	0m0,530s
\end{lstlisting}

Primeiro, \texttt{time} mede o tempo de execução do comando que vem em seguida.
O tempo \texttt{real} é o tempo real de execução do programa, enquanto \texttt{user} e \texttt{sys} indicam, respectivamente, quanto tempo o processo gastou rodando código de usuário e código do \emph{kernel}.

A chamada do executável \texttt{Test} apresenta o parâmetro \texttt{+RTS}, que indica que os parâmetros seguintes dizem respeito ao \emph{runtime system}.
O único parâmetro que vem depois de \texttt{+RTS} é \texttt{-N1}, que instrui o \emph{runtime system} a distribuir todos os trabalhos em uma \emph{thread}.
Assim, mesmo fazendo uso de paralelismo, \texttt{-N1} não nos permite ter ganhos, pois mesmo as avaliações paralelizadas são realizadas todas pela mesma \emph{thread}, e portanto não ocorrem de forma simultânea.
Vamos tentar \texttt{-N2}.

\begin{lstlisting}[language=haskell, frame=single]
$ time ./Teste +RTS -N2
[500000000500000000,500000000499999999,500000000499999997,500000000499999994]

real	0m33,065s
user	0m44,820s
sys	0m1,494s
\end{lstlisting}

A primeira coisa que notamos é uma redução de tempo bem pequena, de $39,523$ para $33,065$ segundos, resultando em um \emph{speedup} de quase $1,2$.
O \emph{speedup} aqui obtido passou longe de $2$, e para o nosso processador, esse deve ser o limite teórico de \emph{speedup}.
Não adianta testar os parâmetros de \texttt{-N3} em diante, pois pelo menos duas \emph{threads} concorreriam pelos recursos de um mesmo \emph{core}.

Há uma observação interessante a ser feita sobre os tempos \texttt{user} e \texttt{sys}.
No primeiro teste, a soma de \texttt{user} e \texttt{sys} é bastante próxima de \texttt{real}.
No segundo teste, porém, essa soma ultrapassa \texttt{real}.
Isso ocorre porque \texttt{user} e \texttt{sys} acumulam os devidos tempos de cada uma das \emph{threads}.

Vamos fazer uma modificação em \texttt{Test.hs}.
Substituimos a expressão \texttt{parChunks 1 xs} por \texttt{parChunks 2 xs}, fazendo \texttt{xs} ser avaliada, dessa vez, por dois trabalhos paralelos.
Recompilamos \texttt{Test.hs} e voltamos aos testes.

\begin{lstlisting}[language=haskell, frame=single]
$ time ./Teste +RTS -N1
[500000000500000000,500000000499999999,500000000499999997,500000000499999994]

real	0m39,544s
user	0m39,056s
sys	0m0,470s
\end{lstlisting}

Esse novo teste nos tomou quase o mesmo tempo de execução que o primeiro teste.
Vamos testar com \texttt{-N2}.

\begin{lstlisting}[language=haskell, frame=single]
 time ./Teste +RTS -N2
[500000000500000000,500000000499999999,500000000499999997,500000000499999994]

real	0m21,273s
user	0m41,760s
sys	0m0,646s
\end{lstlisting}

Agora sim!
A redução de tempo foi de 39,544 para 21,273 segundos, o que nos dá um \emph{speedup} um pouco maior que $1,85$.
Esse \emph{speedup} está bem mais próximo do limite teórico de $2$.
Novamente, não faz sentido usar mais \emph{threads} do que o número de \emph{cores}.
Com esses dois grupos de experimentos, observamos o impacto que o parâmetro de \texttt{parChunks} tem sobre o \emph{speedup} que podemos atingir.

Nosso pequeno exemplo artificial pode deixar a impressão de que a escolha do parâmetro de \texttt{parChunks} deve ser tal que haja exatamente um ``pedaço'' da lista para cada \emph{core} avaliar.
Embora plausível, essa escolha não nos dá escalabilidade.
Isso quer dizer que, se prepararmos um programa para tirar proveito de um certo número de \emph{cores}, ele precisará ser modificado para executar eficientemente em outro número de \emph{cores}.

Quanto maiores os ``pedaços'' em que partimos a lista, maiores serão os trabalhos a serem realizados em paralelo.
Para haver um bom ganho de tempo com paralelismo, é necessário que os trabalhos paralelizados sejam custosos a ponto de compensar o \emph{overhead} introduzido pelo \emph{runtime system}.
O parâmetro ideal de \texttt{parChunks} varia conforme a natureza das tarefas que se está paralelizando.
Geralmente, descobrir esse valor ideal requer alguma experimentação.

\pagebreak

\section{Laboratórios}

Aqui se encontram as atividades a serem desenvolvidas durante as aulas práticas.
Cada subseção corresponde a uma aula em laboratório.

\subsection{Laboratório 1}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab1.hs}.
Seu conteúdo inicial deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Lab1 where

import Prelude (Eq, (+), (*), Int)
import List(foldl, foldr)
\end{lstlisting}

\begin{enumerate}
	\item
		Reescreva as funções \texttt{length}, \texttt{(++)}, \texttt{concat} e \texttt{reverse} como chamadas de \texttt{foldl} ou \texttt{foldr} (a que parecer mais adequada).
		Transcreva essas novas definições para \texttt{List.hs}.
	\item
		Escreva a função \texttt{squares} que, dada uma lista de inteiros, retorna uma lista contendo o quadrado desses inteiros.
	\item
		Escreva a função \texttt{count :: Eq a => a -> [a] -> Int}, que retorna o número de ocorrências de um elemento em uma lista.
		Além de deixá-la em \texttt{Lab1.hs}, copie essa função para \texttt{List.hs}.
\end{enumerate}

\subsection{Laboratório 2} \label{lab2}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab2.hs}.
Seu conteúdo inicial deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Lab2 where

import Prelude(Eq, Fractional, (/))

import Bool
import Functions
import List
import Maybe
\end{lstlisting}

\begin{enumerate}
	\item
		Escreva a função \texttt{repeat :: a -> [a]} que, dado um elemento \texttt{x} de tipo \texttt{a}, retorna uma lista infinita cujos elementos são todos iguais a \texttt{x}.
	\item
		Escreva a função \texttt{cycle :: [a] -> [a]} que, dada uma lista \texttt{xs} como entrada, retorna uma lista infinita formada por repetir continuamente os elementos de \texttt{xs}, em ordem.
		Desejamos que \texttt{cycle [] == []}.
	\item
		Escreva a função \texttt{intercalate :: a -> [a] -> [a]} que, dado um elemento \texttt{x} e uma lista \texttt{ys}, retorna uma lista que consiste dos elementos de \texttt{ys} intercalados por \texttt{x}.
		Desejamos que \texttt{intercalate \_ [] == []} e \texttt{intercalate \_ [y] == [y]}, pois nesses casos \texttt{ys} não tem elementos a serem intercalados por \texttt{x}.
	\item
		Escreva a função \texttt{safeDiv :: (Eq a, Fractional a) => a -> a -> Maybe a} que faz divisões de forma segura, isto é, representa a divisão por zero como uma falha.
	\item
		Escreva uma implementação para \texttt{find :: (a -> Bool) -> [a] -> Maybe a}.
		Perceba que é possível implementar \texttt{find} utilizando composições de \texttt{dropWhile}, \texttt{safeHead} e \texttt{not}.
		Essa é apenas uma sugestão. Implemente como achar mais adequado.
\end{enumerate}

\subsection{Laboratório 3}	\label{lab3}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab3.hs}.
Seu conteúdo inicial deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Lab3 where

import Prelude (Ord, (<=), Eq, (==), Bool(True, False))

import Bool
import Functions
import List
\end{lstlisting}

\begin{enumerate}
	\item
		Implemente a função \texttt{group :: Eq a => [a] -> [[a]]}, que recebe uma lista \texttt{xs} e retorna uma lista de listas, onde cada sublista é uma subsequência contínua maximal de elementos iguais de \texttt{xs}.
		Por exemplo, \texttt{group [1, 1, 2, 2, 2, 3, 3, 1, 1, 1] == [[1, 1], [2, 2, 2], [3, 3], [1, 1, 1]]}.
		A função \texttt{span} pode ser de grande ajuda aqui.
	\item 
		Agora, generalizamos a função \texttt{group} como \texttt{groupBy}, fazendo com que \texttt{group} seja equivalente a \texttt{groupBy (==)}.
		Implemente \texttt{groupBy :: (a -> a -> Bool) -> [a] -> [[a]]}.
	\item
		Implemente as funções \texttt{all} e \texttt{any}, ambas com assinatura \texttt{(a -> Bool) -> [a] -> Bool}, que decidem, respectivamente, se todos ou algum elemento de uma lista satisfazem o predicado dado como entrada.
		Perceba que elas podem ser dadas como composições de \texttt{and}, \texttt{or} e \texttt{map}.
	\item
		Escreva a função \texttt{merge :: Ord a => [a] -> [a] -> [a]} que, dadas duas listas ordenadas como entrada, retorna uma lista ordenada com todos os elementos das listas recebidas.
	\item
		Escreva a função \texttt{split :: [a] -> ([a], [a])} que, dada uma lista \texttt{xs} como entrada, retorna duas listas: a primeira contém os elementos das posições ímpares de \texttt{xs}, e a segunda os elementos das posições pares de \texttt{xs}.
		Aqui, estamos admitindo que a cabeça de uma lista está na posição 1.
	\item
		Agora, utilizando \texttt{merge} e \texttt{split}, implementadas anteriormente, desenvolva a função \texttt{mergesort :: Ord a => [a] -> [a]}.
\end{enumerate}

\subsection{Laboratório 4}	\label{lab4}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab4.hs}.
Seu conteúdo inicial deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Eq, (==), (/=),
                Int, (+), Char,
                IO, readFile, putStrLn, show,
                (>>=), pure)

import Bool
import Functions
import List

import qualified BSTree as BST
\end{lstlisting}

Para esse laboratório, vamos utilizar o arquivo auxiliar \texttt{heyjude.txt}, que contém a letra da referida música.
Como você deve ter notado, o arquivo \texttt{Lab4.hs} contém um módulo chamado \texttt{Main}.
Isso indica que vamos criar um executável \texttt{Lab4}.
Para informações sobre como compilar um programa em Haskell, veja a Subseção \ref{subsec:compiling}.

As atividades a seguir devem ser um guia para o desenvolvimento de um programa que imprime a contagem da ocorrência de palavras no arquivo \texttt{heyjude.txt}.

\begin{enumerate}
	\item
		Escreva a função \texttt{remove :: Eq a => a -> [a] -> [a]}, que remove todas as ocorrências de um certo elemento em uma lista.
		Perceba que \texttt{remove} pode ser implementada como uma chamada de \texttt{filter}.
	\item
		Escreva a função \texttt{split :: Eq a => a -> [a] -> [[a]]} que, dados um elemento \texttt{x} e uma lista \texttt{ys}, retorna as sublistas de \texttt{ys} entre as ocorrências de \texttt{x}. Por exemplo, \texttt{split 0 [0, 1, 2, 0, 2, 5, 7, 0, 0, 0, 3, 0] == [[1, 2], [2, 5, 7], [3]]}.
		As funções \texttt{span} e \texttt{dropWhile} são bastante úteis aqui.
	\item
		Utilize a função \texttt{split} para escrever as funções \texttt{lines} e \texttt{words}, ambas com assinatura \texttt{[Char] -> [[Char]]}.
		A função \texttt{lines} (\texttt{words}) deve particionar uma string em substrings que representem suas linhas (palavras).
		Lembre-se que linhas são separadas por \texttt{'\char`\\n'} e palavras por \texttt{' '}.
	\item
		Escreva a função \texttt{count :: [[Char]] -> BST.BSTree [Char] Int} que, dada uma lista de strings, retorna uma árvore binária de busca onde as chaves são essas strings e cada uma é valorada pelo número de vezes que ocorre na lista.
		As funções \texttt{foldr}, \texttt{BST.empty}, \texttt{BST.contains}, \texttt{BST.insert} e \texttt{BST.update} são muito úteis para isso.
	\item
		Vamos desenvolver a função \texttt{process :: [Char] -> [Char]}, que junta todas as partes do nosso programa.
		Essencialmente, \texttt{process} vai limpar a string de entrada, removendo caracteres indesejáveis, contar a ocorrência das palavras e em seguida preparar a saída do programa, que é seu retorno.
		Podemos decompor \texttt{process} nessas três partes.
		\begin{lstlisting}[language=haskell, frame=single]
process :: [Char] -> [Char]
process = makeOutput . countWords . clean where
	clean = undefined
	countWords = undefined
	makeOutput = concat . intercalate "\n" . map f . BST.inOrder
	f (str, c) = str ++ ": " ++ show c
		\end{lstlisting}
		Escreva implementações para \texttt{clean} e \texttt{countWords}.
		A função \texttt{clean} deve remover os caracteres \texttt{','}, \texttt{'('}, \texttt{')'}, \texttt{'?'} e \texttt{'!'}, e isso pode ser feito com uma composição de \texttt{remove}s.
		A função \texttt{countWords} deve construir a árvore com a contagem de ocorrência das palavras, e isso pode ser expresso como uma composição das funções \texttt{lines}, \texttt{words}, \texttt{map}, \texttt{concat} e \texttt{count}.
	\item
		Com todas as funções desenvolvidas, estamos aptos a finalizar nosso programa.
		Nossa \texttt{main} (que não pode ser totalmente explicada agora) é apresentada a seguir.
		\begin{lstlisting}[language=haskell, frame=single]
main :: IO ()
main = readFile "heyjude.txt" >>= pure . process >>= putStrLn
		\end{lstlisting}
		Agora, basta compilar \texttt{Lab4.hs} e conferir a saída do executável.
\end{enumerate}

\subsection{Laboratório 5}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab5.hs}.
Seu conteúdo inicial deve ser o seguinte.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Eq, (==), (/=),
                Int, (+), Char,
                IO, readFile, putStrLn, show,
                (>>=), pure)

import Bool
import Functions
import List

import qualified BSTree as BST
\end{lstlisting}

Vamos criar um programa ligeiramente diferente do criado na Subseção \ref{lab4}.
Em vez de imprimir as palavras em ordem alfabética, vamos imprimí-las em ordem decrescente de frequência, isto é, as palavras com maior número de ocorrências serão impressas primeiro.

Para tanto, é preciso criar uma função auxiliar \texttt{sortBy}, que ordena uma lista de acordo com um comparador, também dado como entrada.
Basta generalizar \texttt{mergesort}, proposta na Subseção \ref{lab3}.

Descobrindo-se o comparador adequado para produzir a ordenação desejada, uma simples alteração no programa da Subseção \ref{lab4} é suficiente para concluir esse laboratório.
Com isso, esperamos evidenciar o reuso obtido quando expressamos programas funcionais por meio de composições.

Esta subseção se encontra escrita em um estilo distinto das anteriores por uma razão.
Aqui, queremos também avaliar a capacidade de conceber assinaturas e tipos para as funções, em vez de apenas criá-las a partir de assinaturas pré-determinadas.

\subsection{Laboratório 6}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab6.hs}.
Seu conteúdo inicial deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Char, Bool(False), pure, (>>=),
                IO, readFile, putStrLn, read, show)

import Bool
import Functions
import List
import Maybe

import qualified Graph as G
\end{lstlisting}

Vamos trabalhar com grafos.
Em particular, vamos desenvolver um programa que resolve o Problema da Celebridade, um clássico das maratonas de programação.

Dado um grafo $G = (V, E)$, dizemos que um vértice $v \in V$ é uma celebridade se todo outro vértice ``conhece'' $v$ e $v$ ``conhece'' ninguém.
Perceba que um grafo tem no máximo uma celebridade.
Aqui, estamos usando ``$u$ conhece $v$'' para indicar a existência da aresta $(u, v) \in E$.

Para começar, nossa \texttt{main} será como nos outros laboratórios.

\begin{lstlisting}[language=haskell, frame=single]
main :: IO ()
main = readFile "g1.txt" >>= pure . process >>= putStrLn
\end{lstlisting}

No entanto, o arquivo \texttt{g1.txt} contém a codificação de um grafo, em vez de um conteúdo arbitrário.
Sua primeira linha contém um inteiro, indicando o número de vértices.
As demais linhas contêm exatamente dois inteiros, indicando as extremidades das arestas.

Nossa função \texttt{process} tem quatro etapas: dividir o conteúdo do arquivo por linhas, construir o grafo correspondente, resolver o Problema da Celebridade e produzir a saída.

\begin{lstlisting}[language=haskell, frame=single]
process :: [Char] -> [Char]
process = makeOutput . hasCelebrity . buildGraph . lines
\end{lstlisting}

Para que possamos nos concentrar no problema em si, eis a definição de \texttt{buildGraph}.

\begin{lstlisting}[language=haskell, frame=single]
buildGraph :: [[Char]] -> G.Graph
buildGraph [] = G.empty
buildGraph (n:es) = foldr f gn es' where
	es' = map words es
	gn = G.edgeless (read n)
	f e g = G.addEdge g u v where
		(u:v:_) = map read e
\end{lstlisting}

Note que, nesse contexto, \texttt{read} consegue inferir o tipo de seu retorno.
Isso é possível por conta das assinaturas das funções que estão em \texttt{Graph.hs}.

Em um primeiro momento, podemos supor que \texttt{makeOutput = show}. Assim, o retorno booleano de \texttt{hasCelebrity} é impresso na tela, indicando se o grafo tem uma celebridade.
Obviamente, é mais útil dizer qual é a celebridade, caso haja alguma.
No entanto, esse improviso nos deixa apenas com \texttt{hasCelebrity} indefinida.

\begin{lstlisting}[language=haskell, frame=single]
hasCelebrity :: G.Graph -> Bool
hasCelebrity g = verify candidate where
	verify = undefined
	candidate = undefined
\end{lstlisting}

Vamos utilizar uma solução bem simples para o problema.
Como um grafo tem no máximo uma celebridade, em um primeiro momento queremos encontrar um vértice candidato a celebridade.
Isso pode ser feito com uma pilha, e as listas cumprem esse papel.
Colocamos todos os vértices em uma pilha.
Se há pelo menos dois vértices na pilha, digamos $u$ e $v$, verificamos se a aresta $(u, v)$ existe:
caso exista, $u$ ``conhece'' alguém e não pode ser uma celebridade;
caso contrário, $v$ não é ``conhecido'' por um outro vértice e não pode ser celebridade.
Em ambos os casos, eliminamos um vértice e o outro volta para a pilha.
Quando tivermos um único vértice na pilha, esse será nosso candidato.
Precisamos retornar o candidato dentro de um \texttt{Maybe}, para podermos tratar o caso da pilha (lista) vazia.

Uma vez determinado o candidato, caso haja algum, a função \texttt{verify} testa as condições de celebridade para ele.

\begin{lstlisting}[language=haskell, frame=single]
verify = maybe False f where
	f c = and [cond1, not cond2] where
	cond1 = undefined
	cond2 = undefined
\end{lstlisting}

Nessa definição, \texttt{maybe} nos poupa de tratar explicitamente os casos de \texttt{Maybe}.
O valor \texttt{cond1} indica se todos os outros vértices ``conhecem'' o candidato, enquanto \texttt{cond2} indica se o candidato ``conhece'' algum outro vértice.
As funções \texttt{and}, \texttt{or}, \texttt{zipWith}, \texttt{G.hasEdge}, \texttt{repeat} e \texttt{remove} são úteis para definí-los.

Aqui, o executável já deve estar pronto.
Teste-o, modificando o conteúdo de \texttt{g1.txt} para isso.
Uma vez seguro do comportamento do programa, altere-o para que a celebridade (caso haja uma) seja exibida como saída.

\subsection{Laboratório 7}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab7.hs}.
Antes de abordar nosso objetivo primário, vamos criar uma variante de \texttt{Heap.hs}.

Baseado na estrutura definida em \texttt{Heap.hs}, crie uma estrutura para representar uma fila de prioridade máxima.
Copie o conteúdo de \texttt{Heap.hs} para \texttt{MaxHeap.hs}.
Além de renomear o módulo do arquivo adequadamente, note que apenas uma função de \texttt{MaxHeap.hs} precisa sofrer alterações.

Agora que temos implementações para filas de prioridade mínima e máxima, vamos aprovietá-las e criar uma fila de prioridade mediana.
A finalidade de tal estrutura de dados é permitir acesso em tempo constante à mediana de um conjunto de elementos, mesmo que esse conjunto sofra alterações.
Por simplicidade, consideramos que, dada uma lista \texttt{xs} de $n$ elementos, sua mediana é o $\lceil\frac{n}{2}\rceil$-ésimo elemento de uma versão ordenada de \texttt{xs}.

Dada uma lista inicial \texttt{xs} de $n$ elementos do tipo \texttt{(k, v)}, com \texttt{k} ordenável, vamos criar um algoritmo \mbox{\texttt{median :: Ord k => [(k, v)] -> Maybe (k, v)}}, que encontra a mediana de \texttt{xs} (de acordo com \texttt{k}) em tempo linear, no caso médio.
O algoritmo que \texttt{median} implementa é o \emph{quickselect}, inspirado nas mesmas ideias do \emph{quicksort}.
Para implementá-lo, \texttt{filter} é bastante útil.

Uma vez determinada a mediana de \texttt{xs}, digamos \texttt{m}, dividimos \texttt{xs} em duas listas: a dos elementos menores ou iguais a \texttt{m} (\texttt{ps}) e a dos elementos maiores que \texttt{m} (\texttt{qs}).
Por fim, criamos uma fila de prioridade máxima (mínima) com os elementos de \texttt{ps} (\texttt{qs}).

Após isso tudo, obtemos duas filas de prioridade:
a máxima agrupa os elementos com prioridade menor ou igual a da mediana;
a mínima agrupa os elementos com prioridade superior a da mediana.
Perceba que a diferença entre as quantidades de elementos em cada fila de prioridade é no máximo um:
se $n$ é par, as duas \emph{heaps} têm o mesmo número de elementos;
se $n$ é ímpar, a \emph{heap} máxima tem exatamente um elemento a mais que a \emph{heap} mínima.

A ideia principal dessa estrutura de dados está no fato de que, ao inserir ou remover exatamente um elemento do conjunto representado, ou o ``sucessor'' ou o ``antecessor'' da mediana torna-se a nova mediana.
O ``antecessor'' (``sucessor'') é indicado como o elemento mais prioritário da \emph{heap} máxima (mínima).

Quando queremos tomar a mediana, escolhemos sempre o elemento mais prioritário da \emph{heap} com mais elementos.
Em caso de empate, preferimos o elemento mais prioritário da \emph{heap} máxima.
Aqui, fica claro que é preciso armazenar, além das \emph{heaps}, a quantidade de elementos de cada uma.

Ao inserirmos um elemento \texttt{x}, fazemos a inserção de acordo com a relação entre \texttt{x} e a mediana atual \texttt{m}:
se \texttt{x} tem mais prioridade que \texttt{m}, inserimos \texttt{x} na \emph{heap} mínima;
do contrário, inserimos \texttt{x} na \emph{heap} máxima.

Sempre que é feita uma alteração na estrutura de dados, é preciso rebalancear as \emph{heaps} caso uma tenha pelo menos dois elementos a mais que a outra.
Isso é feito removendo o elemento mais prioritário da \emph{heap} com mais elementos, e inserindo-o na outra \emph{heap}.
A quantidade de vezes que essa operação deve ser feita pode ser controlada com o uso de recursão.

É esperado que sejam implementadas as operações \texttt{fromList}, \texttt{lookup}, \texttt{insert} e \texttt{pop} para essa estrutura de dados.
Observe que \texttt{fromList} falha caso receba uma lista vazia.
Além dessas, a função auxiliar \texttt{rebalance} deve ser chamada sempre que uma alteração for feita.

Com a estrutura implementada, escreva um programa para testá-la.
Podemos trabalhar com elementos de tipo \texttt{(Int, ())}.

Uma ideia seria receber um arquivo com duas linhas, cada uma contendo inteiros separados por um espaço.
A estrutura inicial é construída a partir das chaves na primeira linha.
Após isso, os elementos da segunda linha são inseridos um por vez.
A cada modificação da estrutura, a mediana atual deve ser impressa na tela.

\subsection{Laboratório 8}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab8.hs}.
Por razões que ficarão claras no decorrer desse texto, esperamos receber, como resultado desse laboratório, os arquivos \texttt{Lab4.hs} e \texttt{Lab8.hs}.
O conteúdo inicial de \texttt{Lab8.hs} deve ser o seguinte.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (IO, print, putStrLn,
                readFile, writeFile,
                getContents,
                (>>=))

import System.Environment (getArgs)

import Functions
import List
\end{lstlisting}

Nesse laboratório, vamos exercitar uma interação básica com o sistema operacional, que consiste em tratar argumentos da linha de comando.
Vamos desenvolver uma série de programas elementares, começando com \texttt{program1}.

\begin{lstlisting}[language=haskell, frame=single]
program1 :: IO ()
program1 = getArgs >>= print
\end{lstlisting}

Basicamente, \texttt{program1} toma a lista de argumentos e a imprime no terminal.
Para compilar, acrescentamos.

\begin{lstlisting}[language=haskell, frame=single]
main = program1
\end{lstlisting}

Não escrevemos a assinatura explícita de \texttt{main}, pois ela tem claramente a mesma assinatura de \texttt{program1}.
Tente passar argumentos para o executável \texttt{Lab8}.
Agora, vamos desenvolver um análogo do comando \texttt{cat}, que imprime o conteúdo de um arquivo de texto no terminal.

\begin{lstlisting}[language=haskell, frame=single]
program2 :: IO ()
program2 = getArgs >>= readFile . head >>= putStrLn
\end{lstlisting}

Com o uso de \texttt{head}, é bem simples tratar um único argumento passado pela linha de comando.
Faça a alteração devida em \texttt{main} e teste o novo programa.
Observe que ele ignora todos, menos o primeiro argumento para ele passado.
Note também que ele lança exceções caso não receba argumentos (por conta de \texttt{head}), ou caso seu primeiro argumento não seja um arquivo válido (por conta de \texttt{readFile}).
Isso indica que deve haver um jeito melhor de lidar com argumentos.

Como sua primeira tarefa, escreva \texttt{program3}, que imprime o conteúdo de um arquivo de texto passado como argumento, mas antes ordena suas linhas.
As funções \texttt{lines}, \texttt{sortBy}, \texttt{intercalate} e \texttt{concat} são úteis para isso.
Organizá-las por composição pode ser uma boa ideia.

Agora, vamos criar um programa que copia o conteúdo de um arquivo de texto.

\begin{lstlisting}[language=haskell, frame=single]
program4 :: IO ()
program4 = getArgs >>= treatArgs where
	treatArgs [from, to] = readFile from >>= writeFile to
	treatArgs _ = putStrLn "You must pass exactly two arguments."
\end{lstlisting}

Verifique a assinatura de \texttt{writeFile} no \texttt{ghci}, afinal é a primeira vez que a vemos.
A função \texttt{treatArgs} trata os argumentos usando dois casos:
no primeiro, fica claro que esperamos dois argumentos, para ler o conteúdo do arquivo \texttt{from} e escrevê-lo no arquivo \texttt{to};
o segundo caso lida com qualquer outro número de argumentos, informando o usuário sobre o uso correto do programa.
Tente copiar o conteúdo de \texttt{heyjude.txt} para \texttt{teste.txt}.
Após isso, tente passar diversos números de argumentos.
Como \texttt{writeFile} apaga o conteúdo do arquivo antes de escrever seu segundo argumento, não é interessante que \texttt{to} seja o nome de um arquivo existente.

Vamos voltar ao \texttt{program2}.
Dissemos que \texttt{program2} é análogo ao comando \texttt{cat}.
No entanto, \texttt{cat} e \texttt{program2} se comportam de formas distintas quando não recebem argumentos.

Após verificar isso, sua segunda tarefa é escrever \texttt{program5}, que deve se comportar exatamente igual a \texttt{cat}, seja com zero ou um argumentos.
Já devemos ter notado que \texttt{cat} lê sua entrada do teclado quando não tem argumentos.
Em Haskell, \texttt{getContents} faz exatamente isso, isto é, retorna uma string ``infinita'' de coisas que são digitadas no teclado.
Para esse programa, \texttt{treatArgs} deve tratar os casos de zero e um argumentos, e invalidar todos os demais casos.

Na nossa terceira tarefa, vamos modificar o conteúdo de \texttt{Lab4.hs}, que foi desenvolvido na Subseção \ref{lab4}.
Em vez de tratar apenas o conteúdo do arquivo \texttt{heyjude.txt}, nosso programa modificado deve receber exatamente um argumento, que é o nome do arquivo que deve ser tratado.

Por fim, a quarta tarefa consiste em desenvolver \texttt{program6}, que recebe exatamente dois argumentos: uma string \texttt{str} e o nome de um arquivo \texttt{file}.
Esse programa deve imprimir apenas as linhas de \texttt{file} que contém \texttt{str} como substring.
A função \texttt{isInfixOf}, proposta no Exercício \ref{exercicioIsInfixOf}, pode ser utilizada para essa filtragem.
Feito isso, acrescente um caso em que \texttt{program6} recebe exatamente um argumento, e imprime apenas as linhas digitadas no teclado que tenham \texttt{str} como substring.
Temos implementado uma versão (muito) simplificada do comando \texttt{grep}.
Inclusive, podemos usar \texttt{program6} em combinação com o \emph{pipe} do sistema operacional.

\subsection{Laboratório 9}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab9.hs}.
O conteúdo inicial de \texttt{Lab9.hs} deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (IO, putStrLn, getLine,
                (<$>), (<*>), pure,
                (*>), (>>=),
                Char, (==))

import Bool
import Functions
import List
\end{lstlisting}

Vamos desenvolver um programa que ``cadastra'' uma senha.
Por motivos de verificação, o programa pede que ela seja digitada duas vezes e, enquanto houver divergência, pede novamente.

A primeira coisa de que precisamos é uma função \texttt{ask :: [Char] -> IO [Char]}, que imprime seu argumento na tela e retorna uma linha lida a partir do teclado, dentro de \texttt{IO}.
Para construir \texttt{ask}, as funções \texttt{putStrLn}, \texttt{getLine} e \texttt{(*>)} são úteis.

Com \texttt{ask} em mãos, vamos construir \texttt{getPasswd :: IO ([Char], [Char])}, uma ação que retorna um par de strings em \texttt{IO}.
A ideia aqui não é tão complicada: precisamos construir um par, mas dentro de \texttt{IO}.
O operador \texttt{(,)} constrói pares simples, e podemos aproveitá-lo para construir um par em \texttt{IO}, já que \texttt{IO} é instância de \texttt{Functor} e \texttt{Applicative}.
Sabemos que \mbox{\texttt{(,) x y}} constrói um par de tipo \texttt{(a, b)}, desde que \texttt{x :: a} e \texttt{y :: b}.
Caso \mbox{\texttt{x :: IO a}} e \mbox{\texttt{y :: IO b}}, como poderíamos usar \texttt{(,)}, \texttt{(<\$>)} e \texttt{(<*>)} para construir \texttt{IO (a, b)}?
Respondida a pergunta, basta fazer com que \texttt{x} e \texttt{y} sejam duas chamadas de \texttt{ask}, com strings que avisem o usuário se é a primeira (\texttt{x}) ou segunda (\texttt{y}) vez que estão digitando a senha.

Temos implementado \texttt{getPasswd}, mas ainda precisamos validar se as duas strings digitadas são iguais.
Fazemos isso em \texttt{validPasswd}, uma ação recursiva que termina apenas ao receber duas strings idênticas.
Sua implementação é dada a seguir.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
validPasswd :: IO [Char]
validPasswd = getPasswd >>= f where
    f (p1, p2) = cond (p1 == p2)
                      (pure p1)
                      (incorrect *> validPasswd)
    incorrect = putStrLn "They don't match! Try again."
\end{lstlisting}

Agora que sabemos como obter uma senha válida, implemente \texttt{main :: IO ()} e teste seu programa.
Mas o laboratório ainda não acabou.

Em \texttt{Data.Char}, existem alguns predicados muito úteis, que testam se um \texttt{Char} é um certo tipo de caractere, como letra minúscula, maiúscula ou dígito.
Dizemos que uma senha é forte se ela tem pelo menos oito caracteres e há, dentre eles, uma letra minúscula, uma maiúscula e um dígito.
Escreva uma função \texttt{isStrong :: [Char] -> Bool}, que determina se uma senha é forte.

Uma vez implementada \texttt{isStrong}, escreva a ação \texttt{strongPasswd :: IO [Char]}, que utiliza \texttt{validPasswd} para obter senhas válidas e retorna, dentro de \texttt{IO}, a primeira que seja forte.
A definição de \texttt{validPasswd} é um bom modelo para \texttt{strongPasswd}.

Adapte sua \texttt{main} e teste seu programa.
Agora sim o laboratório acabou.

\subsection{Laboratório 10}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab10.hs}.
O conteúdo inicial de \texttt{Lab10.hs} deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Ord, (<=), (>=), (-), Bool,
                IO, putStrLn, (<$>), pure, (<*>))

import Bool
import Functions
import List
import Maybe
\end{lstlisting}

Neste laboratório, vamos resolver o problema da maior subsequência crescente, ou \emph{longest increasing subsequence}.
Dada uma sequência de naturais, gostaríamos de encontrar a maior subsequência crescente dessa sequência.
Por exemplo, dada a sequência $10, 22, 9, 33, 21, 50, 41, 60, 80$, sua maior subsequência crescente é $10, 22, 33, 41, 60, 80$.

Primeiro, desenvolva \texttt{maximum :: Ord a => [a] -> Maybe a}, que retorna o maior elemento de uma lista, caso ela não seja vazia.
Basta usar \texttt{foldl} e \texttt{(<=)}.
No entanto, precisaremos fazer uso de uma versão genérica de \texttt{maximum}.
Para tanto, implemente a função \mbox{\texttt{maximalBy :: (a -> a -> Bool) -> [a] -> Maybe a}}, de tal forma que \texttt{maximalBy (>=)} seja equivalente a \texttt{maximum}.

Agora, vamos criar uma solução ingênua para o problema em vista.
Dada uma sequência de $n$ naturais $x_0, x_1, \dots, x_{n - 1}$, criamos a seguinte notação:
$s_i$ representa a maior subsequência crescente começando com $x_i$, para $0 \leq i \leq n - 1$.

Podemos definir $s$ em termos de si mesma:
claramente, $s_{n - 1}$ é uma sequência unitária contendo $x_{n - 1}$;
para $0 \leq i \leq n - 2$, $s_i$ começa com $x_i$, e pode seguir com os elementos de $s_j, i < j \leq n - 1$, desde que $x_i \leq x_j$.
Certamente, definimos $s_i$ utilizando, dentre todos os $s_j$ possíveis, aquele que represente a maior subsequência.
Por fim, é fácil escolher a maior subsequência crescente dentre os $s_i, 0 \leq i \leq k - 1$.
Essa solução pode ser implementada da seguinte forma.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
lis :: Ord a => [a] -> [a]
lis [] = []
lis [x] = [x]
lis xs = fromMaybe [] (maximalBy cmp (s <$> [0..n - 1] <*> pure xs)) where
	n = length xs
	cmp ps qs = length ps >= length qs
	s 0 [] = []
	s 0 [y] = [y]
	s 0 (y:ys) = y : ms where
		candidates = filter ((y<=) . head) $ s <$> [0..k - 1] <*> pure ys
		k = length ys
		ms = fromMaybe [] $ maximalBy cmp candidates
	s i ys = s 0 $ drop i ys
\end{lstlisting}

Em um primeiro momento, a função \texttt{s} parece receber mais argumentos que o necessário, afinal $s$ é indexada apenas por $0 \leq i \leq n - 1$.
No entanto, receber a lista como segundo argumento nos permite tratar o caso referente a $s_i$, para algum $0 < i \leq n - 1$, com \texttt{drop}.

Uma outra coisa interessante de se notar é \texttt{candidates}.
Note que \texttt{candidates} parece estar fazendo \texttt{s} tratar sobre subsequências de outras listas além de \texttt{xs}.
Na verdade não está, mas da forma como \texttt{candidates} se comporta, os índices passados para \texttt{s} podem referir-se a posições em sufixos de \texttt{xs}, e assim não podem ser interpretados de maneira absoluta, como os índices de $s$.

Bem, a implementação de \texttt{lis} apresentada está correta, mas é extremamente ineficiente.
É preciso utilizar \texttt{memo} e \texttt{fix} para criar uma \emph{cache} para \texttt{s}.
No entanto, há um obstáculo: \texttt{memo} espera receber uma função \texttt{Int -> b}, e essa não é a assinatura de \texttt{s}.

O objetivo final desse laboratório é reescrever \texttt{lis} de forma que \texttt{s} tenha assinatura \mbox{\texttt{Int -> [a]}}, para em seguida criar uma \emph{cache} para \texttt{s}.

\subsection{Laboratório 11}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab11.hs}.
O conteúdo inicial de \texttt{Lab11.hs} deve ser o seguinte.

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Char, Int, (==),
                IO, putStrLn, (<$>))

import Bool
import Functions
import List
\end{lstlisting}

Neste laboratório, vamos construir definições para trabalhar com autômatos finitos
não-determinísticos.
Para isso, vamos usar o seguinte tipo.

\begin{lstlisting}[language=haskell, frame=single]
type State = Int
type Transition = (State, Char, State)

data NFA = NFA [State] State [Transition] [State]
\end{lstlisting}

Em \texttt{NFA}, o primeiro campo representa o conjunto de estados do autômato,
enquanto o segundo representa seu estado corrente.
Isso difere um pouco da definição usual de autômato, mas facilita a
implementação.
Já o terceiro campo é a lista de transições do autômato, enquanto o quarto
representa seu conjunto de estados finais.
Além disso, definimos uma série de funções auxiliares para esse tipo.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
nfa :: [State] -> State -> [Transition] -> [State] -> NFA
nfa states s trs finals = NFA states s trs finals

states :: NFA -> [State]
states (NFA states _ _ _) = states

currentState :: NFA -> State
currentState (NFA _ s _ _) = s

transitions :: NFA -> [Transition]
transitions (NFA _ _ trs _) = trs

finalStates :: NFA -> [State]
finalStates (NFA _ _ _ finals) = finals
\end{lstlisting}

Com elas, podemos definir uma função que faz o autômato ``consumir'' um
caractere.
Em nossa representação desse conceito, o autômato não vai mudar de estado, e sim
produzir novos autômatos, cada um deles representando o resultado de uma
possível transição.

\begin{lstlisting}[language=haskell, frame=single]
transition :: NFA -> Char -> [NFA]
transition aut c = f <$> nextStates where
  validTransitions = filter valid (transitions aut)
  valid (st, c', _) = and [st == (currentState aut), c' == c]
  nextStates = thd <$> validTransitions
  thd (_, _, z) = z
  f st = nfa (states aut) st (transitions aut) (finalStates aut)
\end{lstlisting}

Para prosseguir com as atividades do laboratório, faça a implementação de duas
funções: \mbox{\texttt{isAccepting :: NFA -> Bool}} e \texttt{run :: NFA -> [Char] -> Bool}.
Enquanto a primeira função deixa claro o seu propósito, a segunda deve fazer um
autômato consumir uma lista de caracteres, e no fim determinar se essa foi
aceita pelo autômato.
Para facilitar a escrita, recomendamos a implementação de \texttt{foldM},
proposta no Exercício \ref{exercicio:foldM}.
Como a lista representa não-determinismo enquanto mônada, \texttt{run} pode ser
escrita em termos de \texttt{foldM}.
Observe bem a assinatura de \texttt{transition}.

Por fim, crie dois autômatos, utilizando o arcabouço aqui desenvolvido.
O primeiro autômato deve aceitar representações binárias de números pares,
enquanto o segundo aceita strings binárias que tenham $010$ como substring.
Perceba que, em ambos os casos, quaisquer outros valores de \texttt{Char} devem implicar na rejeição
da string.

\subsection{Laboratório 12}

Desenvolva as atividades a seguir.
Salve suas funções em um arquivo \texttt{Lab12.hs}.
O conteúdo inicial de \texttt{Lab12.hs} deve ser o seguinte.

\pagebreak

\begin{lstlisting}[language=haskell, frame=single]
module Main where

import Prelude (Int, (+), (^),
                IO, (>>=),
                print, read)

import System.Environment (getArgs)

import Functions
import List

sum' :: [Int] -> Int
sum' = foldl' (+) 0

main :: IO ()
main = getArgs >>= \[kstr] ->
       print $ sum' (xs $ read kstr)

xs :: Int -> [Int]
xs k = zipWith (+) [1..10^k] [1..10^k]
\end{lstlisting}

Além do código que deve ser desenvolvido, é esperada a entrega de uma planilha
contendo os tempos de execução do programa, de acordo com dois parâmetros:
o tamanho da entrada, dado por \texttt{k};
o argumento passado para \texttt{parChunks} (o tamanho dos ``pedaços'' em que se
divide a lista).

Compile esse programa com \texttt{ghc -O2 -threaded Lab12 -W}.
Estabeleça alguns valores de \texttt{k} com os quais serão realizados testes.
Inicialmente, use o comando \mbox{\texttt{time ./Lab12 k +RTS -N1}} para verificar o tempo (\texttt{real}) de execução serial para
esses valores de \texttt{k}.

Observamos que há duas oportunidades de paralelização nesse programa.
A primeira consiste em avaliar os ``pedaços'' de \texttt{xs} em paralelo.
A segunda consiste em aplicar \texttt{sum'} a cada ``pedaço'', e em seguida
somar os resultados parciais.
Estabeleça alguns valores para o argumento de \texttt{parChunks}, com os quais
serão realizados testes.

A partir de agora, utilize o comando \texttt{time ./Lab12 k +RTS -Nc} para realizar os testes.
Nesse comando, \texttt{k} controla o tamanho da entrada, enquanto \texttt{c} é o
número de \emph{cores} do seu computador.

Implemente a primeira abordagem.
Realize testes para as combinações de valores estabelecidos.
Faça o mesmo para a segunda abordagem.
Em seguida, utilize as duas abordagens simultaneamente.

Monte uma planilha com os tempos de execução \texttt{real} coletados, e calcule
os \emph{speedups} obtidos (que também devem constar na planilha).
Lembre-se que o \emph{speedup} é dado pelo tempo de execução serial sobre o
tempo de execução paralelo.
Não esqueça de fechar a maior parte dos programas durante os testes.

\pagebreak

\section{Trabalhos práticos}

Nesta seção, descrevemos os trabalhos práticos de cada Avaliação Parcial.
É esperado que haja uma subseção para cada Avaliação Parcial.
Na presente versão da disciplina, deve haver três subseções.

\subsection{Trabalho 1}

Descrevemos alguns problemas que devem ser resolvidos e implementados.

\subsubsection{Problema 1}

Uma agência de crédito emite cartões de crédito, cada um identificado por uma sequência de dez dígitos: os oito primeiros são significativos e os dois últimos são verificadores.
Os dois dígitos verificadores representam a soma dos oito primeiros dígitos.

Escreva uma função \texttt{addSum} que, dada uma string de oito dígitos, adiciona ao seu final os dois dígitos verificadores.
Você vai precisar transformar cada dígito da string de entrada em um inteiro (pode ser interessante definir \texttt{getDigit :: Char -> Int}, com o auxílio de \texttt{read}), e em seguida somá-los e transformar o resultado em uma string (usar \texttt{show} é muito útil).

Escreva uma função \texttt{valid} que, dada uma string de dez dígitos, verifica se ela é um identificador válido de um cartão.
Isso é bem simples quando se usa a função \texttt{take}.

\subsubsection{Problema 2}

A primeira parte desse problema, que será útil para a segunda, consiste em implementar a função \texttt{until :: (a -> Bool) -> (a -> a) -> a -> a}.
A função \texttt{until} recebe duas funções: a primeira é um predicado \texttt{p}, e a segunda é uma função \texttt{f} que transforma elementos do tipo \texttt{a}.
Além disso, ela recebe um elemento \texttt{x} do tipo \texttt{a}.
Se \texttt{x} satisfaz o predicado \texttt{p}, então \texttt{until} retorna \texttt{x}.
Caso contrário, \texttt{until} testa, recursivamente, o predicado \texttt{p} para \texttt{f x}.
É bastante simples implementar \texttt{until} com o auxílio de \texttt{iterate}, proposta no Exercício \ref{exercicio:iterate}.

Agora, vamos implementar a raiz quadrada.
Você pode usar o seguinte template.

\begin{lstlisting}[language=haskell, frame=single]
sqrt :: Floating a => a -> a
sqrt x = until goodEnough improve x where
	goodEnough y = undefined
	improve y = undefined
\end{lstlisting}

Para implementar \texttt{goodEnough}, determine se o valor absoluto de \texttt{y*y} está suficientemente próximo de \texttt{x}.
Sugerimos uma precisão de seis casas decimais.

Para implementar \texttt{improve}, pode ser útil pesquisar por alguma fórmula baseada no método de Newton (ou no método da secante).

\subsubsection{Problema 3}

A definição indutiva dos números naturais diz que há um primeiro número natural, digamos zero, e que cada um dos outros é obtido aplicando-se uma certa função injetora a algum natural.
Essa função é chamada de \emph{sucessora}, e zero é sucessor de nenhum natural.
Isso é suficiente para determinar que os números naturais formam um conjunto infinito.

Com base nessa definição, podemos implementar os naturais da seguinte forma.

\begin{lstlisting}[language=haskell, frame=single]
data Nat = Zero | Suc Nat
\end{lstlisting}

Faça de \texttt{Nat} uma instância da classe \texttt{Eq} (basta implementar \texttt{(==)}).
Faça de \texttt{Nat} uma instância da classe \texttt{Ord} (basta implementar \texttt{(<=)}).
Escreva as funções \texttt{natToInt :: Nat -> Int} e \texttt{intToNat :: Int -> Nat} e verifique se os comparadores estão funcionando corretamente.

\subsection{Trabalho 2}

Dado um conjunto de símbolos $S$, uma codificação $c : S \to \{0, 1\}^*$ é uma função bijetora que atribui a cada símbolo uma sequência de valores binários.
Uma codificação livre de prefixos tem a seguinte propriedade: $c(s_1)$ não é prefixo de $c(s_2)$, para quaisquer $s_1, s_2 \in S$.

Vamos admitir que cada símbolo de $S$ é formado por uma sequência de valores binários.
Dado $s \in S$, $|s|$ representa o comprimento da sequência de \emph{bits} que forma $s$.

Se conhecemos $c : S \to \{0, 1\}^*$ tal que, para cada $s \in S$, $|c(s)| \leq |s|$, então uma sequência de símbolos $s_1s_2\dots s_k$ seria representada mais eficientemente como $c(s_1)c(s_2)\dots c(s_k)$.
No entanto, esperamos que os símbolos de $S$ não admitam tal codificação.
Uma vez que admitissem, passaríamos a representar $s$ por $c(s)$, para todo $s \in S$.
Com isso, estamos supondo que a representação dos símbolos em $S$ é a mais eficiente possível.
Via de regra, se $|S| \leq 2^l$, precisamos de no máximo $l$ \emph{bits} para a representação de cada símbolo de $S$.

Então, dada uma sequência de símbolos $s_1s_2 \dots s_k$ de $S$, concatenar as representações dos símbolos é a maneira mais eficiente de represnetar a sequência?
Não necessariamente.
Pode ser que, nessa sequência em particular, um símbolo $\overline{s}$ ocorra muito mais que outro $\tilde{s}$.
Nesse caso, seria interessante que $\overline{s}$ tivesse uma representação menor que $\tilde{s}$.

Vamos admitir que, dado o conteúdo de um arquivo de texto, queremos criar uma codificação para suas palavras, associando às palavras mais frequentes as menores sequências binárias possíveis.
Utilizando funções já escritas em laboratório, sabemos construir uma \texttt{BSTree} que associa a cada palavra sua quantidade de ocorrências.

Vamos criar o seguinte tipo, que representa uma \emph{codificação de Huffman}.

\begin{lstlisting}[language=haskell, frame=single]
data HuffmanTree a = Leaf a
                   | Branch (HuffmanTree a) (HuffmanTree a)
\end{lstlisting}

Vamos usar esse tipo para representar as palavras de um arquivo de texto como suas folhas.
Cada folha tem sua codificação representada pelo seu caminho a partir da raiz da árvore:
descer para a esquerda (direita) representa $0$ ($1$).

Para construir a \texttt{HuffmanTree}, criamos, para cada palavra \texttt{w}, um par \texttt{(nw, w)}, onde \texttt{nw} representa o número de ocorrências de \texttt{w}.
Isso pode ser feito com um passeio em uma \texttt{BSTree}.
Em seguida, criamos uma \texttt{Heap} (mínima) onde os elementos são, para cada palavra \texttt{w}, \texttt{Leaf w} com prioridade \texttt{nw}.

Agora, o algoritmo de Huffman é bem simples: enquanto for possível retirar dois elementos da \texttt{Heap}, digamos \texttt{(n1, t1)} e \texttt{(n2, t2)}, retire-os e insira \texttt{(n1 + n2, Branch t1 t2)}.
Quando houver exatamente um elemento na \texttt{Heap}, esse estará representando a codificação de Huffman das palavras de acordo com seu número de ocorrências.

Com isso, podemos substituir cada palavra do arquivo pela codificação dada pela \texttt{HuffmanTree}.
Para tanto, é interessante criar uma função \texttt{encoding} que, dada uma \texttt{HuffmanTree}, retorna a codificação associada a cada uma de suas folhas.
Poderíamos, por fim, usar \texttt{encoding} para criar uma \texttt{BSTree}, digamos \texttt{encodingTree}, que associa cada palavra à sua codificação, e usá-la para substituir cada palavra do arquivo pela codificação associada.
Lembre-se que, como uma codificação de Huffman é livre de prefixos, não precisamos separar as codificações com espaços, e assim economizamos um pouco mais de memória.

É esperado que, nesse momento, estejamos aptos a, dado um arquivo de texto como entrada, criar um arquivo de texto codificado como saída que também contém a codificação usada.
Podemos organizar o arquivo de saída da seguinte forma:
a primeira linha contém o conteúdo codificado do arquivo de entrada;
cada uma das linhas seguintes tem uma sequência binária e sua palavra correspondente.

Para facilitar a implementação, crie um executável capaz de codificar o conteúdo do arquivo \texttt{input.txt}, produzindo o arquivo \texttt{output.txt}.
Agora, vamos tratar de recuperar o conteúdo original do arquivo.

Além de criar \texttt{encodingTree}, é interessante criar \texttt{decodingTree}, uma \texttt{BSTree} chaveada pelas codificações e valorada pelas palavras.
Com ela, estamos aptos a criar \texttt{decode}, que recebe uma codificação e retorna a palavra associada.
Antes de poder usar \texttt{decode} em um conteúdo codificado (que seria uma sequência enorme de valores binários), precisamos saber separar seu conteúdo.

Vamos agora criar \texttt{isValid}, que determina se uma sequência binária é uma codificação válida, isto é, verifica se é uma chave de \texttt{decodingTree}.
Com ela e \texttt{inits}, vamos poder determinar o menor prefixo de uma sequência binária que é uma codificação válida, e usamos isso para criar \texttt{encodingSplit}, que dada uma sequência binária, retorna-a particionada em codificações válidas.
Por fim, temos apenas o trabalho de substituir cada codificação pela palavra correspondente, intercalar a lista resultante com espaços e concatenar as strings dessa lista.

Nesse momento, esperamos estar aptos a, dado um arquivo codificado (como o produzido acima) como entrada, decodificar o conteúdo de sua primeira linha a partir da codificação descrita pelas demais linhas, e imprimir o conteúdo decodificado no terminal.
Para simplificar a implementação, crie um executável capaz de decodificar \texttt{output.txt}.

\subsection{Trabalho 3}

Nos trabalhos práticos dessa Avaliação Parcial, cada grupo de alunos deve escolher um, e somente um, dos temas
listados abaixo, ou sugerir seu próprio tema.
Cada grupo de alunos deve desenvolver um programa com
características de paralelismo que atenda a proposta do seu tema.

Em cada um dos temas, é esperado que, além do desenvolvimento do programa, seja
também elaborada uma análise do tempo de execução e do \emph{speedup}, de acordo com os seguintes
parâmetros:
tamanho da entrada;
número de \emph{cores} utilizados (controlado com o parâmetro \texttt{-N});
primeiro argumento de \texttt{parChunks} (quando utilizada).
Fica a critério do grupo de alunos decidir se tal análise será apresentada em
forma de
gráficos ou tabelas.

Para fins de consistência, aconselhamos que todos os programas desenvolvidos
nesse contexto sejam compilados com o seguinte comando.
Nele, \texttt{Program.hs}
representa o nome do arquivo desenvolvido.

\begin{lstlisting}[language=haskell, frame=single]
ghc -O2 -threaded Program.hs
\end{lstlisting}

Esperamos também que os testes sejam feitos com o seguinte comando. Nele,
\texttt{k} representa o número de \emph{threads} a serem utilizadas pelo programa.
Lembramos que \texttt{real} é o tempo que deve ser considerado.

\begin{lstlisting}[language=haskell, frame=single]
time ./Program +RTS -Nk
\end{lstlisting}

Sugerimos que, para obtenção de bons resultados, os testes concorram com
o menor número possível de outros programas.
Assim, é bom fechar o navegador e o editor de texto antes de realizar um teste.

\subsubsection{Tema 1}

Nesse tema, devem ser desenvolvidas operações elementares de Álgebra Linear,
como soma, subtração e multiplicação de matrizes, assim como soma, subtração e
produto interno de vetores.
Tais operações oferecem muitas oportunidades de paralelismo.

Por exemplo, podemos imaginar a soma $A + B$ de duas matrizes $A, B \in \mathbb{R}^{m
  \times n}$ dividida em $m$ ($n$) tarefas, onde cada tarefa realiza a soma de duas
linhas (colunas) correspondentes de $A$ e $B$.
Com isso, podemos usar \texttt{parChunks} para realizar grupos dessas tarefas em paralelo.

Observamos que, para a multiplicação de matrizes, é interessante que uma das
matrizes esteja representada por suas linhas, enquanto a outra esteja
representada por suas colunas.
Assim, faz-se necessário desenvolver funções que convertam matrizes entre essas representações.

\subsubsection{Tema 2}

Aqui, deve ser desenvolvida uma função que, dada uma lista \texttt{x:xs} sem elementos
repetidos, retorna uma lista com todos os subconjuntos de \texttt{x:xs}.
Uma vez construídos os subconjuntos da cauda \texttt{xs}, é preciso realizar as
tarefas de duplicar cada
um deles, e acrescentar \texttt{x} em uma das cópias.
Note que essas são tarefas que podem ser paralelizadas, mas são muito baratas, e
assim não conseguem
justificar o custo do \emph{runtime system}.
Seria possível, mesmo assim, desenvolver uma forma de paralelizá-las que resulte
em ganhos no tempo de execução?

\subsubsection{Tema 3}

Podemos aproximar o cálculo de uma integral $\int_a^b f(x) dx$ através de uma
quadratura, como a regra do trapézio ou a regra de Simpson, cujas fórmulas são
fáceis de implementar.
No entanto, aplicar diretamente essas quadraturas pode resultar em uma
aproximação não muito boa, principalmente se $|b - a|$ for um valor muito alto.
Com a propriedade $\int_a^b f(x) dx = \int_a^c f(x) dx + \int_c^b f(x) dx$, para
algum $c \in [a, b]$, podemos ver a integral em um
certo intervalo $[a, b]$ como a soma das integrais em subintervalos que particionam $[a,
b]$, e essas podem ser aproximadas em paralelo.
Note que essas tarefas são muito baratas para, individualmente, compensar o \emph{overhead} do
\emph{runtime system}.

Assim, deve ser desenvolvida uma função que toma quatro argumentos:
um integrando \mbox{\texttt{Double -> Double}}, uma quadratura (que também é uma função),
um intervalo de integração \mbox{\texttt{(Double, Double)}} e um número \texttt{k} de subintervalos.
Essa função deve particionar o intervalo recebido em \texttt{k} subintervalos, e
aplicar a quadratura a cada um deles, de forma paralela.

\subsubsection{Tema 4}

Considere a função \texttt{mergesort}, proposta na Subseção \ref{lab3}.
Desenvolva duas versões paralelizadas de \texttt{mergesort}.

Na primeira versão, ``quebre'' a lista em sublistas, ordene-as em paralelo, e
faça as operações de \texttt{merge} também em paralelo.
Note que a eficiência dessa abordagem está relacionada com o tamanho das
sublistas que se toma.

Na segunda versão, crie uma função auxiliar \texttt{mergesort'}, que recebe,
além da lista, um segundo argumento que determina a ``profundidade'' da chamada recursiva.
Assim, \texttt{mergesort xs = mergesort' xs 0}, e \texttt{mergesort'} incrementa
seu segundo argumento para suas chamadas recursivas.
Com isso, pode-se determinar, de acordo com o segundo argumento, se as chamadas
recursivas serão realizadas em paralelo ou não.
O ideal é que apenas as chamadas recursivas mais ``rasas'' sejam realizadas em
paralelo.

\subsubsection{Tema 5}

Escolha um dos temas anteriores e o desenvolva na linguagem Scala.
O tema deve ser desenvolvido, preferencialmente, evidenciando as facilidades que
se obtém ao integrar programação OO com programação funcional.
Assim como os outros temas, esse também deve ser desenvolvido usado paralelismo.
Observamos também que algumas instruções dadas no começo dessa seção não se
aplicam a esse tema.

\end{document}
