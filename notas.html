<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Luiz Alberto do Carmo Viana" />
  <title>Programação Funcional</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Programação Funcional</h1>
<p class="author">Luiz Alberto do Carmo Viana</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introdução">Introdução</a></li>
<li><a href="#ferramentas">Ferramentas</a></li>
<li><a href="#programando-em-haskell">Programando em Haskell</a>
<ul>
<li><a href="#trabalhando-com-listas">Trabalhando com listas</a></li>
<li><a href="#abstraindo-o-conceito-de-loop">Abstraindo o conceito de <em>loop</em></a></li>
<li><a href="#usando-tipos-para-o-tratamento-de-erros">Usando tipos para o tratamento de erros</a></li>
<li><a href="#representando-valores-disjuntivos">Representando valores disjuntivos</a></li>
<li><a href="#árvores-binárias-de-busca">Árvores binárias de busca</a></li>
<li><a href="#representando-sequências-de-forma-eficiente">Representando sequências de forma eficiente</a></li>
<li><a href="#subsec:compiling">Compilando um programa</a></li>
<li><a href="#implementando-um-grafo">Implementando um grafo</a></li>
<li><a href="#filas-de-prioridade">Filas de prioridade</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#functor-applicative-e-alternative"><code>Functor</code>, <code>Applicative</code> e <code>Alternative</code></a></li>
<li><a href="#fix-e-programação-dinâmica"><code>fix</code> e Programação Dinâmica</a></li>
<li><a href="#mônadas">Mônadas</a></li>
<li><a href="#avaliação-estrita-e-paralelismo">Avaliação estrita e Paralelismo</a></li>
</ul></li>
<li><a href="#laboratórios">Laboratórios</a>
<ul>
<li><a href="#laboratório-1">Laboratório 1</a></li>
<li><a href="#lab2">Laboratório 2</a></li>
<li><a href="#lab3">Laboratório 3</a></li>
<li><a href="#lab4">Laboratório 4</a></li>
<li><a href="#laboratório-5">Laboratório 5</a></li>
<li><a href="#laboratório-6">Laboratório 6</a></li>
<li><a href="#laboratório-7">Laboratório 7</a></li>
<li><a href="#laboratório-8">Laboratório 8</a></li>
<li><a href="#laboratório-9">Laboratório 9</a></li>
<li><a href="#laboratório-10">Laboratório 10</a></li>
<li><a href="#laboratório-11">Laboratório 11</a></li>
<li><a href="#laboratório-12">Laboratório 12</a></li>
</ul></li>
<li><a href="#trabalhos-práticos">Trabalhos práticos</a>
<ul>
<li><a href="#trabalho-1">Trabalho 1</a>
<ul>
<li><a href="#problema-1">Problema 1</a></li>
<li><a href="#problema-2">Problema 2</a></li>
<li><a href="#problema-3">Problema 3</a></li>
</ul></li>
<li><a href="#trabalho-2">Trabalho 2</a></li>
<li><a href="#trabalho-3">Trabalho 3</a>
<ul>
<li><a href="#tema-1">Tema 1</a></li>
<li><a href="#tema-2">Tema 2</a></li>
<li><a href="#tema-3">Tema 3</a></li>
<li><a href="#tema-4">Tema 4</a></li>
<li><a href="#tema-5">Tema 5</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="introdução">Introdução</h1>
<p>Programar computadores é uma atividade que pode ser bastante prazeroza. Testar programas de computador, a fim de garantir que funcionem adequadamente, já não é tão agradável (ao menos para mim).</p>
<p>A crescente complexidade dos ambientes computacionais traz consigo linguagens de programação cada vez mais sofisticadas, dotadas de recursos necessários para lidar com os avanços técnicos dos computadores. Atualmente, por exemplo, é bastante comum nos depararmos com computadores dotados de múltiplos processadores ou <em>cores</em>. Para tirar proveito desse recurso, é preciso escrever programas que executem instruções em paralelo, com o auxílio de linguagens que forneçam os meios para lidar com os vários <em>cores</em> do processador.</p>
<p>Se considerarmos que <em>debugar</em> um programa simples já é desafiador, o que podemos dizer sobre corrigir um programa que executa, simultaneamente, diferentes instruções em alguns processadores? Uma vez que pudéssemos demonstrar a corretude do nosso programa, não haveria a preocupação de testá-lo, e assim esse problema desapareceria completamente.</p>
<p>O paradigma de Programação Funcional propõe o desenvolvimento de linguagens de programação que se aproximem o máximo possível da linguagem matemática. Essa escolha de <em>design</em> facilita a demonstração da corretude de um programa funcional, que não precisa ser testado. Dessa forma, o paradigma em estudo ganha bastante adequação para o desenvolvimento de programas que lidam com ambientes computacionais complexos.</p>
<h1 id="ferramentas">Ferramentas</h1>
<p>Nestas notas de aula, usaremos a linguagem de programação Haskell, na dsitribuição Linux de sua preferência. Admitimos, naturalmente, o uso do compilador GHC (Glasgow Haskell Compiler), e esperamos que sua versão seja a 8.4.4. Você pode conferir a versão instalada com o comando <code>ghci</code> (falaremos mais a respeito dele no futuro), que deve produzir uma saída como esta.</p>
<div class="sourceCode" id="cb1" data-bgcolor="bg"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">GHCi,</span> version 8.6.3: http://www.haskell.org/ghc/</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Prelude</span><span class="op">&gt;</span> </span></code></pre></div>
<p>Existem diversas formas de se obter o GHC. Você pode tentar instalá-lo pelo gerenciador de pacotes da sua distribuição, ou tentar baixá-lo pelo site oficial. Recomendamos o uso do ghcup, que costuma instalar a versão mais recente do compilador.</p>
<h1 id="programando-em-haskell">Programando em Haskell</h1>
<p>Aqui, reimplementamos as funções básicas de Haskell com o propósito de entender seu funcionamento. Isso também nos permite ganhar familiaridade com a linguagem e sua sintaxe, além de nos expor, aos poucos, às suas características.</p>
<p>Vamos desenvolver nossa reimplementação utilizando uma divisão em módulos mais simplificada que a estrutura modular oficial. Usaremos os seguintes arquivos:</p>
<ul>
<li><p><code>Bool.hs</code>: aqui se encontram as funções relacionadas a operações com valores booleanos;</p></li>
<li><p><code>BSTree.hs</code>: contém as definições da estrutura de árvore binária de busca;</p></li>
<li><p><code>Either.hs</code>: implementa valores disjuntivos e funções para seu manuseio;</p></li>
<li><p><code>Functions.hs</code>: apresenta as operações elementares para o reuso de funções;</p></li>
<li><p><code>Graph.hs</code>: define algumas funções para manipulação de grafos;</p></li>
<li><p><code>Heap.hs</code>: implementação de uma fila de prioridade mínima;</p></li>
<li><p><code>InfinityTree.hs</code>: árvore binária infinita, isto é, sem folhas;</p></li>
<li><p><code>List.hs</code>: elenca diversas funções para o tratamento de listas;</p></li>
<li><p><code>Maybe.hs</code>: define um tipo para representação de falha, assim como facilidades para o seu manuseio;</p></li>
<li><p><code>Memo.hs</code>: traz funções que implementam memoização;</p></li>
<li><p><code>SeqTree.hs</code>: contém as definições de uma estrutura arbórea simples para a representação de sequências.</p></li>
</ul>
<h2 id="trabalhando-com-listas">Trabalhando com listas</h2>
<p>Iniciamos nossos estudos da linguagem Haskell tratando de um tipo composto que é clássico para o paradigma funcional: a <em>lista</em>. A lista é caracterizada por ser uma estrutura linear que contém elementos de um único tipo. Uma lista é uma estrutura que pode ou ser <em>vazia</em> ou ter uma <em>cabeça</em> (composta de um único elemento) e uma <em>cauda</em> (uma outra lista, contendo o mesmo tipo de elemento).</p>
<p>Vamos criar um arquivo <code>List.hs</code> com o seguinte conteúdo inicial. Este indica que iremos trabalhar com algumas definições de Prelude, bem como iremos fazer uso de conceitos definidos em outros módulos.</p>
<div class="sourceCode" id="cb2" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">List</span> <span class="kw">where</span> tonton</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Eq</span>, <span class="dt">Num</span>, <span class="dt">Int</span>, <span class="dt">Char</span>, <span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>),</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">+</span>), (<span class="op">-</span>), (<span class="op">*</span>), (<span class="op">&lt;=</span>), (<span class="op">==</span>), (<span class="op">/=</span>), <span class="fu">error</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Functor</span>(<span class="fu">fmap</span>), (<span class="op">&lt;$&gt;</span>), <span class="dt">Applicative</span>(<span class="fu">pure</span>, (<span class="op">&lt;*&gt;</span>)),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">seq</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (<span class="dt">Alternative</span>(empty, (&lt;|&gt;)))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span> </span></code></pre></div>
<p>Iniciamos nossas implementações com uma operação muito básica: determinar o comprimento de uma lista. Dada sua natureza recursiva, podemos aproveitar a estrutura de uma lista para calcular recursivamente seu comprimento.</p>
<div class="sourceCode" id="cb3" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>Vamos entender o código acima por partes. A primeira linha determina a assinatura da função <code>length</code>, que recebe uma lista de elementos do tipo <code>a</code> (pode ser um tipo qualquer), e retorna um elemento do tipo <code>Int</code>, isto é, um inteiro. Em Haskell, uma lista vazia é representada por <code>[]</code>. Intuitivamente, sabemos que uma lista vazia tem 0 elementos, e dizemos isso na segunda linha. Esse é o nosso caso base. Quando tomamos uma lista não vazia, sabemos que ela tem cabeça e cauda. Em Haskell, representamos uma lista não vazia como <code>(x:xs)</code>, que tem cabeça <code>x</code> e cauda <code>xs</code>. Essa lista tem um elemento <code>x</code>, e esse “um" precisa ser somado à quantidade de elementos da cauda <code>xs</code> (computada recursivamente, já que <code>xs</code> é uma lista). Agora vamos testar nosso código.</p>
<p>Antes de aprendermos a utilizar o compilador (comando <code>ghc</code>), vamos nos habituar a testar nosso código no interpretador (comando <code>ghci</code>). Vamos para o diretório onde está <code>List.hs</code> e executamos o seguinte.</p>
<div class="sourceCode" id="cb4" data-bgcolor="bg"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci                                                                      </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">GHCi,</span> version 8.6.3: http://www.haskell.org/ghc/                                        </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Prelude</span><span class="op">&gt;</span> :l List                                                                                   </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ex">[1</span> of 1] Compiling List                                                    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ex">Ok,</span> one module loaded.                                                                             </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ex">*List</span><span class="op">&gt;</span> length [1,2,4]                                                                              </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ex">3</span>                                                                                                  </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ex">*List</span><span class="op">&gt;</span> :q                                                                                          </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ex">Leaving</span> GHCi.               </span></code></pre></div>
<p>Como podemos ver, carregamos o arquivo no interpretador utilizando <code>:l List</code> (note que não precisamos escrever a extensão do arquivo). Quando passamos uma lista com três elementos, <code>length</code> responde de acordo. Para sair do interpretador, utilizamos <code>:q</code>.</p>
<p>Agora que entendemos o básico de como utilizar o interpretador, vamos nos concentrar em desenvolver outras funções. A função <code>null</code>, por exemplo, determina se uma lista é vazia ou não.</p>
<div class="sourceCode" id="cb5" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">null</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">null</span> [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">null</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Recomendamos carregar <code>List.hs</code> no interpretador e fazer alguns testes. Não deve ser difícil entender que <code>null</code> recebe uma lista contendo elementos de um tipo qualquer e retorna um valor booleano (verdadeiro para listas vazias).</p>
<p>Vamos agora criar duas funções para acessar as componentes do tipo lista: cabeça e cauda.</p>
<div class="sourceCode" id="cb6" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;head: empty list&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (x<span class="op">:</span>_) <span class="ot">=</span> x</span></code></pre></div>
<p>Temos duas coisas novas no trecho de código acima. Primeiro, como não podemos retornar a cabeça de uma lista vazia, temos de lançar uma exceção. Isso é feito utilizando a função <code>error</code>, que recebe uma string e lança uma exceção (a assinatura de error é muito interessante). A segunda coisa ocorre na expressão <code>(x:_)</code>: o <em>underline</em> serve para ignorar o nome de um argumento de função (nesse caso, a cauda de uma lista decomposta). Como não precisamos mencionar a cauda da lista para retornar sua cabeça, consideramos boa prática não nomeá-la. Agora definimos a função <code>tail</code>, de forma análoga.</p>
<div class="sourceCode" id="cb7" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;tail: empty list&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (_<span class="op">:</span>xs) <span class="ot">=</span> xs</span></code></pre></div>
<p>Podemos entender o par de funções <code>head</code> e <code>tail</code> como duas funções que decompõem uma lista separando seu primeiro elemento. Intuitivamente, podemos conceber as funções <code>last</code> e <code>init</code>, que decompõem uma lista separando seu último elemento.</p>
<div class="sourceCode" id="cb8" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;last: empty list&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> (x<span class="op">:</span>[]) <span class="ot">=</span> x</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">last</span> xs</span></code></pre></div>
<p>Observe que a implementação de <code>last</code> tem três casos, apesar de uma lista ter apenas duas definições: vazia ou com cabeça e cauda. É preciso tratar o caso de uma lista ter cabeça e uma cauda vazia (uma lista com apenas um elemento) por conta da definição recursiva. Observe que, se não houvesse o referido caso, a definição recursiva sempre levaria ao lançamento de uma exceção. Definimos agora <code>init</code>.</p>
<div class="sourceCode" id="cb9" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">init</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">init</span> [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;init: empty list&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">init</span> (_<span class="op">:</span>[]) <span class="ot">=</span> []</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">init</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> <span class="fu">init</span> xs</span></code></pre></div>
<p>A ocorrência de três casos em <code>init</code> é justificada da mesma forma que em <code>last</code>. Temos algo novo no caso recursivo: além de <code>(:)</code> ser usado para decompor listas, também pode ser usado para a construção de listas. Em <code>init</code>, usamos <code>(:)</code> para construir uma lista, a ser retornada, cuja cabeça é <code>x</code> e cuja cauda é o resultado de <code>init xs</code>.</p>
<p>Uma operação usual em listas (e outros tipos compostos lineares) é a <em>concatenação</em>, que consiste em tomar duas listas e retornar uma lista maior, resultado de justapor a primeira seguida da segunda. Vamos implementar essa função como um operador infixo, isto é, como uma função “binária" (essas aspas serão explicadas posteriormente) que ocorre entre seus argumentos.</p>
<div class="sourceCode" id="cb10" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>xs) <span class="op">++</span> ys <span class="ot">=</span> x <span class="op">:</span> xs <span class="op">++</span> ys</span></code></pre></div>
<p>A primeira coisa que observamos é como o operador <code>(++)</code> é definido na assinatura. Quando definimos a assinatura de operadores, colocamos seu nome entre parênteses. Quando definimos os casos de um operador, escrevemos seu nome entre seus dois argumentos. Quanto à definição de <code>(++)</code>, seu primeiro caso é bem simples. No último caso, definimos que o primeiro elemento da concatenação de duas listas não vazias é justamente o primeiro elemento da primeira lista, e os demais elementos da concatenação são definidos recursivamente.</p>
<p>Para facilitar o uso de <code>(++)</code> em certos contextos, definimos também a função <code>concat</code>, que recebe uma lista de listas e retorna uma lista simples, resultado da sucessiva concatenação das sublistas recebidas.</p>
<div class="sourceCode" id="cb11" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span><span class="ot"> ::</span> [[a]] <span class="ot">-&gt;</span> [a]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> [] <span class="ot">=</span> []</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> (xs<span class="op">:</span>xss) <span class="ot">=</span> xs <span class="op">++</span> <span class="fu">concat</span> xss</span></code></pre></div>
<p>Chamamos a atenção para o estilo de nomenclatura utilizado. Listas simples costumam ter nomes com um único ‘s’ no final, enquanto listas de listas são nomeadas com “ss" ao final.</p>
<p>Agora definimos como computar o inverso de uma lista. Nossa primeira tentativa poderia ser algo como o seguinte.</p>
<div class="sourceCode" id="cb12" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> [] <span class="ot">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">reverse</span> xs <span class="op">++</span> [x]</span></code></pre></div>
<p>Essa definição, embora correta, não é a mais eficiente. Perceba que o operador <code>(++)</code> tem um custo linear em relação ao número de elementos de seu primeiro argumento. Se, para cada elemento de seu argumento, <code>reverse</code> usa <code>(++)</code>, usaríamos <code>(++)</code> um número linear de vezes. Como <code>(++)</code> tem custo linear, essa definição de <code>reverse</code> tem custo quadrático (em relação ao número de elementos de seu argumento).</p>
<p>Podemos definir <code>reverse</code> com custo linear (percorrendo seu argumento uma única vez) se fizermos uso de uma função auxiliar, da seguinte forma.</p>
<div class="sourceCode" id="cb13" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> xs <span class="ot">=</span> f xs [] <span class="kw">where</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    f [] acc <span class="ot">=</span> acc</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    f (x<span class="op">:</span>xs) acc <span class="ot">=</span> f xs (x<span class="op">:</span>acc)</span></code></pre></div>
<p>Vamos dar um tempo com nosso arquivo <code>List.hs</code> e criar um outro, <code>Bool.hs</code>. Nosso novo arquivo terá o seguinte conteúdo inicial.</p>
<div class="sourceCode" id="cb14" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span>(<span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>), <span class="dt">Applicative</span>(pure))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (<span class="dt">Alternative</span>(empty))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span></code></pre></div>
<p>Infelizmente não poderemos desenvolver nosso próprio tipo booleano, pois diversas funções em Haskell que são implementadas em baixo nível referenciam o tipo booleano usado pelo compilador. Por isso, importamos o tipo <code>Bool</code> e seus valores a partir de <code>Prelude</code>.</p>
<p>Em <code>Bool.hs</code>, vamos desenvolver duas funções bastante similares a operadores lógicos bem conhecidos.</p>
<div class="sourceCode" id="cb15" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> (<span class="dt">True</span><span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">and</span> xs</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> (<span class="dt">False</span><span class="op">:</span>_) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>A função <code>and</code> toma uma lista de valores booleanos e retorna um booleano. Se a lista contém apenas valores <code>True</code>, então ela retorna <code>True</code>. Do contrário, ela retorna <code>False</code>. Perceba que, além de decompor a lista em cabeça e cauda, criamos casos de acordo com os possíveis valores da cabeça. Essas decomposições de tipos em partes (lista em cabeça e cauda), bem como a criação de casos de acordo com os possíveis valores de uma certa parte, são chamadas de <em>pattern matching</em>. A seguir, definimos a função <code>or</code> de forma similar.</p>
<div class="sourceCode" id="cb16" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> (<span class="dt">True</span><span class="op">:</span>_) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> (<span class="dt">False</span><span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">or</span> xs</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 1</strong>.  <em>Implemente os operadores <em><code>(&amp;&amp;)</code></em> e <em><code>(||)</code></em>, ambos com assinatura <em><code>Bool -&gt; Bool -&gt; Bool</code></em>. Esses operadores funcionam de forma análoga a <em><code>and</code></em> e <em><code>or</code></em>, respectivamente, mas tomam necessariamente dois valores booleanos como argumentos.</em></p>
</div>
<p>Voltando a editar <code>List.hs</code>, criamos duas operações muito usuais em programação funcional, que consistem em tomar ou descartar prefixos de una lista. As funções <code>take</code> e <code>drop</code> fazem precisamente isso.</p>
<div class="sourceCode" id="cb17" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> <span class="dv">0</span> _ <span class="ot">=</span> []</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> _ [] <span class="ot">=</span> []</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> <span class="fu">take</span> (n <span class="op">-</span> <span class="dv">1</span>) xs</span></code></pre></div>
<p>Dado um inteiro <code>n</code>, <code>take</code> retorna um prefixo de comprimento <code>n</code> da lista de entrada (caso essa seja vazia, apenas a lista vazia pode ser retornada como prefixo). Observe, mais uma vez, o uso de <em>pattern matching</em> por valores: o primeiro caso verifica se o inteiro <code>n</code> tem valor 0. O último caso diz que, se <code>n</code> não é nulo (esperamos que seja positivo), e a lista não é vazia, então sua cabeça certamente faz parte do prefixo a ser retornado. Os <code>n - 1</code> elementos restantes do prefixo são tomados, de forma recursiva, da cauda da lista dada como entrada.</p>
<p>Antes de escrever a função <code>drop</code>, vamos criar um condicional, o que nos permitirá um outro estilo de escrita. A função <code>cond</code> é bem simples de entender, e ficará escrita em <code>Bool.hs</code>.</p>
<div class="sourceCode" id="cb18" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cond ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>cond <span class="dt">True</span> x _ <span class="ot">=</span> x</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>cond <span class="dt">False</span> _ y <span class="ot">=</span> y</span></code></pre></div>
<div class="sourceCode" id="cb19" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> _ [] <span class="ot">=</span> []</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> n xs <span class="ot">=</span> cond (n <span class="op">&lt;=</span> <span class="dv">0</span>) xs (<span class="fu">drop</span> (n <span class="op">-</span> <span class="dv">1</span>) (<span class="fu">tail</span> xs))</span></code></pre></div>
<p>Note que, nesse estilo de escrita, não usamos <em>pattern matching</em> para determinar a nulidade de <code>n</code>, nem para atribuir nomes às partes de uma lista não vazia. Usamos <code>cond</code> para tratar os valores de <code>n</code> (perceba que isso lida inclusive com o caso de <code>n</code> ter valor negativo) e <code>tail</code> para acessar a cauda da lista de entrada (graças ao primeiro caso, sabemos que <code>tail</code> nunca receberá uma lista vazia).</p>
<p>A função <code>splitAt</code> combina os resultados de <code>take</code> e <code>drop</code>. Para isso, ela faz uso de uma <em>tupla</em>.</p>
<div class="sourceCode" id="cb20" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a], [a])</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> n xs <span class="ot">=</span> (<span class="fu">take</span> n xs, <span class="fu">drop</span> n xs)</span></code></pre></div>
<p>Mais uma vez, essa definição simples não é a mais eficiente. Como é percebido, chamar <code>take</code> e <code>drop</code> com os mesmos argumentos implica em “passear" pelas mesmas posições da lista duas vezes. Implementando <code>splitAt</code> independentemente de <code>take</code> e <code>drop</code>, conseguimos resolver esse problema.</p>
<div class="sourceCode" id="cb21" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a], [a])</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> <span class="dv">0</span> xs <span class="ot">=</span> ([], xs)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> _ [] <span class="ot">=</span> ([], [])</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> n (x<span class="op">:</span>xs) <span class="ot">=</span> (x<span class="op">:</span>ps, qs) <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    (ps, qs) <span class="ot">=</span> <span class="fu">splitAt</span> (n <span class="op">-</span> <span class="dv">1</span>) xs</span></code></pre></div>
<p>Dessa vez, fizemos uso de <code>where</code> para receber o resultado da chamada recursiva, que é um par. Assim, podemos usar esse resultado para construir o retorno de <code>splitAt</code> de forma adequada.</p>
<p>Vamos criar nossa primeira função que exigirá uma restrição em sua assinatura. A função <code>isPrefixOf</code> recebe duas listas, e determina se a primeira é prefixo da segunda.</p>
<div class="sourceCode" id="cb22" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isPrefixOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>isPrefixOf [] _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>isPrefixOf _ [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>isPrefixOf (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> cond (x <span class="op">==</span> y) (isPrefixOf xs ys) <span class="dt">False</span></span></code></pre></div>
<p>Dessa vez, a função não recebe listas contendo um tipo qualquer. O tipo dos elementos das listas deve implementar as funções da classe <code>Eq</code>. Em Haskell, uma <em>classe</em> é apenas um grupo de funções. Um exemplo de classe é <code>Eq</code>, que contém os operadores <code>(==)</code> e <code>(/=)</code>. Assim, se um tipo é <em>instância</em> da classe <code>Eq</code>, podemos usar o operador <code>(==)</code> sobre seus valores. Em <code>isPrefixOf</code>, isso é necessário para determinar se os elementos da primeira lista são iguais aos primeiros elementos da segunda.</p>
<div id="exercicioIsInfixOf" class="exercicio">
<p><strong>Exercício 2</strong>.  <em>Implemente a função <em><code>isInfixOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code></em>, que decide se a primeira lista é sublista contínua da segunda.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 3</strong>.  <em>Implemente a função <em><code>isSubsequenceOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code></em>, que decide se a primeira lista é uma subsequência da segunda, não necessariamente contínua.</em></p>
</div>
<p>Por vezes, queremos percorrer duas listas simultaneamente. Uma forma de fazer isso é transformar as duas listas numa lista de pares, onde as primeiras e segundas posições vêm, respectivamente, da primeira e da segunda lista. A função <code>zip</code> faz justamente isso.</p>
<div class="sourceCode" id="cb23" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> [] _ <span class="ot">=</span> []</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> _ [] <span class="ot">=</span> []</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> (x, y) <span class="op">:</span> <span class="fu">zip</span> xs ys</span></code></pre></div>
<p>Vamos apresentar agora as primeiras funções que tomam funções como argumento. Por ser uma linguagem funcional, o sistema de tipos de Haskell é bastante robusto. Isso se mostra no fato de que não apenas tipos simples, como <code>Int</code> e <code>Bool</code>, são recebidos e retornados por funções, mas também assinaturas de funções podem ser argumentos ou o valor de retorno de certas funções (funções de <em>alta ordem</em>). Dizemos que, em Haskell, as funções são <em>habitantes de primeira classe</em>.</p>
<p>Lembra que a função <code>(++)</code> foi dita “binária"? Apesar de parecer que ela recebe dois argumentos, na verdade ela recebe um só. O seu retorno, no entanto, não é uma lista, e sim uma função. Em verdade, todas as funções em Haskell recebem apenas um argumento, e são portanto <em>unárias</em>. Particularmente, <code>(++)</code> recebe uma lista <code>xs</code> e retorna uma outra função. Essa outra função, por sua vez, recebe uma lista <code>ys</code> e retorna a lista que é a concatenação de <code>xs</code> e <code>ys</code>. Devemos nos acostumar a ler as assinaturas na forma <code>(++) :: [a] -&gt; ([a] -&gt; [a])</code>. Dessa forma, uma função é determinada pelo primeiro <code>-&gt;</code> de sua assinatura: antes dele, está o tipo de seu único argumento; após ele, o tipo de seu retormo.</p>
<p>Para receber uma função como argumento, escrevemos sua assinatura entre parênteses. Temos, por exemplo, a função <code>takeWhile</code>.</p>
<div class="sourceCode" id="cb24" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> _ [] <span class="ot">=</span> []</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> p (x<span class="op">:</span>xs) <span class="ot">=</span> cond (p x) (x <span class="op">:</span> <span class="fu">takeWhile</span> p xs) []</span></code></pre></div>
<p>Note que <code>p</code> é um argumento do tipo <code>a -&gt; Bool</code>. Dizemos que <code>p</code> é um <em>predicado</em>, isto é, uma função que recebe um valor de um certo tipo e retorna um valor booleano. Por exemplo, tomando a assinatura <code>(&lt;=) :: Ord a =&gt; a -&gt; a -&gt; Bool</code>, podemos criar o predicado <code>(0&lt;=) :: (Ord a, Num a) =&gt; a -&gt; Bool</code>, cujo argumento é um valor de um tipo numérico ordenável.</p>
<p>A função <code>takeWhile</code> toma um predicado e retorna uma função, que por sua vez toma uma lista e retorna seu maior prefixo cujos elementos satisfazem <code>p</code>. Seu par é a função <code>dropWhile</code>, que descarta o maior prefixo cujos elementos satisfazem um certo predicado.</p>
<div class="sourceCode" id="cb25" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span> _ [] <span class="ot">=</span> []</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span> p xs <span class="ot">=</span> cond (p (<span class="fu">head</span> xs)) (<span class="fu">dropWhile</span> p (<span class="fu">tail</span> xs)) xs</span></code></pre></div>
<p>Para esse contexto, o análogo da função <code>splitAt</code> se chama <code>span</code>. A função <code>span</code> combina os resultados de <code>takeWhile</code> e <code>dropWhile</code>, e já devemos ter uma ideia de como implementá-la de forma eficiente.</p>
<div class="sourceCode" id="cb26" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a], [a])</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span> _ [] <span class="ot">=</span> ([], [])</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span> p l<span class="op">@</span>(x<span class="op">:</span>xs) <span class="ot">=</span> cond (p x) (x<span class="op">:</span>ps, qs) ([], l) <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    (ps, qs) <span class="ot">=</span> <span class="fu">span</span> p xs</span></code></pre></div>
<p>Na definição de <code>span</code>, temos mais uma novidade sintática. Usamos <code>@</code> quando queremos nomear tanto um valor de um tipo composto quanto suas partes. Nesse caso, usamos <code>l@(x:xs)</code> para indicar que a lista passada como argumento se chama <code>l</code>, e também que sua cabeça e cauda se chamam, respectivamente, <code>x</code> e <code>xs</code>.</p>
<p>Em vez de usar <code>@</code>, poderíamos simplesmente escrever <code>x:xs</code> onde ocorre <code>l</code> na definição do segundo caso. No entanto, isso construiria uma nova lista igual a <code>l</code>. Por mais que tivessem a cauda compartilhada, ainda assim haveria algum desperdício de memória, e portanto o uso de <code>@</code> é preferível.</p>
<div class="exercicio">
<p><strong>Exercício 4</strong>.  <em>Implemente a função <em><code>insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code></em> que, dado um elemento de um tipo ordenável e uma lista ordenada, insere o elemento na lista, preservando a ordenação.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 5</strong>.  <em>Implemente a função <em><code>insertionSort :: Ord a =&gt; [a] -&gt; [a]</code></em>, que toma uma lista de elementos ordenáveis e retorna uma versão ordenada dessa lista.</em></p>
</div>
<p>Vamos criar um novo arquivo, <code>Functions.hs</code>, que terá o seguinte conteúdo inicial.</p>
<div class="sourceCode" id="cb27" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Functions</span> <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Applicative</span>(pure, (*&gt;)), <span class="dt">Monad</span>((&gt;&gt;=)), seq)</span></code></pre></div>
<p>Nele, definimos algo crucial para a expressividade e reuso em programação funcional: a composição de funções. Em Haskell, como era de se esperar, a composição de funções também é uma função.</p>
<div class="sourceCode" id="cb28" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">comp ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>comp f g x <span class="ot">=</span> f (g x)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g <span class="ot">=</span> comp f g</span></code></pre></div>
<p>Definimos <code>comp</code> para determinar a composição como uma função. Em seguida, definimos a composição como o operador <code>(.)</code>, que toma duas funções e retorna uma função (o resultado de passar <code>g</code> para a função retornada por <code>comp f</code>).</p>
<div class="exercicio">
<p><strong>Exercício 6</strong>.  <em>Implemente a função <em><code>replicate :: Int -&gt; a -&gt; [a]</code></em> que, dado um inteiro não-negativo <em><code>n</code></em> e um elemento <em><code>x</code></em>, cria uma lista de <em><code>n</code></em> elementos, todos iguais a <em><code>x</code></em>. Note que <em><code>replicate</code></em> pode ser definida como uma composição de <em><code>take</code></em> e <em><code>repeat</code></em>, essa última função proposta na Subseção <a href="#lab2" data-reference-type="ref" data-reference="lab2">4.2</a>.</em></p>
</div>
<p>Uma função bastante comum de ser composta com predicados é a função <code>not</code>. Sua descrição não exige explicações, e é escrita em <code>Bool.hs</code>.</p>
<div class="sourceCode" id="cb29" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> <span class="dt">True</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Voltando a editar <code>List.hs</code>, podemos agora definir a função <code>break</code>, cujo comportamento se assemelha ao de <code>span</code>. No entanto, <code>break</code> nega o predicado antes de particionar a lista recebida.</p>
<div class="sourceCode" id="cb30" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">break</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a], [a])</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">break</span> p xs <span class="ot">=</span> <span class="fu">span</span> (<span class="fu">not</span> <span class="op">.</span> p) xs</span></code></pre></div>
<p>Além de trabalhar apenas tomando prefixos de listas, é perfeitamente plausível que haja uma função que filtre uma lista com base em um predicado. Essa função costuma ser chamada de <code>filter</code>.</p>
<div class="sourceCode" id="cb31" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p [] <span class="ot">=</span> []</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p (x<span class="op">:</span>xs) <span class="ot">=</span> cond (p x) (x<span class="op">:</span>xs&#39;) xs&#39; <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    xs&#39; <span class="ot">=</span> <span class="fu">filter</span> p xs</span></code></pre></div>
<p>Apesar de todas as funções em Haskell serem unárias, conseguimos “simular" funções com mais argumentos retornando outras funções unárias para receber os argumentos restantes. Essa, no entanto, não é a única forma de fazer isso. Como tuplas são tipos compostos, podemos criar funções unárias que recebem uma tupla como seu único argumento, e assim poderíamos tratar cada posição da tupla recebida como um argumento independente. Quando usamos a primeira forma de “simular" mais de um argumento, estamos usando <em>curried functions</em> (como Curry é um sobrenome, uma tradução desse termo seria provavelmente tosca). Quando utilizamos tuplas para o mesmo fim, criamos <em>uncurried functions</em>.</p>
<p><em>Curried functions</em> costumam tornar a escrita em Haskell mais expressiva, permitindo um uso mais flexível das funções. No entanto, algumas situações podem tornar desejável que certas funções não sejam aplicadas parcialmente, e daí as <em>uncurried functions</em> ganham justificativa. Nesse sentido, definimos a função <code>uncurry</code>, que recebe uma <em>curried function</em> “binária" e retorna a <em>uncurried function</em> equivalente. Ela deve ser escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb32" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> c</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span> f (x, y) <span class="ot">=</span> f x y</span></code></pre></div>
<p>Ironicamente, a função <code>uncurry</code> deve ser aplicada parcialmente para que retorne a <em>uncurried function</em> correspondente ao seu argumento. Assim, <code>uncurry (+)</code> seria equivalente a <code>(+)</code>, mas não permitiria aplicações parciais (como <code>(1+)</code>). Para tornar <em>uncurried</em> funções com mais de dois argumentos, seria preciso escrever a versão de <code>uncurry</code> apropriada.</p>
<h2 id="abstraindo-o-conceito-de-loop">Abstraindo o conceito de <em>loop</em></h2>
<p>Vimos anteriormente a função <code>filter</code>, que filtra os elementos de uma lista conforme um predicado. Em uma linguagem imperativa, teríamos usado um <em>loop</em> (como um <em>for</em>) e um condicional para obter um resultado similar. Em Haskell, as diversas formas de se tratar o conteúdo de uma lista devem ser suficientes para fazer tudo que é possível com o auxílio de <em>loops</em>.</p>
<p>A função <code>map</code> transforma o conteúdo de uma lista de acordo com uma função. Ela pode ser implementada como segue, e sua definição será escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb33" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f [] <span class="ot">=</span> []</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 7</strong>.  <em>Implemente a função <em><code>inits :: [a] -&gt; [[a]]</code></em>, que retorna todos os prefixos da lista dada como entrada.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 8</strong>.  <em>Implemente a função <em><code>tails :: [a] -&gt; [[a]]</code></em>, que retorna todos os sufixos da lista dada como entrada.</em></p>
</div>
<p>Caso <code>f</code> tivesse mais argumentos, a função <code>map</code> não serviria. A função <code>zipWith</code> segue a mesma lógica de <code>map</code>, mas é usada para funções com “dois" argumentos. Também será escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb34" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> f [] _ <span class="ot">=</span> []</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> f _ [] <span class="ot">=</span> []</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> f (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> f x y <span class="op">:</span> <span class="fu">zipWith</span> f xs ys</span></code></pre></div>
<p>Podemos inclusive utilizar <code>zipWith</code> para implementar <code>zip</code> como uma aplicação parcial usando <code>(,) :: a -&gt; b -&gt; (a, b)</code>. Voltamos ao nosso arquivo <code>List.hs</code> e reescrevemos <code>zip</code> como segue.</p>
<div class="sourceCode" id="cb35" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> <span class="ot">=</span> <span class="fu">zipWith</span> (,)</span></code></pre></div>
<p>Até agora, nossas funções tomam listas como argumentos e retornam listas, sejam estas sublistas ou transformações da lista de entrada. Por vezes, é desejável fazer uma computação que envolva todos os elementos da lista. Um somatório, por exemplo, tomaria uma lista de valores de um tipo numérico e retornaria um único valor desse tipo. Em Haskell, o ato de transformar todos os elementos de uma lista <code>[a]</code> em um único elemento de um tipo <code>b</code> é chamado <em>folding</em>, e costuma ser realizado com o auxílio de uma função.</p>
<p>Podemos começar a “dobrar" os elementos de uma lista a partir de qualquer uma de suas duas extremidades. A função <code>foldl</code> começa pela esquerda, emquamto <code>foldr</code> começa pela direita. Manteremos a definição de ambas em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb36" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f acc [] <span class="ot">=</span> acc</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f acc (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">foldl</span> f (f acc x) xs</span></code></pre></div>
<p>Vamos explicar o que <code>foldl</code> está fazendo. No caso base, não há elementos da lista para “dobrar" e <code>foldl</code> retorna o acumulador, o argumento responsável por guardar o resultado das “dobras" já feitas. No segundo caso, a lista não está vazia, e <code>foldl</code> “dobra" a cabeça da lista usando a função <code>f</code> para atualizar o acumulador, e o resultado é passado como acumulador para a chamada recursiva.</p>
<p>Uma coisa importante de se notar é que a definição recursiva de <code>foldl</code> é apenas uma chamada de <code>foldl</code>. Funções com essa propriedade são ditas <em>recursivas por cauda</em>, e são eficientes no uso de memória, devido a otimizações que os compiladores modernos são capazes de fazer. Agora definimos <code>foldr</code>.</p>
<div class="sourceCode" id="cb37" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f acc [] <span class="ot">=</span> acc</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f acc (x<span class="op">:</span>xs) <span class="ot">=</span> f x (<span class="fu">foldr</span> f acc xs)</span></code></pre></div>
<p>Não deve ser difícil perceber que a definição de <code>foldr</code> retorna um valor de um tipo como é proposto na assinatura. O mais intrigante é entender como <code>foldl</code> e <code>foldr</code> “dobram" os elementos na ordem que cada uma propõe. Isso está relacionado à forma como a função <code>f</code> é utilizada. Em <code>foldl</code>, <code>f</code> é usada para calcular um argumento de uma chamada de <code>foldl</code>, e como a definição recursiva é essencialmente essa chamada, <code>x</code> é o primeiro elemento da lista a ser computado por <code>f</code>. Já em <code>foldr</code>, a definição recursiva tem seu resultado dado por uma chamada de <code>f</code>, cujo segundo argumento é dado por <code>foldr</code>, dessa vez aplicada à cauda. Assim, se o retorno de <code>f</code> for totalmente dependente de seu segundo argumento, <code>x</code> será o último elemento da lista a ser computado por <code>f</code>, uma vez que a chamada recursiva de <code>foldr</code> ocorrerá antes, e irá tratar de todos os elementos da cauda <code>xs</code>.</p>
<p>Como exemplos do uso de <code>foldl</code>, podemos descrever as seguintes funções em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb38" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">+</span>) <span class="dv">0</span> </span></code></pre></div>
<div class="sourceCode" id="cb39" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prod ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>prod <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">*</span>) <span class="dv">1</span> </span></code></pre></div>
<p>Para ilustrar o uso de <code>foldr</code>, podemos reescrever <code>filter</code> da seguinte forma.</p>
<div class="sourceCode" id="cb40" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p xs <span class="ot">=</span> <span class="fu">foldr</span> f [] xs <span class="kw">where</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    f x ys <span class="ot">=</span> cond (p x) (x<span class="op">:</span>ys) ys</span></code></pre></div>
<p>Note como a definição de <code>f</code> se assemelha à definição anterior de <code>filter</code>. Perceba que, pela definição de <code>foldr</code>, <code>ys</code> pode ser vista como a cauda já filtrada de acordo com <code>p</code>. Além disso, como o retorno de <code>f</code> (uma lista) não depende totalmente de <code>ys</code> (caso <code>p x == True</code>, a cabeça não é elemento de <code>ys</code>), <code>foldr</code> não cumpre o seu papel. Ela sempre o cumpriria em uma linguagem de <em>avaliação estrita</em>, isto é, numa linguagem em que a computação dos argumentos precede a chamada da função.</p>
<p>Aparentemente falha por conta das características de Haskell, <code>foldr</code> faz algo que <code>foldl</code> não pdoe fazer: o retorno parcial de seu resultado. Isso é notável quanto ao retorno de listas: <code>foldl</code>, por ser recursiva por cauda, precisa computar a lista inteira antes de poder retornar seu primeiro elemento, enquanto <code>foldr</code> disponibiliza os elementos tão logo estejam computados. O impacto disso fica evidente com o auxílio desta definição de <code>takeWhile</code>, que deixaremos escrita em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb41" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> p xs <span class="ot">=</span> <span class="fu">foldr</span> f [] xs <span class="kw">where</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    f x ys <span class="ot">=</span> cond (p x) (x<span class="op">:</span>ys) []</span></code></pre></div>
<p>Perceba que há uma única diferença dessa definição de <code>takeWhile</code> para a definição de <code>filter</code>. Suponha que apenas os três primeiros elementos de uma lista satisfaçam um certo predicado. <code>foldr</code> verificaria apenas os quatro primeiros elementos, não importa o tamanho da lista, enquanto que operações semelhantes com <code>foldl</code> precisariam percorrer a lista toda, pelo fato de <code>foldl</code> ser recursiva por cauda.</p>
<div class="exercicio">
<p><strong>Exercício 9</strong>.  <em>Implemente as funções <em><code>and</code></em>, <em><code>or</code></em> e <em><code>map</code></em> como chamadas de <em><code>foldr</code></em>.</em></p>
</div>
<div id="exercicio:iterate" class="exercicio">
<p><strong>Exercício 10</strong>.  <em>Um outro conceito de <em>loop</em> é a iteração, que consiste em, dada uma função e um elemento inicial, aplicar a função a esse elemento, e repetir esse processo com o resultado dessa aplicação. Implemente a função <em><code>iterate :: (a -&gt; a) -&gt; a -&gt; [a]</code></em> que, dados uma função <em><code>f</code></em> e um elemento <em><code>x</code></em>, cria uma lista infinita com os resultados de sucessivas aplicações de <em><code>f</code></em> em <em><code>x</code></em>, isto é, <em><code>iterate f x == [x, f x, f (f x), …]</code></em>. Perceba que <em><code>iterate</code></em> não é muito útil por si só.</em></p>
</div>
<h2 id="usando-tipos-para-o-tratamento-de-erros">Usando tipos para o tratamento de erros</h2>
<p>Vimos anteriormente que <code>error</code> é capaz de indicar erros de execução, interrompendo o fluxo usual do programa com o lançamento de uma exceção. No entanto, <code>error</code> não nos dá a oportunidade de tratar esses erros, muito menos fornece uma forma simples de indicar que uma função pdoe falhar. Ao lermos a assinatura de <code>head</code>, por exemplo, nada nos diz que existe a chance de ela lançar uma exceção. Vamos criar um tipo justamente com o propósito de representar uma computação que pode falhar.</p>
<p>Criamos o arquivo <code>Maybe.hs</code> com o conteúdo inicial a seguir.</p>
<div class="sourceCode" id="cb42" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>),</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Functor</span>(<span class="fu">fmap</span>),</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Applicative</span>((<span class="op">&lt;*&gt;</span>)),</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Monad</span>((<span class="op">&gt;&gt;=</span>)))</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>Aqui, temos o primeiro uso de <code>data</code>, que serve para a definição de um tipo. Criamos o tipo <code>Maybe</code> que, dado um tipo <code>a</code> como argumento, representa um conjunto de valores em dois casos: <code>Maybe a</code> pode estar vazio (<code>Nothing</code>) ou pode conter um único valor do tipo <code>a</code> (<code>Just a</code>). A possibilidade de <code>Maybe a</code> conter nenhum valor do tipo <code>a</code> nos permite representar uma falha com <code>Nothing</code>, pois se uma computação não é bem sucedida, ela produz nenhum valor.</p>
<p>Como exemplo de seu uso, podemos importar o módulo <code>Maybe</code> em <code>List.hs</code> e definir versões bem comportadas de <code>head</code> e <code>tail</code>.</p>
<div class="sourceCode" id="cb43" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>safeHead [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>safeHead (x<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="ot">safeTail ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>safeTail [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>safeTail (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> xs</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 11</strong>.  <em>Implemente a função <em><code>uncons :: [a] -&gt; Maybe (a, [a])</code></em> que, dada uma lista, retorna uma tupla composta, respectivamente, por sua cabeça e sua cauda. Note que a função <em><code>uncons</code></em> evita lançar uma exceção caso receba uma lista vazia.</em></p>
</div>
<p>Vemos que <code>safeHead</code> e <code>safeTail</code> não lançam exceções, mas representam seus casos falhos retornando <code>Nothing</code>. É sempre preferível usar o sistema de tipos para tratar os erros, em vez de apenas lançar uma exceção. Como a validação dos tipos de um programa é feita em tempo de compilação, o compilador consegue nos dizer se todas as possibildiades de erro estão tratadas antes de executarmos nosso programa.</p>
<p>Vamos agora desenvolver um aparato para facilitar o tratamento de valores do tipo <code>Maybe a</code>. Os seguintes predicados são úteis para facilitar futuras definições.</p>
<div class="sourceCode" id="cb44" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isNothing ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>isNothing <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>isNothing _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>isJust <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> isNothing</span></code></pre></div>
<p>Agora definimos a função <code>maybe</code>.</p>
<div class="sourceCode" id="cb45" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span><span class="ot"> ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span> y f <span class="dt">Nothing</span> <span class="ot">=</span> y</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span> _ f (<span class="dt">Just</span> x) <span class="ot">=</span> f x</span></code></pre></div>
<p>Pela assinatura de <code>maybe</code>, podemos entender seu objetivo. A função <code>maybe</code> recebe um valor do tipo <code>b</code> e uma função <code>f</code>, além de um valor do tipo <code>Maybe a</code>. Com a ajuda de <code>y</code>, <code>maybe</code> consegue tratar uma possível falha em seu “terceiro" argumento: caso esse seja <code>Nothing</code>, <code>y</code> é retornado como um valor padrão; caso contrário, <code>x</code> é aplicado a <code>f</code> para produzir o valor de retorno.</p>
<p>Perceba ainda que <code>maybe</code> é feita para ser aplicada parcialmente. Uma vez aplicados <code>y</code> e <code>f</code>, <code>maybe</code> retorna uma versão de <code>f</code> que tolera falhas em seu argumento.</p>
<div class="sourceCode" id="cb46" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromMaybe ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>fromMaybe y <span class="dt">Nothing</span> <span class="ot">=</span> y</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>fromMaybe _ (<span class="dt">Just</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>A função <code>fromMaybe</code> também serve para definir um valor padrão em caso de falha, mas de forma mais simples. Por não receber uma função, é útil para definir valores padrão quando um valor do tipo <code>Maybe a</code> deveria ser usado em uma expressão.</p>
<div class="sourceCode" id="cb47" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">catMaybes ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>catMaybes [] <span class="ot">=</span> []</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>catMaybes (<span class="dt">Nothing</span><span class="op">:</span>xs) <span class="ot">=</span> catMaybes xs</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>catMaybes ((<span class="dt">Just</span> x)<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> catMaybes xs</span></code></pre></div>
<p>A função <code>catMaybes</code> remove os valores <code>Nothing</code> de uma lista de elementos do tipo <code>Maybe a</code>, enquanto também extrai os valores agregados aos <code>Just</code>.</p>
<div class="sourceCode" id="cb48" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>mapMaybe f <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">map</span> f</span></code></pre></div>
<p>Por fim, a função <code>mapMaybe</code> transforma uma lista de elementos do tipo <code>a</code> usando uma função que pode falhar, e em seguida remove as transformações que falharam. Repare como a divisão entre esses dois passos é evidenciada com <code>(.)</code>, e mais uma vez, a composição de funções promove o reuso de código.</p>
<h2 id="representando-valores-disjuntivos">Representando valores disjuntivos</h2>
<p>Nesta subseção, implementamos o tipo <code>Either a b</code>, cujos valores representam uma disjunção entre valores dos tipos <code>a</code> e <code>b</code>. Escrevemos suas definições em <code>Either.hs</code>, que tem o seguinte conteúdo inicial.</p>
<div class="sourceCode" id="cb49" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>))</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>Por vezes, percebe-se o uso de <code>Either</code> apenas como um <code>Maybe</code> “informativo”, já que <code>Either [Char] b</code> pode representar um erro com <code>Left [Char]</code>, permitindo uma string que o descreva. Esse, no entanto, é um uso muito limitado de <code>Either</code>, que facilita a descrição de alguns algoritmos.</p>
<p>Desenvolvemos facilidades para a manipulação de <code>Either</code>. As funções que seguem são escritas também em <code>Either.hs</code>.</p>
<div class="sourceCode" id="cb50" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">either</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> c</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">either</span> f _ (<span class="dt">Left</span> x) <span class="ot">=</span> f x</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="fu">either</span> _ g (<span class="dt">Right</span> y) <span class="ot">=</span> g y</span></code></pre></div>
<p>A função <code>either</code> toma duas funções para “resolver” a disjunção provocada por <code>Either</code>. É irresistível traçar uma analogia com construções como <em>switch</em> e <em>case</em>, típicas de linguagens procedurais. No entanto, o <em>switching</em> não ocorre entre valores de um certo tipo, mas sim entre dois tipos.</p>
<div class="sourceCode" id="cb51" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lefts ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> [a]</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>lefts [] <span class="ot">=</span> []</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>lefts (<span class="dt">Left</span> x <span class="op">:</span> xs) <span class="ot">=</span> x <span class="op">:</span> lefts xs</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>lefts (<span class="dt">Right</span> _ <span class="op">:</span> xs) <span class="ot">=</span> lefts xs</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="ot">rights ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> [b]</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>rights [] <span class="ot">=</span> []</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>rights (<span class="dt">Left</span> _ <span class="op">:</span> xs) <span class="ot">=</span> rights xs</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>rights (<span class="dt">Right</span> x <span class="op">:</span> xs) <span class="ot">=</span> x <span class="op">:</span> rights xs</span></code></pre></div>
<p>A função <code>lefts</code> (<code>rights</code>) filtra os elementos de tipo <code>a</code> (<code>b</code>) e os retorna em uma lista. Usa-se <em>pattern matching</em> para isso, e as definições são imediatas.</p>
<div class="sourceCode" id="cb52" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isLeft ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>isLeft (<span class="dt">Left</span> _) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>isLeft _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="ot">isRight ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>isRight <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> isLeft</span></code></pre></div>
<p>As definições de <code>isLeft</code> e <code>isRight</code> são elementares. Partimos para as próximas definições.</p>
<div class="sourceCode" id="cb53" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLeft ::</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> a</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>fromLeft _ (<span class="dt">Left</span> x) <span class="ot">=</span> x</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>fromLeft x (<span class="dt">Right</span> _) <span class="ot">=</span> x</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fromRight ::</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> b</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>fromRight x (<span class="dt">Left</span> _) <span class="ot">=</span> x</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>fromRight _ (<span class="dt">Right</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>As funções <code>fromLeft</code> e <code>fromRight</code> retornam valores padrão caso não recebam o caso correspondente, do contrário retornam o valor nele contido.</p>
<div class="exercicio">
<p><strong>Exercício 12</strong>.  <em>Implemente a função <em><code>partitionEithers :: [Either a b] -&gt; ([a], [b])</code></em>.</em></p>
</div>
<h2 id="árvores-binárias-de-busca">Árvores binárias de busca</h2>
<p>Em programação funcional, definimos o conceito das operações sem levar em conta como seria sua implementação na arquitetura que utilizamos. Isso é suficiente para caracterizar as linguagens desse paradigma como de alto nível, o que lhes confere muita expressividade, já que a escrita de código não menciona detalhes alheios à lógica das definições. Há, no entanto, um preço a se pagar por essa característica.</p>
<p>Por se distanciar dos detalhes da arquitetura e abordar a programação por um viés matemático, as linguagens funcionais não têm contato com estruturas de dados cujo conceito é dependente da arquitetura. É o caso, por exemplo, dos <em>arrays</em>, que são dotados de acesso em tempo constante a qualquer uma de suas posições. Uma lista, por outro lado, garante apenas acesso em tempo linear a seus elementos, o que é uma desvantagem séria. Para garantir a eficiência dos programas funcionais, é preciso construir uma estrutura de dados que alivie esse problema.</p>
<p>Vamos criar um arquivo <code>BSTree.hs</code>, que conterá as definições necessárias para o uso de árvores binárias de busca. Apesar de não terem acesso em tempo constante a seus elementos, mas apenas em tempo logarítmico (quando balanceadas), elas proporcionam um tempo de acesso muito superior ao das listas. É verdade que esse tempo de acesso ainda não é tão bom quanto o de um <em>array</em>, mas é eficiente o bastante (e o obtemos sem nos incomodar com detalhes da arquitetura).</p>
<div class="sourceCode" id="cb54" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">BSTree</span> <span class="kw">where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Ord</span>, <span class="dt">Ordering</span>(<span class="dt">LT</span>, <span class="dt">EQ</span>, <span class="dt">GT</span>), compare,</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Eq</span>, (<span class="op">==</span>),</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>),</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Functor</span>(<span class="fu">fmap</span>)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span> ((.))</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BSTree</span> k v <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Branch</span> (k, v) (<span class="dt">BSTree</span> k v) (<span class="dt">BSTree</span> k v)</span></code></pre></div>
<p>Isso define uma árvore binária de busca, com chaves do tipo <code>k</code> e valores do tipo <code>v</code>. Temos dois casos para nossa árvore: ela pode ser vazia (<code>Empty</code>) ou pode ser ramificada (<code>Branch</code>), contendo um par de chave e valor (<code>(k, v)</code>) e duas sub-árvores, sendo assim definida recursivamente.</p>
<p>Estamos definindo um <em>tipo parametrizado</em>, isto é, um tipo que precisa de outros tipos para estar completo. Apenas <code>BSTree</code> não é um tipo bem definido. Para completar a definição desse tipo, é preciso informar que tipo servirá de chave (<code>k</code>) e que tipo servirá de valor (<code>v</code>). Como exemplo, <code>BSTree Int [Char]</code> é uma árvore binária de busca chaveada por inteiros e valorada por strings. A lista, inclusive, é outro tipo parametrizado, já que precisa determinar o tipo de seus elementos para estar bem definida. O tipo <code>Maybe a</code> também ilustra o uso de um parâmetro para a definição de um tipo.</p>
<p>Vamos escrever uma função que retorna uma árvore vazia. Faremos com que este seja o único modo de criar uma <code>BSTree</code> fora desse módulo.</p>
<div class="sourceCode" id="cb55" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">BSTree</span> k v</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Empty</span></span></code></pre></div>
<p>É apenas isso. Basta retornar o valor do primeiro caso. Agora, definimos como deve ocorrer uma inserção em nossa árvore.</p>
<div class="sourceCode" id="cb56" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">BSTree</span> k v</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>insert <span class="dt">Empty</span> (key&#39;, val&#39;) <span class="ot">=</span> <span class="dt">Branch</span> (key&#39;, val&#39;) empty empty</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>insert bst<span class="op">@</span>(<span class="dt">Branch</span> (key, val) ltree rtree) (key&#39;, val&#39;) <span class="ot">=</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    decide (<span class="fu">compare</span> key&#39; key) <span class="kw">where</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">LT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree&#39; rtree</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">EQ</span> <span class="ot">=</span> bst</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">GT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree rtree&#39;</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>        ltree&#39; <span class="ot">=</span> insert ltree (key&#39;, val&#39;)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        rtree&#39; <span class="ot">=</span> insert rtree (key&#39;, val&#39;)</span></code></pre></div>
<p>No seu primeiro caso, <code>insert</code> transforma uma árvore vazia em uma árvore ramificada com as duas sub-árvores vazias. No segundo caso, é preciso tratar a inserção de forma a preservar as invariantes de uma árvore binária de busca: não pode haver chaves duplicadas e todas as chaves contidas na sub-árvore esquerda (direita) devem ser menores (maiores) que a chave presente na raiz. A função auxiliar <code>decide</code> compara a chave a ser inserida (<code>key’</code>) com a chave da raiz (<code>key</code>) por meio de <code>compare</code>, que por sua vez retorna um valor do tipo <code>Ordering</code>: <code>LT</code> (<em>less than</em>), <code>EQ</code> (<em>equals</em>) ou <code>GT</code> (<em>greater than</em>). Caso <code>decide</code> receba <code>EQ</code>, a nova chave é duplicada e retorna-se <code>bst</code>, o que não modifica a árvore. Caso <code>decide</code> receba <code>LT</code> (<code>GT</code>), a operação de inserção é feita recursivamente na sub-árvore esquerda (direita), conforme a definição de <code>ltree’</code> (<code>rtree’</code>).</p>
<p>Note como a preguiça de Haskell afeta a definição de <code>insert</code>. Apesar de ambas <code>ltree’</code> e <code>rtree’</code> estarem definidas, no máximo uma delas será computada. Isso ocorre porque, em todos os três casos, no máximo uma delas é utilizada para definir o retorno.</p>
<p>Além disso, é preciso chamar a atenção para a natureza <em>imutável</em> dos valores de tipos em Haskell. Uma função nunca altera o valor associado aos identificadores de seus argumentos. Dessa forma, <code>insert</code> não altera a árvore recebida, mas retorna uma nova árvore com o par de chave e valor inserido.</p>
<p>A propriedade de que valores associados a identificadores são imutáveis não quer dizer que uma implementação de Haskell seja necessariamente um desastre em termos de consumo de memória. Como os valores são imutáveis, não há prejuízo em tipos compostos (como listas e árvores) partilharem alguns de seus campos, como listas partilharem caudas ou árvores partilharem sub-árvores, já que essas partes em comum nunca serão alteradas. A imutabilidade, inclusive, permite que um compilador pratique otimizações muito agressivas, mesmo em programas com múltiplas <em>threads</em>.</p>
<p>Definimos agora uma forma de consultar um valor do tipo <code>BSTree k v</code>. A função <code>lookup</code> toma uma árvore e uma chave, e verifica se a árvore contém a chave.</p>
<div class="sourceCode" id="cb57" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (<span class="dt">Branch</span> (key, val) ltree rtree) key&#39; <span class="ot">=</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    decide (<span class="fu">compare</span> key&#39; key) <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">LT</span> <span class="ot">=</span> <span class="fu">lookup</span> ltree key&#39;</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">EQ</span> <span class="ot">=</span> <span class="dt">Just</span> val</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">GT</span> <span class="ot">=</span> <span class="fu">lookup</span> rtree key&#39;</span></code></pre></div>
<p>Como não há garantias de que a árvore contém a chave, e portanto um valor associado a ela, <code>lookup</code> deve retornar <code>Maybe v</code>. A lógica de busca também baseia-se nas invariantes de uma árvore binária de busca, o que torna a estrutura dessa definição similar à da definição de <code>insert</code>. Podemos definir rapidamente uma função que verifica se uma árvore contém uma certa chave.</p>
<div class="sourceCode" id="cb58" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">contains ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>contains bst <span class="ot">=</span> isJust <span class="op">.</span> <span class="fu">lookup</span> bst</span></code></pre></div>
<p>Além de inserir valores associados a chaves em nossa árvore, é interessante que possamos atualizar o valor de uma chave. Isso nos permitiria utilizar mais facilmente a <code>BSTree</code> em certas situações.</p>
<div class="sourceCode" id="cb59" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">update ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> (v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">BSTree</span> k v</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>update <span class="dt">Empty</span> _ _ <span class="ot">=</span> empty</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>update (<span class="dt">Branch</span> (key, val) ltree rtree) key&#39; f <span class="ot">=</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    decide (<span class="fu">compare</span> key&#39; key) <span class="kw">where</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">LT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree&#39; rtree</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">EQ</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, f val) ltree rtree</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">GT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree rtree&#39;</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>        ltree&#39; <span class="ot">=</span> update ltree key&#39; f</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>        rtree&#39; <span class="ot">=</span> update rtree key&#39; f</span></code></pre></div>
<p>Vamos escrever funções para determinar as chaves máximas e mínimas de uma árvore, junto com seu valor.</p>
<div class="sourceCode" id="cb60" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxKey ::</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (k, v)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>maxKey <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>maxKey (<span class="dt">Branch</span> keyval _ <span class="dt">Empty</span>) <span class="ot">=</span> <span class="dt">Just</span> keyval</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>maxKey (<span class="dt">Branch</span> _ _ rtree) <span class="ot">=</span> maxKey rtree</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="ot">minKey ::</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (k, v)</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>minKey <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>minKey (<span class="dt">Branch</span> keyval <span class="dt">Empty</span> _) <span class="ot">=</span> <span class="dt">Just</span> keyval</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>minKey (<span class="dt">Branch</span> _ ltree _) <span class="ot">=</span> minKey ltree</span></code></pre></div>
<p>Note como não precisamos restringir <code>k</code> a ser instância da classe <code>Ord</code> nessas duas funções. Isso é possível porque não fazemos comparações. A busca pela chave máxima (mínima) utiliza apenas a estrutura da árvore e suas invariantes: caso a sub-árvore direita (esquerda) não seja vazia, a chave máxima (mínima) tem de estar lá. Ambas as funções sequer “abrem" o conteúdo do par <code>keyval</code>, usando esse identificador para a tupla inteira em vez de associar identificadores individuais às componentes do par.</p>
<p>Vamos agora definir como é feita a remoção de uma chave da <code>BSTree</code>.</p>
<div class="sourceCode" id="cb61" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">remove ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">BSTree</span> k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">BSTree</span> k v</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>remove <span class="dt">Empty</span> _ <span class="ot">=</span> empty</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>remove bst<span class="op">@</span>(<span class="dt">Branch</span> (key, val) ltree rtree) key&#39; <span class="ot">=</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    decide (<span class="fu">compare</span> key&#39; key) <span class="kw">where</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">LT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree&#39; rtree</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">GT</span> <span class="ot">=</span> <span class="dt">Branch</span> (key, val) ltree rtree&#39;</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        decide <span class="dt">EQ</span> <span class="ot">=</span> removeRoot bst</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        ltree&#39; <span class="ot">=</span> remove ltree key&#39;</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>        rtree&#39; <span class="ot">=</span> remove rtree key&#39;</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>        removeRoot <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>        removeRoot (<span class="dt">Branch</span> _ lt <span class="dt">Empty</span>) <span class="ot">=</span> lt</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        removeRoot (<span class="dt">Branch</span> _ <span class="dt">Empty</span> rt) <span class="ot">=</span> rt</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>        removeRoot (<span class="dt">Branch</span> _ lt rt) <span class="ot">=</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Branch</span> (keyMinR, valMinR) lt rt&#39; <span class="kw">where</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (keyMinR, valMinR) <span class="ot">=</span> minKey rt</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>                rt&#39; <span class="ot">=</span> remove rt keyMinR</span></code></pre></div>
<p>Essa função não é tão complexa quanto parece. Basicamente, <code>remove</code> busca pela chave a ser removida e, se ela é encontrada, a sub-árvore da qual ela é raiz é passada para a função <code>removeRoot</code>. A função <code>removeRoot</code> faz exatamente o que seu nome diz, e para isso há quatro casos (referentes ao número de sub-árvores não vazias). O primeiro caso nunca será usado (por quê?), e apenas deixa completa a definição de <code>removeRoot</code>. Os dois próximos casos são imediatos, e temos o último caso, onde a árvore em questão tem suas duas sub-árvores não vazias: tomamos o par de menor chave na sub-árvore direita para substituir o par da raiz, e em seguida o removemos da sub-árvore direita, para não haver chaves duplicadas. Dessa forma, a antiga chave da raiz não estará presente na árvore a ser retornada.</p>
<p>Há duas observações interessantes. A primeira é que <code>keyMinR</code> nunca usará o último caso de <code>removeRoot</code>. Para perceber isso mais claramente, basta ver a definição de <code>minKey</code>. A segunda observação é sobre como o retorno de <code>minKey</code> é tomado. Temos a liberdade de admitir que seu retorno será um <code>Just (k, v)</code> pelo fato de que <code>removeRoot</code> nunca passa uma árvore vazia para <code>minKey</code>.</p>
<p>Assim como definimos <code>map</code> (em <code>Functions.hs</code>) para aplicar uma função em uma lista, podemos declarar uma função <code>map</code> dentro de <code>BSTree.hs</code> com o mesmo propósito. Mais adiante, veremos como evitar conflitos entre funções homônimas.</p>
<div class="sourceCode" id="cb62" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (v1 <span class="ot">-&gt;</span> v2) <span class="ot">-&gt;</span> <span class="dt">BSTree</span> k v1 <span class="ot">-&gt;</span> <span class="dt">BSTree</span> k v2</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ <span class="dt">Empty</span> <span class="ot">=</span> empty</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="dt">Branch</span> (key, val) ltree rtree) <span class="ot">=</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Branch</span> (key, f val) ltree&#39; rtree&#39; <span class="kw">where</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        ltree&#39; <span class="ot">=</span> <span class="fu">map</span> f ltree</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        rtree&#39; <span class="ot">=</span> <span class="fu">map</span> f rtree</span></code></pre></div>
<p>É interessante que a lista e <code>BSTree</code> possam ambas ter seu conteúdo transformado. Inclusive, isso é esperado de tipos que representam estruturas de dados. Mais adiante, veremos que essa propriedade ocorre com frequência em diversos tipos.</p>
<p>Se quisermos comparar duas árvores por igualdade, devemos fazer <code>BSTree k v</code> ser uma instância da classe <code>Eq</code>. Isso pode ser feito da seguinte forma.</p>
<div class="sourceCode" id="cb63" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Eq</span> k, <span class="dt">Eq</span> v) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">BSTree</span> k v) <span class="kw">where</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Empty</span> <span class="op">==</span> <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Empty</span> <span class="op">==</span> _     <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    _     <span class="op">==</span> <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Branch</span> (key, val) ltree rtree) <span class="op">==</span> (<span class="dt">Branch</span> (key&#39;, val&#39;) ltree&#39; rtree&#39;) <span class="ot">=</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">and</span> [key <span class="op">==</span> key&#39;, val <span class="op">==</span> val&#39;, ltree <span class="op">==</span> ltree&#39;, rtree <span class="op">==</span> rtree&#39;]</span></code></pre></div>
<p>Nessa definição, exigimos que <code>k</code> e <code>v</code> sejam comparáveis por igualdade para determinar o comparador de igualdade de <code>BSTree k v</code>. Sua definição não deve ser difícil de entender. O que deve chamar a atenção aqui é o fato de que essa não é a única definição plausível de igualdade entre árvores. É possível pensar, por exemplo, que duas árvores são estruturalmente iguais se têm o mesmo conjunto de chaves, dispostas da mesma forma. Nesses casos, onde há mais de uma definição (semanticamente) plausível para tornar um tipo instância de uma classe, existe um recurso da linguagem para “encapsular" um tipo como outro, de forma que ele possa ser instância de uma classe mais de uma vez. Isso será abordado futuramente.</p>
<p>Por fim, para concluir o módulo <code>BSTree.hs</code>, definimos sua lista de exportação, ou seja, as definições do módulo que serão visíveis para quem o importa. Essa é uma prática usual para esconder a definição de um tipo e funções auxiliares. Modificamos o começo de <code>BSTree.hs</code> da seguinte forma.</p>
<div class="sourceCode" id="cb64" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">BSTree</span> (<span class="dt">BSTree</span>, empty,</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>               insert, update, remove, <span class="fu">map</span>,</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>               <span class="fu">lookup</span>, contains) <span class="kw">where</span></span></code></pre></div>
<p>Módulos como <code>BSTree.hs</code>, que contém a definição de um tipo, costumam ter funções homônimas às definidas para outros tipos. Para evitar conflitos entre nomes de funções, é sempre bom importar esses módulos como <code>qualified</code>. Assim, <code>import qualified BSTree as BST</code> deixa vísiveis as definições exportadas de <code>BSTree.hs</code> a partir do símbolo <code>BST</code>. Quando formos utilizar a função <code>empty</code>, por exemplo, ela será referenciada como <code>BST.empty</code>. Perceba que essa prefixação é suficiente para resolver conflitos entre funções homônimas definidas em módulos distintos.</p>
<div class="exercicio">
<p><strong>Exercício 13</strong>.  <em>Escreva a função <em><code>breadth :: BSTree k v -&gt; [(k, v)]</code></em> que, dada uma árvore binária de busca, retorna seus pares de chave e valor em largura. Isso quer dizer que os elementos são retornados, a cada nível, da esquerda para a direita, começando pelo nível da raiz. Use a concatenação de listas para simular o comportamento de uma fila.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 14</strong>.  <em>Escreva a função <em><code>leaves :: BSTree k v -&gt; Int</code></em>, que retorna o número de folhas da árvore binária de busca dada como entrada.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 15</strong>.  <em>Escreva as funções <em><code>inOrder</code></em>, <em><code>preOrder</code></em> e <em><code>postOrder</code></em>, todas com assinatura <em><code>BSTree k v -&gt; [(k, v)]</code></em>, que retornam uma lista com os pares de chave e valor contidos na árvore de entrada. A ordem dos pares nas listas é dada de acordo com o passeio sugerido pelo nome da função.</em></p>
</div>
<h2 id="representando-sequências-de-forma-eficiente">Representando sequências de forma eficiente</h2>
<p>Como sabemos, listas são a estrutura de dados padrão para se trabalhar em Haskell e cumprem o papel de representar sequências de elementos. Sua definição simples, no entanto, não nos permite operar com tais sequências de forma eficiente. Se quisermos acessar o <code>k</code>-ésimo elemento de uma lista, precisamos fazer um número de operações proporcional a <code>k</code>. Isso fica evidente na definição do operador <code>(!!) :: [a] -&gt; Int -&gt; a</code>, que se encontra em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb65" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>[] <span class="op">!!</span> _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;(!!): empty list&quot;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>_) <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> x</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>(_<span class="op">:</span>xs) <span class="op">!!</span> k <span class="ot">=</span> xs <span class="op">!!</span> (k <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 16</strong>.  <em>Implemente <em><code>(!?) :: [a] -&gt; Int -&gt; Maybe a</code></em>, que deve ser uma versão segura de <em><code>(!!)</code></em>.</em></p>
</div>
<p>Sempre que é necessário acessar elementos de uma sequência em ordem arbitrária, o tempo linear de acesso torna as listas representações indesejáveis. Assim, devemos propor uma representação que permita um acesso mais eficiente. Embora não possamos garantir acesso em tempo constante, como nas linguagens imperativas, podemos garantir acesso em tempo logarítmico.</p>
<p>Uma ideia seria usar uma <code>BSTree</code> onde as chaves representam as posições da sequência. No entanto, o nosso tipo <code>BSTree</code> não garante um balanceamento em sua definição. Pior ainda, se inserirmos a sequência em ordem crescente (ou decrescente) de posições, teremos uma representação linear da sequência (tal como é a lista, mas gastando ainda mais memória). Devemos lembrar que uma árvore binária de busca sem operações de balanceamento é razoavelmente eficiente apenas quando sua construção se dá de maneira arbitrária.</p>
<p>No entanto, como temos uma ideia clara do que queremos representar de forma arbórea, é perfeitamente possível que consigamos garantir um balanceamento baseado na ordem em que as chaves são inseridas. Por exemplo, podemos admitir a inserção das chaves apenas em ordem crescente e conceber uma representação em árvore que seja naturalmente balanceada.</p>
<p>Vamos definir nossa estrutura de dados no arquivo <code>SeqTree.hs</code>, que terá o seguinte conteúdo inicial.</p>
<div class="sourceCode" id="cb66" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SeqTree</span> <span class="kw">where</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (+), (-), (^),</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Ord</span>, (<span class="op">&lt;</span>), (<span class="op">&lt;=</span>), <span class="fu">max</span>)</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SeqTree</span> a <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Leaf</span> a</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Branch</span> <span class="dt">Int</span> <span class="dt">Int</span> (<span class="dt">SeqTree</span> a) (<span class="dt">SeqTree</span> a)</span></code></pre></div>
<p>A primeira coisa notável em nossa definição é que não usamos um tipo para representar nossas chaves, uma vez que sequências são todas indexadas por inteiros. Outra observação está no fato de que apenas as folhas contém elementos do tipo <code>a</code>, enquanto os nós internos da árvore contém dois valores inteiros. Isso quer dizer que o conteúdo de todas as posições de nossa sequência estará armazenado em folhas, e os nós internos terão informações para garantir o balanceamento da árvore.</p>
<p>De fato, é preciso explicar o que representam os valores inteiros em <code>Branch</code>. O primeiro valor representa a altura do nó, e nos auxilia a determinar quantos elementos cabem em sua sub-árvore. Se um nó tem altura <code>h</code>, e <code>SeqTree a</code> representa uma árvore binária, então sua sub-árvore pode ter no máximo <span class="math inline">\(2^h\)</span> folhas, e portanto pode conter no máximo <span class="math inline">\(2^h\)</span> elementos do tipo <code>a</code>. Já o segundo valor determina a quantidade de folhas que a sub-árvore daquele nó contém. Dessa forma, podemos determinar se uma sub-árvore está cheia comparando esses dois valores, o que vai permitir que nossa operação de inserção garanta algum balanceamento para a árvore.</p>
<p>Antes de prosseguir, vamos definir alguns <em>getters</em> para <code>SeqTree</code>, que serão bastante úteis para estabelecer algumas conveções.</p>
<div class="sourceCode" id="cb67" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">height ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>height <span class="dt">Empty</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>height (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>height (<span class="dt">Branch</span> h l ltree rtree) <span class="ot">=</span> h</span></code></pre></div>
<p>Usamos <code>height</code> para convencionar que a altura de árvores vazias e de árvores com um único nó é 0. À primeira vista parece estranho que folhas não tenham altura 1, mas perceba: se permitirnos que folhas tenham altura 1, estaremos admitindo que elas comportam <span class="math inline">\(2^1 = 2\)</span> elementos, o que não faz sentido. Por fim, o terceiro caso estabelece o primeiro valor inteiro de <code>Branch</code> como sua altura.</p>
<div class="sourceCode" id="cb68" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leaves ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>leaves <span class="dt">Empty</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>leaves (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>leaves (<span class="dt">Branch</span> h l ltree rtree) <span class="ot">=</span> l</span></code></pre></div>
<p>A função <code>leaves</code> retorna o número de folhas de uma <code>SeqTree</code>. <code>Empty</code> não tem folhas e <code>Leaf</code> tem exatamente uma folha. O terceiro caso estabelece que o segundo valor inteiro de <code>Branch</code> representa seu número de folhas.</p>
<p>Para construir valores de <code>SeqTree</code>, podemos usar seus três construtores (<code>Empty</code>, <code>Leaf</code> e <code>Branch</code>). Vamos, no entanto, evitar o uso do construtor <code>Branch</code> e preferir o uso da função <code>makeBranch</code>, com a finalidade de encapsular alguns cálculos.</p>
<div class="sourceCode" id="cb69" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">makeBranch ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>makeBranch tx ty <span class="ot">=</span> <span class="dt">Branch</span> h&#39; l&#39; tx ty <span class="kw">where</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    h&#39; <span class="ot">=</span> <span class="fu">max</span> (height tx) (height ty) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    l&#39; <span class="ot">=</span> leaves tx <span class="op">+</span> leaves ty</span></code></pre></div>
<p>Utilizar <code>makeBranch</code> é mais simples que utilizar <code>Branch</code>, pois altura e número de folhas já estão determinados. A altura da árvore criada é a altura da maior de suas sub-árvores, mais um. Já o número de folhas da árvore é a soma do número de folhas de suas sub-árvores.</p>
<p>Vamos criar agora <em>getters</em> para tomar as sub-árvores de uma <code>SeqTree</code>. Suas definições não exigem muitas explicações, mas observamos que há a convenção de que árvores vazias ou com apenas um nó têm ambas as suas sub-árvores vazias.</p>
<div class="sourceCode" id="cb70" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftTree ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>leftTree <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>leftTree (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>leftTree (<span class="dt">Branch</span> h l ltree rtree) <span class="ot">=</span> ltree</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="ot">rightTree ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>rightTree <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>rightTree (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>rightTree (<span class="dt">Branch</span> h l ltree rtree) <span class="ot">=</span> rtree</span></code></pre></div>
<p>Agora precisamos definir a inserção de forma a garantir um balanceamento para <code>SeqTree</code>. Vamos fazer isso permitindo a inserção de elementos apenas após o último elemento da sequência representada por uma <code>SeqTree</code>.</p>
<p>Antes de definirmos a operação de inserção em uma <code>SeqTree</code>, faz-se necessário criar um tipo para representar a comparação de um elemento de um tipo ordenável em relação a dois outros elementos do mesmo tipo.</p>
<div class="sourceCode" id="cb71" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ordering</span> <span class="ot">=</span> <span class="dt">LL</span> <span class="op">|</span> <span class="dt">LG</span> <span class="op">|</span> <span class="dt">GL</span> <span class="op">|</span> <span class="dt">GG</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="fu">compare</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="fu">compare</span> x p q <span class="ot">=</span> cond (x <span class="op">&lt;</span> p)</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>                     (cond (x <span class="op">&lt;</span> q) <span class="dt">LL</span> <span class="dt">LG</span>)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>                     (cond (x <span class="op">&lt;</span> q) <span class="dt">GL</span> <span class="dt">GG</span>)</span></code></pre></div>
<p>Basicamente, criamos esse <code>Ordering</code> personalizado e sua função <code>compare</code> com o objetivo estético de expressar essa lógica de comparação fora de <code>insert</code>. A função <code>insert</code> é definida a seguir.</p>
<div class="sourceCode" id="cb72" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>insert <span class="dt">Empty</span> x <span class="ot">=</span> <span class="dt">Leaf</span> x</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>insert ltree<span class="op">@</span>(<span class="dt">Leaf</span> _) x <span class="ot">=</span> makeBranch ltree (<span class="dt">Leaf</span> x)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>insert branch x <span class="ot">=</span> decide (<span class="fu">compare</span> (leaves branch) halfCapacity capacity) <span class="kw">where</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    decide <span class="dt">LL</span> <span class="ot">=</span> makeBranch lbranch&#39; rbranch</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    decide <span class="dt">GL</span> <span class="ot">=</span> makeBranch lbranch rbranch&#39;</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    decide <span class="dt">GG</span> <span class="ot">=</span> makeBranch branch (<span class="dt">Leaf</span> x)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    lbranch <span class="ot">=</span> leftTree branch</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    rbranch <span class="ot">=</span> rightTree branch</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    lbranch&#39; <span class="ot">=</span> insert lbranch x</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    rbranch&#39; <span class="ot">=</span> insert rbranch x</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    halfCapacity <span class="ot">=</span> <span class="dv">2</span><span class="op">^</span>(height branch <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    capacity <span class="ot">=</span> <span class="dv">2</span><span class="op">^</span>(height branch)</span></code></pre></div>
<p>Os dois primeiros casos de <code>insert</code> lidam com <code>Empty</code> e <code>Leaf</code>: inserir um elemento em uma árvore vazia resulta em uma única folha; inserir um elemento em uma folha resulta em uma árvore de altura 1 com duas folhas. Em seu último caso, <code>insert</code> tem de se preocupar com o número de folhas de <code>branch</code>: se <code>branch</code> tem menos folhas que o máximo de folhas que pode haver em <code>lbranch</code> (<code>halfCapacity</code>), então a inserção é feita em <code>lbranch</code>; caso <code>branch</code> não esteja com seu número máximo de folhas, a inserção é feita em <code>rbranch</code>; caso <code>branch</code> tenha atingido seu número máximo de folhas, <code>branch</code> torna-se a sub-árvore esquerda de uma nova <code>SeqTree</code>, cuja sub-árvore direita consiste de uma folha.</p>
<p>Agora, definimos a função <code>lookup</code>, cujo objetivo é retornar o valor associado a uma posição da sequência. Note que consideramos nossas sequências indexadas a partir de 1, e não de 0.</p>
<div class="sourceCode" id="cb73" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (<span class="dt">Leaf</span> x) <span class="dv">1</span> <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (<span class="dt">Leaf</span> _) _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> branch n <span class="ot">=</span> cond  (n <span class="op">&lt;=</span> halfCapacity)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>                        (<span class="fu">lookup</span> lbranch n)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>                        (<span class="fu">lookup</span> rbranch n&#39;) <span class="kw">where</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    halfCapacity <span class="ot">=</span> <span class="dv">2</span><span class="op">^</span>(height branch <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    lbranch <span class="ot">=</span> leftTree branch</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    rbranch <span class="ot">=</span> rightTree branch</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    n&#39; <span class="ot">=</span> n <span class="op">-</span> halfCapacity</span></code></pre></div>
<p>Primeiro, temos os três casos elementares. No último caso, <code>lookup</code> verifica se o índice da posição buscada (<code>n</code>) é limitado pelo número máximo de folhas que uma sub-árvore de <code>branch</code> pode ter. Caso seja, e como <code>insert</code> garante que <code>branch</code> tem elementos em <code>rbranch</code> apenas se <code>lbranch</code> estiver cheia, então a busca pelo valor da posição <code>n</code> continua em <code>lbranch</code>. Do contrário, o valor associado a <code>n</code> não pode estar em uma das folhas de <code>lbranch</code>, e a busca deve continuar em <code>rbranch</code>, mas com uma modificação: <code>rbranch</code> representa uma subsequência que começa após os <code>halfCapacity</code> primeiros elementos da sequência representada por <code>branch</code>; dessa forma, o <code>n</code>-ésimo elemento da sequência de <code>branch</code> deverá estar na posição <code>n - halfCapacity</code> da subsequência de <code>rbranch</code>.</p>
<div class="sourceCode" id="cb74" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">update ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>update <span class="dt">Empty</span> _ _ <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>update (<span class="dt">Leaf</span> x) <span class="dv">1</span> f <span class="ot">=</span> <span class="dt">Leaf</span> (f x)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>update leaf<span class="op">@</span>(<span class="dt">Leaf</span> _) _ _ <span class="ot">=</span> leaf</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>update branch n f <span class="ot">=</span> cond (n <span class="op">&lt;=</span> halfCapacity)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>                         (makeBranch lbranch&#39; rbranch)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>                         (makeBranch lbranch rbranch&#39;) <span class="kw">where</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>    halfCapacity <span class="ot">=</span> <span class="dv">2</span><span class="op">^</span>(height branch <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>    lbranch <span class="ot">=</span> leftTree branch</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    rbranch <span class="ot">=</span> rightTree branch</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    lbranch&#39; <span class="ot">=</span> update lbranch n f</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    rbranch&#39; <span class="ot">=</span> update rbranch n&#39; f</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    n&#39; <span class="ot">=</span> n <span class="op">-</span> halfCapacity</span></code></pre></div>
<p>Acima, temos a função <code>update</code>, que atualiza o conteúdo de uma posição da sequência. A decisão sobre qual sub-árvore irá sofrer a atualização é a mesma de <code>lookup</code>. No entanto, em vez de retornar o elemento da posição <code>n</code>, <code>update</code> reconstrói as sub-árvores necessárias para que <code>f x</code> torne-se o valor da posição <code>n</code> da sequência representada por <code>branch</code>.</p>
<div class="sourceCode" id="cb75" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">remove ::</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>remove <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>remove (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>remove (<span class="dt">Branch</span> _ _ ltree <span class="dt">Empty</span>) <span class="ot">=</span> remove ltree</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>remove (<span class="dt">Branch</span> _ _ ltree rtree) <span class="ot">=</span> makeBranch ltree (remove rtree)</span></code></pre></div>
<p>Temos agora nossa função <code>remove</code>, que sempre remove o último elemento da sequência. Perceba que <code>remove</code> apenas deleta a folha que estiver mais à direita, o que a torna bem simples. Além disso, perceba que o terceiro caso de <code>remove</code> é responsável por reduzir a estrutura de uma <code>SeqTree</code>, eliminando sub-árvores vazias.</p>
<p>Aproveitamos também para definir como transformar uma sequência de elementos. A função <code>map</code> explora a estrutura de <code>SeqTree</code>, alterando o conteúdo de suas folhas.</p>
<div class="sourceCode" id="cb76" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> a <span class="ot">-&gt;</span> <span class="dt">SeqTree</span> b</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="dt">Leaf</span> x) <span class="ot">=</span> <span class="dt">Leaf</span> (f x)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="dt">Branch</span> _ _ ltree rtree) <span class="ot">=</span> makeBranch ltree&#39; rtree&#39; <span class="kw">where</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    ltree&#39; <span class="ot">=</span> <span class="fu">map</span> f ltree</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    rtree&#39; <span class="ot">=</span> <span class="fu">map</span> f rtree</span></code></pre></div>
<p>Antes de preparar a lista de exportação de nosso módulo, fornecemos uma maneira de criar uma <code>SeqTree</code> vazia.</p>
<div class="sourceCode" id="cb77" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">SeqTree</span> a</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Empty</span></span></code></pre></div>
<p>Por fim, definimos nossa lista de exportação, alterando o começo de <code>SeqTree.hs</code> da seguinte forma.</p>
<div class="sourceCode" id="cb78" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SeqTree</span> (<span class="dt">SeqTree</span>, empty, insert, update, <span class="fu">lookup</span>, remove, <span class="fu">map</span>) <span class="kw">where</span></span></code></pre></div>
<p>Assim, temos concluído as definições necessárias para <code>SeqTree</code>. Futuramente, utilizaremos essa estrutura para resolver alguns problemas.</p>
<h2 id="subsec:compiling">Compilando um programa</h2>
<p>Até o presente momento, escrevemos alguns módulos com definições úteis e os testamos utilizando um interpretador, o <code>ghci</code>. Nesta breve subseção, mostramos quais os passos necessários para se compilar um programa em Haskell.</p>
<p>Dado um arquivo <code>Module.hs</code>, utilizamos o seguinte comando para compilá-lo.</p>
<div class="sourceCode" id="cb79" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>ghc <span class="dt">Module</span> <span class="op">-</span><span class="dt">W</span></span></code></pre></div>
<p>Esse comando compila <code>Module.hs</code>, produzindo um tipo de saída conforme seu conteúdo. Aqui, <code>-W</code> habilita os <em>warnings</em> do <code>ghc</code> que, em suas últimas versões, tornaram-se opcionais. Certamente, é sempre bom usar <code>-W</code>.</p>
<p>Se <code>Module.hs</code> tem em sua primeira linha algo como <code>module Module where</code>, então o comando acima produz um arquivo <code>Module.o</code>. Como exemplo, temos a compilação de <code>List.hs</code>.</p>
<div class="sourceCode" id="cb80" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="dt">List</span> <span class="op">-</span><span class="dt">W</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">4</span>] <span class="dt">Compiling</span> <span class="dt">Bool</span>             ( <span class="dt">Bool</span><span class="op">.</span>hs, <span class="dt">Bool</span><span class="op">.</span>o )</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span> <span class="kw">of</span> <span class="dv">4</span>] <span class="dt">Compiling</span> <span class="dt">Functions</span>        ( Functions.hs, Functions.o )</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span> <span class="kw">of</span> <span class="dv">4</span>] <span class="dt">Compiling</span> <span class="dt">Maybe</span>            ( <span class="dt">Maybe</span><span class="op">.</span>hs, <span class="dt">Maybe</span><span class="op">.</span>o )</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span> <span class="kw">of</span> <span class="dv">4</span>] <span class="dt">Compiling</span> <span class="dt">List</span>             ( List.hs, List.o )</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="op">$</span></span></code></pre></div>
<p>Podemos perceber que, como <code>List</code> importa outros módulos, esses foram recursivamente compilados. Assim, a rotina de compilação do <code>ghc</code> usualmente dispensa o uso de ferramentas como <code>make</code>. Note ainda que nenhum executável foi criado, mas apenas arquivos objeto.</p>
<p>Se <code>Module.hs</code> tem <code>module Main where</code> como sua primeira linha, então o <code>ghc</code> espera que haja uma função <code>main :: IO ()</code> definida em <code>Module.hs</code> (<code>IO</code> será explicada futuramente). Caso haja, <code>ghc</code> gera um executável <code>Module</code>. Como exemplo, vamos criar um arquivo <code>Hello.hs</code> com o seguinte conteúdo.</p>
<div class="sourceCode" id="cb81" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">IO</span>, putStrLn, getLine, (&gt;&gt;=))</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">reverse</span></span></code></pre></div>
<p>Há muitas coisas novas sendo usadas em <code>Hello.hs</code>. Basicamente, <code>IO</code> representa um valor que surge de operações de entrada e saída. Essa é a forma de Haskell separar funções com retorno <em>impuro</em> de funções com retorno simples. O valor <code>getLine :: IO [Char]</code> retorna uma string, obtida a partir do teclado, dentro de <code>IO</code>. Como o valor <code>getLine</code> pode mudar, a depender do que se digita no teclado, ele não é considerada puro. A função <code>putStrLn :: String -&gt; IO ()</code> recebe uma string e a imprime na tela, retornando uma tupla vazia dentro de <code>IO</code>. Como isso envolve uma operação de entrada e saída, o retorno de <code>putStrLn</code> é representado por <code>IO</code>. Por fim, o operador <code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code> pode ser visto como uma composição de funções mais sofisticada (entraremos em detalhes sobre ele futuramente).</p>
<p>Agora, compilamos <code>Hello.hs</code>.</p>
<div class="sourceCode" id="cb82" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="dt">Hello</span> <span class="op">-</span><span class="dt">W</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">5</span>] <span class="dt">Compiling</span> <span class="dt">Bool</span>             ( <span class="dt">Bool</span><span class="op">.</span>hs, <span class="dt">Bool</span><span class="op">.</span>o )</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span> <span class="kw">of</span> <span class="dv">5</span>] <span class="dt">Compiling</span> <span class="dt">Functions</span>        ( Functions.hs, Functions.o )</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span> <span class="kw">of</span> <span class="dv">5</span>] <span class="dt">Compiling</span> <span class="dt">Maybe</span>            ( <span class="dt">Maybe</span><span class="op">.</span>hs, <span class="dt">Maybe</span><span class="op">.</span>o )</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span> <span class="kw">of</span> <span class="dv">5</span>] <span class="dt">Compiling</span> <span class="dt">List</span>             ( List.hs, List.o )</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span> <span class="kw">of</span> <span class="dv">5</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( Hello.hs, Hello.o )</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Linking</span> <span class="dt">Hello</span> <span class="op">...</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="op">$</span></span></code></pre></div>
<p>Observe que, dessa vez, o processo de compilação se estende até a fase de <em>linking</em>. Mais uma vez, <code>ghc</code> compila os módulos necessários recursivamente. Podemos testar o que o executável <code>Hello</code> faz.</p>
<div class="sourceCode" id="cb83" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="op">./</span><span class="dt">Hello</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Hello</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>olleH</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="op">$</span></span></code></pre></div>
<p>Isso deve ser suficiente para que possamos compilar programas, em um primeiro momento.</p>
<h2 id="implementando-um-grafo">Implementando um grafo</h2>
<p>Aqui, desenvolvemos em <code>Graph.hs</code> algumas definições para lidar com grafos. Nosso objetivo é ilustrar o uso de <code>SeqTree</code>. Um grafo <span class="math inline">\(G = (V, E)\)</span> tem um conjunto de vértices <span class="math inline">\(V\)</span> e um conjunto de arestas <span class="math inline">\(E\)</span>, sendo que uma aresta relaciona dois vértices. Seu conteúdo inicial se encontra a seguir.</p>
<div class="sourceCode" id="cb84" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Graph</span> <span class="kw">where</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (+), (-), <span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>),</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>                (<span class="op">==</span>), (<span class="op">&lt;=</span>))</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">SeqTree</span> <span class="kw">as</span> <span class="dt">Seq</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Vertex</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Graph</span> <span class="ot">=</span> <span class="dt">G</span> <span class="dt">Int</span> (<span class="dt">Seq.SeqTree</span> [<span class="dt">Vertex</span>])</span></code></pre></div>
<p>Usamos valores inteiros para representar nossos vértices, e deixamos isso expresso de forma clara com o uso de <code>type</code>, que apenas cria sinônimos para tipos já existentes. Dessa forma, um grafo com <span class="math inline">\(n\)</span> vértices tem seus vértices numerados de 1 a <span class="math inline">\(n\)</span>. Nosso tipo <code>Graph</code> tem dois campos: um inteiro, indicando seu número de vértices; uma <code>SeqTree [Vertex]</code>, que associa a cada vértice <span class="math inline">\(v\)</span> uma lista com os outros vértices das arestas relacionadas a <span class="math inline">\(v\)</span>. Vamos desenvolver uma função para criar um grafo com nenhum vértice.</p>
<div class="sourceCode" id="cb85" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">Graph</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">G</span> <span class="dv">0</span> Seq.empty</span></code></pre></div>
<p>A função <code>empty</code> é bem simples. Ela apenas cria um grafo com 0 vértices e, portanto, com uma <code>SeqTree</code> vazia. A seguir, criamos um modo de adicionar um vértice ao grafo.</p>
<div class="sourceCode" id="cb86" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addVertex ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>addVertex (<span class="dt">G</span> n adj) <span class="ot">=</span> <span class="dt">G</span> (n <span class="op">+</span> <span class="dv">1</span>) (Seq.insert adj [])</span></code></pre></div>
<p>Ao adicionar um vértice, <code>addVertex</code> precisa atualizar o número de vértices do grafo. Além disso, o vértice recém-criado faz parte de nenhuma aresta, portanto inserimos <code>[]</code> em <code>adj</code>. Aproveitamos <code>addVertex</code> para criar uma função que retorna grafos sem arestas.</p>
<div class="sourceCode" id="cb87" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="ot">edgeless ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>edgeless n <span class="ot">=</span> cond (n <span class="op">&lt;=</span> <span class="dv">0</span>) empty (addVertex g) <span class="kw">where</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    g <span class="ot">=</span> edgeless (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>A função a seguir verifica se um grafo tem um certo vértice.</p>
<div class="sourceCode" id="cb88" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hasVertex ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>hasVertex (<span class="dt">G</span> n _) v <span class="ot">=</span> <span class="fu">and</span> [<span class="dv">1</span> <span class="op">&lt;=</span> v, v <span class="op">&lt;=</span> n]</span></code></pre></div>
<p>Como consideramos que um grafo tem seus <code>n</code> vértices numerados entre 1 e <code>n</code>, <code>hasVertex</code> verifica justamente isso. Vale notar também que, se um grafo tem nenhum (zero) vértices, então <code>hasVertex</code> retorna <code>False</code> para qualquer vértice recebido como entrada.</p>
<p>Definimos a função <code>vertices</code>, que retorna uma lista com os vértices do grafo, por uma questão de conveniência. Fazemos uso de <code>iterate</code>, proposta no Exercício <a href="#exercicio:iterate" data-reference-type="ref" data-reference="exercicio:iterate">Exercício 10</a>.</p>
<div class="sourceCode" id="cb89" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vertices ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>vertices (<span class="dt">G</span> n _) <span class="ot">=</span> <span class="fu">take</span> n (<span class="fu">iterate</span> (<span class="op">+</span><span class="dv">1</span>) <span class="dv">1</span>)</span></code></pre></div>
<p>Agora vamos definir a adição de uma aresta.</p>
<div class="sourceCode" id="cb90" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addEdge ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>addEdge g<span class="op">@</span>(<span class="dt">G</span> n adj) u v <span class="ot">=</span> cond verticesExist g&#39; g <span class="kw">where</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    verticesExist <span class="ot">=</span> <span class="fu">and</span> [g <span class="ot">`hasVertex`</span> u, g <span class="ot">`hasVertex`</span> v]</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    g&#39; <span class="ot">=</span> <span class="dt">G</span> n adj&#39;</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    adj&#39; <span class="ot">=</span> Seq.update adj u (v<span class="op">:</span>)</span></code></pre></div>
<p>Primeiro, <code>addEdge</code> verifica se o grafo <code>g</code> tem os vértices <code>u</code> e <code>v</code>. Aqui, notamos mais uma novidade sintática: funções “binárias” podem ser usadas como operadores infixos, isto é, entre seusa argumentos. Para isso, o nome da função deve estar entre crases (no código acima, o nome da função aparece entre aspas simples porque o LaTeX  interpreta crases soltas como aspas simples (mas olha só, ele tem um comando para imprimir seu próprio nome de um jeito bem bizarro)). Caso <code>u</code> e <code>v</code> sejam vértices de <code>g</code>, a lista de <code>u</code> é atualizada de forma que <code>v</code> seja vizinho de <code>u</code>. Isso indica que há uma aresta de <code>u</code> para <code>v</code>, já que <code>v</code> aparece na lista de <code>u</code>. Com isso, estamos implementando um grafo onde as arestas têm direção, isto é, estamos implementando um grafo direcionado.</p>
<p>Os vizinhos de um vértice <code>v</code> são os vértices que aparecem em sua lista. Note que, a partir de <code>v</code>, podemos ir para qualquer vértice de sua lista, enquanto que o contrário nem sempre é verdade. A função <code>neighbors</code> retorna os vizinhos de um vértice em um grafo, aproveitando o fato de que <code>adj</code>, de acordo com a definição anterior, armazena justamente os vizinhos de cada vértice.</p>
<div class="sourceCode" id="cb91" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbors ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>neighbors (<span class="dt">G</span> _ adj) v <span class="ot">=</span> fromMaybe [] (Seq.lookup adj v)</span></code></pre></div>
<p>Na definição acima, note o uso de <code>fromMaybe</code> para tratar o caso de <code>v</code> não ser um vértice do grafo. Nesse caso, convencionamos que se um vértice não pertence ao grafo, ele não tem vizinhos. Para verificar se é possível ir de um vértice <code>u</code> para um certo vértice <code>v</code>, é preciso verificar se <code>v</code> é vizinho de <code>u</code>.</p>
<div class="sourceCode" id="cb92" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hasEdge ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>hasEdge g u v <span class="ot">=</span> f (neighbors g u) <span class="kw">where</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">=</span> isJust <span class="op">.</span> find (<span class="op">==</span>v)</span></code></pre></div>
<p>Na definição acima, tomamos os vizinhos do vértice <code>u</code>. Em seguida, verificamos se <code>v</code> se encontra dentre os vizinhos de <code>u</code>. A função <code>isJust</code>, por fim, retorna o valor booleano apropriado. Perceba que, pela definição de <code>addEdge</code>, <code>hasEdge g u v == hasEdge g v u</code> nem sempre é <code>True</code>. Fizemos uso de <code>find</code>, proposta na Subseção <a href="#lab2" data-reference-type="ref" data-reference="lab2">4.2</a>.</p>
<p>Essas operações são suficientes para a construção de grafos. Sobre elas, seria possível definir algumas operações mais sofisticadas.</p>
<p>É preciso observar, ainda, que como <code>SeqTree</code> é limitada em sua remoção, nossa implementação de grafo não pode ter uma remoção elementar de vértices. Perceba também que, como cada vértice tem seus vizinhos representados como uma lista, a remoção de uma aresta não seria eficiente. O mais adequado seria representar os vizinhos de um vértice como uma árvore binária de busca balanceada, mas não temos implementado tal estrutura.</p>
<p>Após a constatação de que <code>Graph</code> não pode ter operações de remoção viáveis, fechamos nosso módulo com a seguinte alteração em seu início.</p>
<div class="sourceCode" id="cb93" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Graph</span> (<span class="dt">Graph</span>, empty, edgeless,</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>              addVertex, hasVertex, vertices,</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>              addEdge, neighbors, hasEdge) <span class="kw">where</span></span></code></pre></div>
<p>Isso conclui as operações básicas em <code>Graph.hs</code>.</p>
<h2 id="filas-de-prioridade">Filas de prioridade</h2>
<p>Vamos desenvolver em <code>Heap.hs</code> as definições necessárias para a manipulação de filas de prioridade. Vamos desenvolver uma fila de prioridade mínima.</p>
<p>O conteúdo inicial de <code>Heap.hs</code> é dado a seguir.</p>
<div class="sourceCode" id="cb94" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Heap</span> <span class="kw">where</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Ord</span>, (&lt;=))</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Heap</span> k v <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">Heap</span> (k, v) [<span class="dt">Heap</span> k v]</span></code></pre></div>
<p>Nosso tipo <code>Heap k v</code> representa uma <em>pairing heap</em>. <code>Heap k v</code> associa a cada valor de tipo <code>v</code> uma chave de tipo <code>k</code>, que é tratada como sua prioridade. Em sua definição, temos dois casos: <code>Heap</code> pode ser vazia, representada por <code>Empty</code>; pode ter um par de chave e valor em sua raiz, bem como uma lista de <em>heaps</em>. Assim, <code>Heap</code> pode ser vista como uma árvore (não necessariamente binária, já que uma lista pode ter qualquer número de elementos).</p>
<p>A ideia de manter uma lista de <em>heaps</em> permite que a execução de certas operações seja postergada o máximo possível. Com isso, o custo de execução de uma sequência de (digamos <span class="math inline">\(n\)</span>) operações pode ser desbalanceado: por exemplo, as <span class="math inline">\(n - 1\)</span> primeiras operações podem ser postergadas, enquanto a <span class="math inline">\(n\)</span>-ésima precisa realizar o trabalho de todas as <span class="math inline">\(n\)</span> operações. Em cenários como esse, é preciso considerar o <em>custo amortizado</em> de cada operação, isto é, considerar a média dos custos de todas as operações. Logo teremos ilustrações disso.</p>
<p>A função <code>lookup</code> retorna o elemento da raiz de <code>Heap</code>, que deve ser seu elemento prioritário. Sua definição não exige esclarecimentos e se encontra a seguir.</p>
<div class="sourceCode" id="cb95" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (k, v)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (<span class="dt">Heap</span> keyval _) <span class="ot">=</span> <span class="dt">Just</span> keyval</span></code></pre></div>
<p>Agora, definimos <code>merge</code>, que combina os elementos de duas filas de prioridade.</p>
<div class="sourceCode" id="cb96" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="ot">merge ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>merge <span class="dt">Empty</span> h2 <span class="ot">=</span> h2</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>merge h1 <span class="dt">Empty</span> <span class="ot">=</span> h1</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>merge h1<span class="op">@</span>(<span class="dt">Heap</span> x<span class="op">@</span>(key1, _) hs1) h2<span class="op">@</span>(<span class="dt">Heap</span> y<span class="op">@</span>(key2, _) hs2) <span class="ot">=</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    cond (key1 <span class="op">&lt;=</span> key2) h1&#39; h2&#39; <span class="kw">where</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        h1&#39; <span class="ot">=</span> <span class="dt">Heap</span> x (h2<span class="op">:</span>hs1)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>        h2&#39; <span class="ot">=</span> <span class="dt">Heap</span> y (h1<span class="op">:</span>hs2)</span></code></pre></div>
<p>Perceba que <code>merge</code> é muito peculiar. Independente do tamanho das filas de prioridade que <code>merge</code> recebe, ela executa em tempo constante! Ela sequer é recursiva. O que <code>merge</code> faz é muito simples: dadas duas filas de prioridade, a fila com o elemento mais prioritário passa a conter a outra. Observe ainda que “colocar” uma fila dentro da outra consiste apenas em adicionar uma fila à lista de filas da outra (essas ficam “esperando” que seus elementos sejam processados).</p>
<p>Agora que temos definido <code>merge</code>, podemos definir <code>insert</code> como a combinação de duas <em>heaps</em>. A função <code>insert</code> é descrita abaixo e faz exatamente isso.</p>
<div class="sourceCode" id="cb97" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>insert h keyval <span class="ot">=</span> merge (<span class="dt">Heap</span> keyval []) h</span></code></pre></div>
<p>Para implementar a remoção, precisamos criar uma função que faça todo o trabalho que <code>merge</code> decidiu “procrastinar”. A função <code>mergeAll</code> cumpre esse papel, e faz uso de <code>merge</code> para isso.</p>
<div class="sourceCode" id="cb98" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeAll ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> [<span class="dt">Heap</span> k v] <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>mergeAll [] <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>mergeAll [h] <span class="ot">=</span> h</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>mergeAll (h1<span class="op">:</span>h2<span class="op">:</span>hs) <span class="ot">=</span> merge (merge h1 h2) (mergeAll hs)</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 17</strong>.  <em>A função <em><code>mergeAll</code></em> poderia ser definida como <em><code>mergeAll = foldl merge Empty</code></em>. Existe alguma desvantagem em definí-la dessa forma mais sucinta? Pense nas estruturas que as duas definições produzem.</em></p>
</div>
<p>Aqui, <code>mergeAll</code> cria uma estrutura arbórea, combinando diversas <em>heaps</em> em uma só. Podemos ver sua definição em dois tempos: primeiro, ela define a combinação das <em>heaps</em> duas a duas, da esquerda para a direita; depois, ela faz a combinação cumulativa desses pares, combinando a <em>heap</em> mais à direita com as demais <em>heaps</em>, uma de cada vez e da direita para a esquerda.</p>
<p>Agora estamos aptos a definir a remoção do elemento mais prioritário. A função <code>pop</code> apenas remove a raiz da <em>heap</em>, em seguida combinando sua lista de <em>heaps</em> em uma só, que é retornada pela função. Sua definição elementar é dada abaixo.</p>
<div class="sourceCode" id="cb99" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>pop <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>pop (<span class="dt">Heap</span> _ hs) <span class="ot">=</span> mergeAll hs</span></code></pre></div>
<p>Podemos entender agora que existe um motivo para a definição de <code>mergeAll</code>. Em uma operação de remoção, o fato de <code>mergeAll</code> combinar as <em>heaps</em> aos pares faz com que o número de <em>heaps</em> a serem combinadas em uma remoção futura seja em torno da metade do número de <em>heaps</em> combinadas nessa remoção.</p>
<p>Com isso, podemos analisar o seguinte cenário, que começa com uma <em>heap</em> vazia: após uma sequência de <span class="math inline">\(n\)</span> inserções de elementos (no pior caso, em ordem decrescente de prioridade), a primeira remoção custa <span class="math inline">\(O(n)\)</span> e, por conta do “segundo tempo” de <code>mergeAll</code>, as <span class="math inline">\(\lceil\frac{n}{2}\rceil\)</span> remoções seguintes custam <span class="math inline">\(O(1)\)</span>; graças ao “primeiro tempo” de <code>mergeAll</code>, a próxima remoção custa <span class="math inline">\(O(n)\)</span>, mas agora apenas as <span class="math inline">\(\lceil\frac{n}{4}\rceil\)</span> remoções seguintes custam <span class="math inline">\(O(1)\)</span>; assim, uma sequência de <span class="math inline">\(n\)</span> remoções tem <span class="math inline">\(O(\log n)\)</span> remoções custando <span class="math inline">\(O(n)\)</span>, enquanto as demais custam <span class="math inline">\(O(1)\)</span>, e portanto as <span class="math inline">\(n\)</span> remoções custam, juntas, <span class="math inline">\(O(n \log n)\)</span>; em média, cada uma das <span class="math inline">\(n\)</span> remoções custa <span class="math inline">\(O(\frac{n \log n}{n}) = O(\log n)\)</span>, e esse é o custo amortizado da remoção em nossa <code>Heap</code>.</p>
<p>Nossa última operação serve para alterar a chave do elemento mais prioritário de uma <em>heap</em>. Com isso, <code>Heap</code> permite remoções e alterações apenas no elemento mais prioritário. A definição de <code>changeKey</code> consiste em remover o elemento da raiz e reinserí-lo com uma nova chave.</p>
<div class="sourceCode" id="cb100" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="ot">changeKey ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Heap</span> k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Heap</span> k v</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>changeKey <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>changeKey h<span class="op">@</span>(<span class="dt">Heap</span> (_, val) _) key&#39; <span class="ot">=</span> insert (pop h) (key&#39;, val)</span></code></pre></div>
<p>Para permitir que o usuário crie uma fila de prioridades vazia, encapsulamos <code>Empty</code> como segue.</p>
<div class="sourceCode" id="cb101" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">Heap</span> k v</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Empty</span></span></code></pre></div>
<p>Para encerrar o módulo, definimos a lista de exportação de <code>Heap.hs</code>, alterando seu início.</p>
<div class="sourceCode" id="cb102" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Heap</span> (<span class="dt">Heap</span>, empty, <span class="fu">lookup</span>, insert, pop, changeKey) <span class="kw">where</span></span></code></pre></div>
<p>Isso deve ser o bastante para termos uma fila de prioridade bem definida.</p>
<div class="exercicio">
<p><strong>Exercício 18</strong>.  <em>Uma lista pode ser utilizada como uma pilha, dado que permite inserção e remoção em <span class="math inline">\(O(1)\)</span> na sua extremidade esquerda. Tome o tipo <em><code>Queue a</code></em>, definido como segue.</em></p>
<div class="sourceCode" id="cb103" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Queue</span>(<span class="dt">Queue</span>, empty, enqueue, dequeue) <span class="kw">where</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> ()</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Queue</span> a <span class="ot">=</span> <span class="dt">Q</span> [a] [a]</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">Queue</span> a</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Q</span> [] []</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="ot">enqueue ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> a</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>enqueue <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a><span class="ot">dequeue ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Queue</span> a)</span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>dequeue <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p><em>Implemente <em><code>enqueue</code></em> e <em><code>dequeue</code></em>, e argumente que <em><code>dequeue</code></em> tem custo amortizado <span class="math inline">\(O(1)\)</span>. Escreva sua implementação em <em><code>Queue.hs</code></em>.</em></p>
</div>
<h2 id="classes">Classes</h2>
<p>Nesta subseção, tratamos de descrever algumas classes importantes de Haskell. Lembramos que uma classe é apenas um conjunto de funções, e dizemos que um tipo é instância de uma classe quando implementa suas funções. Por força de analogia, o conceito de classe em Haskell muito se assemelha ao de interface em Java.</p>
<p>Começamos com uma classe bem simples, <code>Eq</code>. Essa classe já foi vista anteriormente, e contém comparadores relacionados com o conceito de igualdade. Usando <code>:info Eq</code> no <code>ghci</code>, obtemos uma saída parecida com essa.</p>
<div class="sourceCode" id="cb104" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">==</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">/=</span> y)</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">/=</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">==</span> y)</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL (==) | (/=) #-}</span></span></code></pre></div>
<p>A despeito do que vínhamos fazendo (reimplementando quase tudo), não estamos aptos a redefinir as classes padrão de Haskell. Isso se dá porque há tipos cuja definição é intrínseca ao compilador, e assim não podemos “abrir” esses tipos e torná-los instâncias de classes. Por exemplo, não seria muito prático tornar <code>Int</code> uma instância de <code>Eq</code> sem usar sua representação binária (e como tentamos nos manter fiéis ao paradgma, temos de abstrair a representação de <code>Int</code> (apesar disso, Haskell tem operações a nível de <em>bit</em>)).</p>
<p>Dito isso, não escreveremos as definições de classe aqui apresentadas em nenhum arquivo. Elas apenas servem para ilustrar as definições padrão das funções.</p>
<p>Voltando à classe <code>Eq</code>, percebemos que ambas as suas funções têm definições padrão. Nesse caso, basta implementar uma delas para que um tipo se torne instância de <code>Eq</code>. Isso é dito explicitamente no comentário logo abaixo da classe. Como exemplo, tornar as listas instâncias de <code>Eq</code> poderia ser feito como segue.</p>
<div class="sourceCode" id="cb105" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> [a] <span class="kw">where</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    [] <span class="op">==</span> [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    [] <span class="op">==</span> _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">==</span> [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    (x<span class="op">:</span>xs) <span class="op">==</span> (y<span class="op">:</span>ys) <span class="ot">=</span> <span class="fu">and</span> [x <span class="op">==</span> y, xs <span class="op">==</span> ys]</span></code></pre></div>
<p>Podemos ver que duas listas são comparáveis por igualdade apenas quando o tipo de seus elementos também é. Isso é dito explicitamente na restrição feita sobre <code>a</code>, na primeira linha.</p>
<p>Algo interessante de se notar é que, na definição acima, o comparador <code>(==)</code> é usado de duas formas distintas. No último caso, <code>x == y</code> faz menção à implementação de <code>(==)</code> que é definida em <code>Eq a</code>, enquanto <code>xs == ys</code> é referente à instância que está sendo definida (é uma chamada recursiva), já que <code>xs</code> e <code>ys</code> são listas.</p>
<div class="exercicio">
<p><strong>Exercício 19</strong>.  <em>Faça de <em><code>Maybe</code></em> uma instância de <em><code>Eq</code></em>.</em></p>
</div>
<p>A classe <code>Ord</code> contém os comparadores relacionados com o conceito de ordenação. Sua definição pode ser vista a seguir.</p>
<div class="sourceCode" id="cb106" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    compare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">compare</span> x y <span class="ot">=</span> cond (x <span class="op">&lt;=</span> y) (cond (x <span class="op">==</span> y) <span class="dt">EQ</span> <span class="dt">LT</span>) <span class="dt">GT</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;</span> y <span class="ot">=</span> (<span class="fu">compare</span> x y) <span class="op">==</span> <span class="dt">LT</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;=</span> y <span class="ot">=</span> (<span class="fu">compare</span> x y) <span class="op">/=</span> <span class="dt">GT</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    max ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    min ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL compare | (&lt;=) #-}</span></span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 20</strong>.  <em>Complete as definições padrão da classe <em><code>Ord</code></em>. Tente fazê-las em termos de <em><code>compare</code></em> ou <em><code>(&lt;=)</code></em>.</em></p>
</div>
<p>Como exemplo de uma de suas instâncias, mostramos como a lista pdoe ser descrita como uma instância de <code>Ord</code>.</p>
<div class="sourceCode" id="cb107" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> [a] <span class="kw">where</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    [] <span class="op">&lt;=</span> _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">&lt;=</span> [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    (x<span class="op">:</span>xs) <span class="op">&lt;=</span> (y<span class="op">:</span>ys) <span class="ot">=</span> cond (x <span class="op">==</span> y) (xs <span class="op">&lt;=</span> ys) (x <span class="op">&lt;</span> y)</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 21</strong>.  <em>Faça de <em><code>Maybe</code></em> uma instância de <em><code>Ord</code></em>.</em></p>
</div>
<p>Tratamos agora de duas classes, ambas relacionadas com a conversão de valores. A classe <code>Show</code> contém funções relacionadas com a conversão de tipos em strings. As instâncias de <code>Show</code>, portanto, podem todas ser representadas como strings. A classe <code>Read</code>, por sua vez, agrupa as funções relacionadas com a conversão de strings em valores de outros tipos. Assim, as instâncias de <code>Read</code> podem ter seus valores obtidos a partir de strings.</p>
<div class="sourceCode" id="cb108" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    showList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL showsPrec | show #-}</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Read</span> a <span class="kw">where</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    readsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ReadS</span> a</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    readList ::</span> <span class="dt">ReadS</span> [a]</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>    GHC.Read.readPrec<span class="ot"> ::</span> <span class="dt">Text.ParserCombinators.ReadPrec.ReadPrec</span> a</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    GHC.Read.readListPrec<span class="ot"> ::</span> <span class="dt">Text.ParserCombinators.ReadPrec.ReadPrec</span> [a]</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL readsPrec | readPrec #-}</span></span></code></pre></div>
<p>Enquanto podemos criar instâncias da classe <code>Show</code> de forma simples, o mesmo não pode ser dito de <code>Read</code>. Utilizamos as instâncias já existentes de <code>Read</code> para converter strings em valores dos tipos básicos de Haskell. Para isso, usamos <code>read :: Read a =&gt; String -&gt; a</code>, uma função que nem mesmo faz parte da classe <code>Read</code>. Exemplificamos a seguir o uso de <code>show</code> e <code>read</code>.</p>
<div class="sourceCode" id="cb109" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghci</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">show</span> <span class="dv">25</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;25&quot;</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">show</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[1,2,3]&quot;</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;4&quot;</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.read<span class="op">:</span> no parse</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;4&quot;</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;4&quot;</span><span class="ot"> ::</span> <span class="dt">Double</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a><span class="fl">4.0</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;[1, 2, 3]&quot;</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.read<span class="op">:</span> no parse</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;[1, 2, 3]&quot;</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.read<span class="op">:</span> no parse</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;[1, 2, 3]&quot;</span><span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">read</span> <span class="st">&quot;[1, 2, 3]&quot;</span><span class="ot"> ::</span> [<span class="dt">Double</span>]</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1.0</span>,<span class="fl">2.0</span>,<span class="fl">3.0</span>]</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>q</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a><span class="dt">Leaving</span> <span class="dt">GHCi</span><span class="op">.</span></span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a><span class="op">$</span></span></code></pre></div>
<p>Podemos perceber que <code>show</code> e <code>read</code> são úteis principalmente quando operando com arquivos (vamos aprender a utilizar arquivos em algum laboratório). Exemplificamos como lista poderia ser feita instância de <code>Show</code>.</p>
<div class="sourceCode" id="cb110" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> [a] <span class="kw">where</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> [] <span class="ot">=</span> <span class="st">&quot;[]&quot;</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> xs <span class="ot">=</span> <span class="st">&quot;[&quot;</span> <span class="op">++</span> f xs <span class="op">++</span> <span class="st">&quot;]&quot;</span> <span class="kw">where</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>        f <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> intercalate <span class="st">&quot;,&quot;</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">show</span></span></code></pre></div>
<p>Nessa definição, apenas o segundo caso precisa de atenção. A função <code>f</code> transforma todos os elementos da lista em strings (podemos fazer isso por conta de <code>Show a</code>), em seguida intercala a lista resultante com <code>","</code>, e por fim concatena todas as strings da lista. A nossa implementação de <code>show</code> apenas chama <code>f</code> e cerca seu resultado com colchetes.</p>
<div class="exercicio">
<p><strong>Exercício 22</strong>.  <em>Faça de <em><code>Maybe</code></em> uma instância de <em><code>Show</code></em>.</em></p>
</div>
<p>Em seguida, temos a classe <code>Bounded</code>, com as funções <code>minBound</code> e <code>maxBound</code>. Os tipos que são instâncias de <code>Bounded</code> têm limites inferior e superior. São poucos os tipos que instanciam <code>Bounded</code>: <code>Word</code>, <code>Ordering</code>, <code>Int</code>, <code>Char</code> e <code>Bool</code>. Além desses, tuplas com componentes desse tipo instanciam <code>Ordering</code>.</p>
<p>Para tipos numéricos, temos a classe <code>Num</code>.</p>
<div class="sourceCode" id="cb111" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    negate ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    abs ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    signum ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}</span></span></code></pre></div>
<p>Os tipos <code>Word</code>, <code>Integer</code>, <code>Int</code>, <code>Float</code> e <code>Double</code> são instâncias de <code>Num</code>, e suas definições são dadas em baixo nível. Observe ainda que <code>Integer</code> não é instância de <code>Bounded</code>. Isso se dá porque <code>Integer</code> é um tipo que representa inteiros com precisão arbitrária, isto é, o limite de representação de <code>Integer</code> é dado pela memória do computador em uso, e não por uma quantidade constante de <em>bits</em>. A desvantagem de <code>Integer</code> é que suas operações são mais custosas que as de <code>Int</code>.</p>
<p>Note ainda que <code>Num</code> não contém a operação de divisão, já que nem todos os tipos numéricos conseguem representar precisamente resultados de divisões arbitrárias. Para isso existe a classe <code>Fractional</code>.</p>
<div class="sourceCode" id="cb112" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a <span class="kw">where</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (/) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    recip ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromRational ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL fromRational, (recip | (/)) #-}</span></span></code></pre></div>
<p>Em <code>Fractional</code>, estão contidas as operações de divisão, inversa e conversão a partir de <code>Rational</code>, e esse representa racionais em precisão arbitrária usando dois <code>Integer</code>s. Estendendo <code>Fractional</code>, temos a classe <code>Floating</code>, que agrupa operações envolvendo trigonometria, potências e logaritmos. Como seu nome sugere, <code>Floating</code> tem como instâncias apenas representações numéricas de pontos flutuantes: <code>Float</code> e <code>Double</code>.</p>
<p>A classe <code>Real</code> trata de conversões para o tipo <code>Rational</code>, e portanto contém apenas a função <code>toRational</code>. Já a classe <code>Integral</code> trata de divisões com restos em inteiros. A classe <code>RealFrac</code>, por sua vez, cuida de truncamentos e arredondamentos.</p>
<div class="sourceCode" id="cb113" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">RealFrac</span> a <span class="kw">where</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    properFraction ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (b, a)</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    truncate ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    round ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    ceiling ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    floor ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL properFraction #-}</span></span></code></pre></div>
<p>Das funções de <code>RealFrac</code>, apenas <code>properFraction</code> exige esclarecimentos. Essa função retorna um valor numérico decomposto em sua parte inteira e sua parte fracionária. Encerrando as classes de tipos numéricos, temos <code>RealFloat</code>, que reúne diversas funções a respeito de representação em ponto flutuante.</p>
<p>Na próxima subseção, tratamos de classes que abstraem o uso de funções, atribuindo semânticas a estruturas de dados.</p>
<h2 id="functor-applicative-e-alternative"><code>Functor</code>, <code>Applicative</code> e <code>Alternative</code></h2>
<p>Aqui, tratamos das três classes mencionadas no título. Antes de prosseguir, contudo, vamos adicionar a seguinte definição a <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb114" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">$</span> x <span class="ot">=</span> f x</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">$</span></span></code></pre></div>
<p>É isso mesmo. O operador <code>($)</code> aplica seu segundo argumento à função recebida como primeiro argumento. Embora pareça fútil, o fato de Haskell permitir aplicações parciais de funções dá utilidade a <code>($)</code>. A última linha atribui nível de precedência 0 a <code>($)</code> (o mais baixo possível), e também o faz associativo pela esquerda.</p>
<p>O operador <code>($)</code> é apresentado nesse contexto por representar aplicações “normais” de função. No texto a seguir, veremos operadores que representam aplicações “especiais” de função.</p>
<p>Tratamos inicialmente de <code>Functor</code>, que tem a seguinte definição.</p>
<div class="sourceCode" id="cb115" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;$) ::</span> a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL fmap #-}</span></span></code></pre></div>
<p>Precisamos fazer uma pausa para explicar o que significa <code>* -&gt; *</code>. Em Haskell, valores têm tipos (<code>1</code> pode ser do tipo <code>Int</code> ou <code>Integer</code>, por exemplo), assim como tipos têm <em>kinds</em> (<em>kind</em> pode significar tipo, então seria estranho traduzir). Basicamente, um <em>kind</em> é um tipo de tipo, e cada <em>kind</em> é caracterizado pelo número e <em>kinds</em> de seus parâmetros. Há os tipos que não são parametrizados (têm 0 parâmetros), como <code>Int</code> e <code>Char</code>. Esses já estão completos e têm <em>kind</em> <code>*</code>. Há os tipos que têm exatamente um tipo completo como parâmetro. Esses têm <em>kind</em> <code>* -&gt; *</code>. Listas, <code>Maybe</code> e <code>SeqTree</code> têm <em>kind</em> <code>* -&gt; *</code>, e se tornam completos apenas quando parametrizados por um tipo completo (<code>[Char]</code>, <code>Maybe Int</code>, <code>SeqTree (Maybe Char)</code>).</p>
<p>Podemos interpretar o <em>kind</em> <code>* -&gt; *</code> como a classe de tipos que precisam de um tipo completo (<code>*</code>) para produzir (<code>-&gt;</code>) um tipo completo (<code>*</code>). Podemos entender <code>* -&gt; * -&gt; *</code> de forma análoga, e esse é o <em>kind</em> de <code>BSTree</code>.</p>
<p>Há mais detalhes a se explicar sobre <em>kinds</em>. Como esses não são necessários aqui, os desconsideramos.</p>
<p>Voltando a falar de <code>Functor</code>, vemos que há duas funções. A função <code>fmap</code> aplica uma função aos elementos contidos em um valor de um tipo parametrizado. O operador <code>(&lt;$)</code>, por sua vez, substitui todos os elementos de um valor de um tipo parametrizado por um certo elemento. Como exemplo de <code>Functor</code>, temos as listas, e sua instanciação é ilustrada a seguir.</p>
<div class="sourceCode" id="cb116" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<p>Essa definição é padrão de Haskell, e não precisamos implementá-la. Devemos, no entanto, instanciar <code>Maybe</code> como <code>Functor</code>, e a definição seguinte deve se encontrar em <code>Maybe.hs</code>.</p>
<div class="sourceCode" id="cb117" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>Perceba que não é preciso definir <code>(&lt;$)</code>, uma vez que existe a implementação padrão <code>(x &lt;$) = fmap f where f _ = x</code>. Fazemos também de <code>BSTree k</code> uma instância de <code>Functor</code>, pondo o código que segue em <code>BSTree.hs</code>.</p>
<div class="sourceCode" id="cb118" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">BSTree</span> k) <span class="kw">where</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 23</strong>.  <em>Faça de <em><code>SeqTree</code></em> uma instância de <em><code>Functor</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 24</strong>.  <em>Como <em><code>Either</code></em> poderia instanciar <em><code>Functor</code></em>?</em></p>
</div>
<p>Uma vez que temos visto algumas instâncias da classe <code>Functor</code>, apresentamos o operador <code>(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>. Esse operador equivale à função <code>fmap</code>, e sua assinatura sugere uma comparação com <code>($)</code>. Trazemos uma breve ilustração de seu uso.</p>
<div class="sourceCode" id="cb119" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>t (<span class="op">$</span>)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>t (<span class="op">&lt;$&gt;</span>)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">*</span><span class="dv">2</span>) <span class="op">$</span> <span class="dv">3</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">*</span><span class="dv">2</span>) <span class="op">$</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">4</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="dt">Non</span> <span class="kw">type</span><span class="op">-</span>variable argument <span class="kw">in</span> the constraint<span class="op">:</span> <span class="dt">Num</span> [a]</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Use</span> <span class="dt">FlexibleContexts</span> to permit this)</span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="dt">When</span> checking the inferred <span class="kw">type</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a><span class="ot">        it ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Num</span> a, <span class="dt">Num</span> [a]) <span class="ot">=&gt;</span> [a]</span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">*</span><span class="dv">2</span>) <span class="op">&lt;$&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">*</span><span class="dv">2</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">*</span><span class="dv">2</span>) <span class="op">&lt;$&gt;</span> (<span class="dt">Just</span> <span class="dv">4</span>)</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">8</span></span></code></pre></div>
<p>Vemos a distinção entre <code>($)</code> e <code>(&lt;$&gt;)</code>. Enquanto <code>($)</code> permite a aplicação de uma função a valores “soltos”, o operador <code>(&lt;$&gt;)</code> aplica a função a valores “contidos” em instâncias de <code>Functor</code>. Com isso, damos os primeiros passos para interpretar estruturas de dados como “contextos”.</p>
<p>Como Haskell tem suas funções como habitantes de primeira classe, é perfeitamente possível que funções sejam guardadas em estruturas de dados. Podemos imaginar que essas funções estão sob um certo “contexto”, e definitivamente queremos utilizá-las (senão não faria sentido guardá-las). Essa é a motivação básica de <code>Applicative</code>: aplicar funções contidas em estruturas de dados.</p>
<div class="sourceCode" id="cb120" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    GHC.Base.liftA2<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (*&gt;) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f b</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span></span></code></pre></div>
<p>Percebemos que instâncias de <code>Applicative</code> devem ter o mesmo <em>kind</em> de instâncias de <code>Functor</code>. Mais ainda: instâncias de <code>Applicative</code> devem ser também instâncias de <code>Functor</code>.</p>
<p>A função <code>pure</code> é responsável por “contextualizar” um valor, de acordo com a expressão em que é usada. O operador <code>(&lt;*&gt;)</code> aplica as funções contidas em seu primeiro argumento aos valores contidos no segundo. Trataremos das demais funções de <code>Applicative</code> em breve.</p>
<p>Como exemplo, listas são instância de <code>Applicative</code>.</p>
<div class="sourceCode" id="cb121" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> [x]</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    [] <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> []</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">&lt;*&gt;</span> [] <span class="ot">=</span> []</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    (f<span class="op">:</span>fs) <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> f <span class="op">&lt;$&gt;</span> xs <span class="op">++</span> fs <span class="op">&lt;*&gt;</span> xs</span></code></pre></div>
<p>Enquanto instância de <code>Applicative</code>, o tipo lista representa computações não-determinísticas. Ilustramos esse conceito a seguir.</p>
<div class="sourceCode" id="cb122" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> xs <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> ys <span class="ot">=</span> [<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;$&gt;</span> ys</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">8</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> <span class="dt">&#39;Integer</span> <span class="ot">-&gt;</span> b&#39;</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>            with actual <span class="kw">type</span> &#39;[<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]&#39;</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="dt">Possible</span> cause<span class="op">:</span> &#39;(<span class="op">&lt;$&gt;</span>)&#39; is applied to too many arguments</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the first argument <span class="kw">of</span> &#39;(<span class="op">&lt;$&gt;</span>)&#39;, namely &#39;(<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs&#39;</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the expression<span class="op">:</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;$&gt;</span> ys</span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> an equation for &#39;it&#39;<span class="op">:</span> it <span class="ot">=</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;$&gt;</span> ys</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="dt">Relevant</span> bindings include<span class="ot"> it ::</span> [b] (bound at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">8</span><span class="op">:</span><span class="dv">1</span>)</span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;*&gt;</span> ys</span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>[<span class="dv">11</span>,<span class="dv">21</span>,<span class="dv">31</span>,<span class="dv">12</span>,<span class="dv">22</span>,<span class="dv">32</span>,<span class="dv">13</span>,<span class="dv">23</span>,<span class="dv">33</span>]</span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> xs <span class="ot">=</span> []</span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;*&gt;</span> ys</span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> xs <span class="ot">=</span> [<span class="dv">2</span>]</span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;*&gt;</span> ys</span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a>[<span class="dv">12</span>,<span class="dv">22</span>,<span class="dv">32</span>]</span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> <span class="dv">5</span> <span class="op">&lt;*&gt;</span> ys</span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a>[<span class="dv">15</span>,<span class="dv">25</span>,<span class="dv">35</span>]</span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> <span class="dv">5</span> <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> <span class="dv">7</span></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span></span></code></pre></div>
<p>Vemos que a expressão <code>(+) &lt;$&gt; xs &lt;*&gt; ys</code> retorna os resultados de todas as aplicações possíveis de <code>(+)</code> aos elementos de <code>xs</code> (como primeiro argumento) e <code>ys</code> (como segudo argumento). Primeiro, <code>(+) &lt;$&gt; xs</code> é uma lista de funções, mais precisamente as aplicações parciais de <code>(+)</code> aos elementos de <code>xs</code>. Com isso, <code>(+) &lt;$&gt; xs</code> é mais que um <code>Functor</code>, o que fica evidente com a expressão <code>(+) &lt;$&gt; xs &lt;$&gt; ys</code>, rejeitada pelo interpretador.</p>
<p>Se pensarmos em <code>xs</code> e <code>ys</code> como resultados de computações não-determinísticas, isto é, de computações que poden ter um número arbitrário de resultados (inclusive nenhum), passamos a ver a expressão <code>(+) &lt;$&gt; xs &lt;*&gt; ys</code> como a soma de dois valores não-determinísticos, e tal expressão deve representar todas as possibilidades de resultado.</p>
<div class="exercicio">
<p><strong>Exercício 25</strong>.  <em>Implemente a função <em><code>sequences :: [a] -&gt; [[a]]</code></em> que, dada uma lista de elementos <em><code>xs</code></em>, retorna a lista de todas as sequências possíveis formadas por elementos de <em><code>xs</code></em>. As funções <em><code>iterate</code></em> e <em><code>concat</code></em> são úteis aqui. Pensar de forma indutiva e não-determinística nos leva a definir <em><code>sequences</code></em> em uma linha!</em></p>
</div>
<div id="exercicio:subsets" class="exercicio">
<p><strong>Exercício 26</strong>.  <em>Implemente a função <em><code>subsets :: [a] -&gt; [[a]]</code></em> que, dada uma lista <em><code>xs</code></em> sem elementos repetidos, retorna uma lista de listas, onde cada sublista representa um subconjunto de <em><code>xs</code></em>. Pense de forma indutiva: como se obtém os subconjuntos de <em><code>x:xs</code></em> a partir dos subconjuntos de <em><code>xs</code></em>?</em></p>
</div>
<div id="exercicio:sequenceA" class="exercicio">
<p><strong>Exercício 27</strong>.  <em>Implemente a função <em><code>sequenceA :: Applicative f =&gt; [f a] -&gt; f [a]</code></em>, que toma uma lista de valores <em><code>f a</code></em> e constrói uma lista de valores <em><code>a</code></em>, que é retornada dentro de <em><code>f</code></em>.</em></p>
</div>
<p>Essa, no entanto, não é a única interpretação plausível que tornaria listas uma instância de <code>Applicative</code>. É possível pensar, por exemplo, que listas poderiam instanciar <code>Applicative</code> em termos de <code>zipWith</code>. Como um tipo pode instanciar uma classe no máximo uma vez, adicionamos as seguintes definições a <code>List.hs</code>.</p>
<div class="sourceCode" id="cb123" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ZipList</span> a <span class="ot">=</span> <span class="dt">ZL</span> [a]</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="ot">zipList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ZipList</span> a</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>zipList xs <span class="ot">=</span> <span class="dt">ZL</span> xs</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getZipList ::</span> <span class="dt">ZipList</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>getZipList (<span class="dt">ZL</span> xs) <span class="ot">=</span> xs</span></code></pre></div>
<p>Aqui, vemos nosso primeiro uso de <code>newtype</code>. A palavra <code>newtype</code> permite a construção de tipos muito simples, com um único caso e um único campo. Com essas restrições, os tipos criados com <code>newtype</code> não são compostos, mas apenas encapsulamentos de tipos já existentes. Isso não é útil para criar estruturas de dados, mas é muito conveniente para permitir que um tipo instancie uma classe mais de uma vez, agora em suas versões encapsuladas. Melhor ainda: como <code>newtype</code> pode apenas criar tipos dessa forma, o encapsulamento é desfeito em tempo de compilação, portanto o uso de tipos criados com <code>newtype</code> não traz custos adicionais para a execução de um programa.</p>
<p>Agora, devemos fazer de <code>ZipList</code> uma instância de <code>Functor</code> e <code>Applicative</code>, nessa ordem.</p>
<div class="sourceCode" id="cb124" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ZipList</span> <span class="kw">where</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">ZL</span> xs) <span class="ot">=</span> <span class="dt">ZL</span> (<span class="fu">fmap</span> f xs)</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> zipList <span class="op">.</span> <span class="fu">repeat</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">ZL</span> fs) <span class="op">&lt;*&gt;</span> (<span class="dt">ZL</span> xs) <span class="ot">=</span> <span class="dt">ZL</span> (<span class="fu">zipWith</span> (<span class="op">$</span>) fs xs)</span></code></pre></div>
<p>Note que <code>ZipList</code> torna-se instância de <code>Functor</code> com a mesma semântica das listas. No entanto, <code>ZipList</code> é instância de <code>Applicative</code> com uma semântica iterativa, tornando-se distinta das listas nesse aspecto. Ilustramos o uso de <code>ZipList</code> a seguir.</p>
<div class="sourceCode" id="cb125" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> xs <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> ys <span class="ot">=</span> [<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;*&gt;</span> ys</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">11</span>,<span class="dv">21</span>,<span class="dv">31</span>,<span class="dv">12</span>,<span class="dv">22</span>,<span class="dv">32</span>,<span class="dv">13</span>,<span class="dv">23</span>,<span class="dv">33</span>]</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> getZipList ((<span class="op">+</span>) <span class="op">&lt;$&gt;</span> zipList xs <span class="op">&lt;*&gt;</span> zipList ys)</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">11</span>,<span class="dv">22</span>,<span class="dv">33</span>]</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> getZipList ((<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> <span class="dv">5</span> <span class="op">&lt;*&gt;</span> zipList ys)</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">15</span>,<span class="dv">25</span>,<span class="dv">35</span>]</span></code></pre></div>
<p>Um outro exemplo de <code>Applicative</code> é <code>Maybe</code>. Definimos <code>Maybe</code> como <code>Applicative</code> pelo código que segue, escrito em <code>Maybe.hs</code>.</p>
<div class="sourceCode" id="cb126" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">&lt;*&gt;</span> <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>Claramente, <code>Maybe</code> representa computações que podem falhar, tendo nenhum ou exatamente um resultado. Ilustramos esse conceito a seguir.</p>
<div class="sourceCode" id="cb127" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">4</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">7</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> <span class="dv">4</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">7</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Nothing</span> <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> <span class="dv">4</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span></code></pre></div>
<p>Com isso, vemos que o uso de <code>Maybe</code> enquanto <code>Applicative</code> nos permite criar, a partir de computações que podem falhar, computações maiores com essa mesma semântica. O uso de <code>(&lt;$&gt;)</code> e <code>(&lt;*&gt;)</code> nos poupa do trabalho de tratar os casos de <code>Maybe</code>, e nos diz que computações com partes que podem falhar são computações que podem falhar como um todo.</p>
<p>Destacamos o papel de <code>pure</code>, evidenciado por esses exemplos. Mesmo que uma de nossas computações tenha uma semântica especial, pode haver partes dela que sejam simples computações determinísticas, feitas com o uso de valores <em>puros</em>. A função <code>pure</code> é usada justamente para “promover” valores puros para os contextos de funções com semânticas especiais. Seu uso é indispensável, uma vez que a função <code>main</code> de um programa em Haskell é necessariamente uma função com semântica especial.</p>
<p>O operador <code>(&lt;*)</code> tem o mesmo comportamento de <code>(*&gt;)</code>, porém o papel de seus argumentos é permutado. Dito isso, nos concentramos em <code>(*&gt;)</code>, cujo papel é aplicar a semântica de seu primeiro argumento (ignorando seus valores) no segundo. Vamos exemplificar o que isso significa.</p>
<div class="sourceCode" id="cb128" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> [] <span class="op">*&gt;</span> <span class="fu">pure</span> <span class="dv">3</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">*&gt;</span> <span class="fu">pure</span> <span class="dv">3</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>]</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">*&gt;</span> [<span class="dv">10</span>,<span class="dv">20</span>]</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">10</span>,<span class="dv">20</span>]</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">pure</span> <span class="dv">3</span> <span class="op">*&gt;</span> <span class="fu">pure</span> <span class="dv">5</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">*&gt;</span> <span class="fu">pure</span> <span class="dv">5</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">5</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dt">Nothing</span> <span class="op">*&gt;</span> <span class="fu">pure</span> <span class="dv">5</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">*&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">pure</span> <span class="dv">3</span> <span class="op">*&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span></code></pre></div>
<p>Isso evidencia que <code>(*&gt;)</code> é definido como <code>x *&gt; y = f &lt;$&gt; x &lt;*&gt; y where f _ q = q</code>. O operador <code>(*&gt;)</code> costuma ser utilizado quando se quer tomar apenas o valor semântico de uma computação, ignorando seu resultado. Por exemplo, <code>find p xs *&gt; f xs</code> vale <code>Nothing</code> ou <code>Just (f xs)</code>, a depender se há um elemento em <code>xs</code> (ignorado por <code>(*&gt;)</code>) satisfazendo <code>p</code>.</p>
<p>Por fim, a função <code>liftA2</code> traz uma outra forma de se utilizar <code>Applicative</code>. <code>liftA2</code> encapsula a aplicação explícita de <code>(&lt;$&gt;)</code> e <code>(&lt;*&gt;)</code>. Assim, as expressões <code>f &lt;$&gt; x &lt;*&gt; y</code> e <code>liftA2 f x y</code> são equivalentes.</p>
<div class="exercicio">
<p><strong>Exercício 28</strong>.  <em>Faça de <em><code>BSTree k</code></em> uma instância de <em><code>Applicative</code></em>. Qual seria uma semântica adequada para esse tipo? Lembre-se de produzir uma árvore binária de busca válida.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 29</strong>.  <em>Faça de <em><code>SeqTree</code></em> uma instância de <em><code>Applicative</code></em>. Como se trata de uma representação linear de dados, <em><code>SeqTree</code></em> sofre do mesmo dilema que as listas.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 30</strong>.  <em>Faça de <em><code>Either a</code></em> uma instância de <em><code>Applicative</code></em>.</em></p>
</div>
<p>Uma função muito interessante de se implementar é <code>when</code>, que modifica a semântica de um <code>Applicative</code> conforme um valor booleano. Basicamente, <code>when</code> pode ser usada para condicionar a realização de uma certa computação. Sua definição é escrita em <code>Bool.hs</code>.</p>
<div class="sourceCode" id="cb129" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="ot">when ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f ()</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>when <span class="dt">True</span> x <span class="ot">=</span> x</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>when <span class="dt">False</span> _ <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="ot">unless ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f ()</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>unless <span class="ot">=</span> when <span class="op">.</span> <span class="fu">not</span></span></code></pre></div>
<p>Além de <code>when</code>, definimos também sua versão negada, <code>unless</code>. Por fim, temos <code>forever :: Applicative f =&gt; f a -&gt; f b</code>, que repete uma computação indefinidamente.</p>
<div class="sourceCode" id="cb130" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forever ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>forever x <span class="ot">=</span> x <span class="op">*&gt;</span> forever x</span></code></pre></div>
<p>Agora vamos falar sobre <code>Alternative</code>, definida em <code>Control.Applicative</code>.</p>
<div class="sourceCode" id="cb131" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    empty ::</span> f a</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    some ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    many ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL empty, (&lt;|&gt;) #-}</span></span></code></pre></div>
<p>A classe <code>Alternative</code> é instanciada por tipos que, de alguma forma, trazem o conceito de ser vazio ou não. A função <code>empty</code> retorna a representação “vazia” de um tipo, que geralmente é inferido pela expressão em que <code>empty</code> é utilizada. O operador <code>(&lt;|&gt;)</code> representa uma espécie de união, e combina dois valores com a propriedade de que <code>x &lt;|&gt; y == empty</code> sse <code>x == y == empty</code>.</p>
<p>As listas são instância de <code>Alternative</code>, da seguinte forma.</p>
<div class="sourceCode" id="cb132" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> [] <span class="kw">where</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> []</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre></div>
<p>Com isso, podemos instanciar <code>ZipList</code> como <code>Alternative</code> com a seguinte definição, que se encontra em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb133" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">ZipList</span> <span class="kw">where</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> zipList empty</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">ZL</span> xs) <span class="op">&lt;|&gt;</span> (<span class="dt">ZL</span> ys) <span class="ot">=</span> <span class="dt">ZL</span> (xs <span class="op">&lt;|&gt;</span> ys)</span></code></pre></div>
<p>Em se tratando de listas ou <code>ZipLists</code>, a definição de <code>Alternative</code> é bem simples e intuitiva. O tipo <code>Maybe</code> é instanciado como <code>Alternative</code> com as seguintes definições, que se encontram em <code>Maybe.hs</code>.</p>
<div class="sourceCode" id="cb134" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&lt;|&gt;</span> y <span class="ot">=</span> y</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> x</span></code></pre></div>
<p>As instâncias de <code>Alternative</code> são particularmente úteis para representar os resultados de computações que podem falhar. Enquanto computações não-determinísticas, representadas por listas, apenas têm seus resultados mesclados, o tipo <code>Maybe</code> apresenta um comportamento mais interessante: o segundo argumento de <code>(&lt;|&gt;)</code> é utilizado apenas quando o primeiro argumento representa uma falha. Dessa forma, podemos criar uma sequência de computações que podem falhar, de tal forma que cada uma delas é executada apenas quando todas as anteriores têm falhado.</p>
<div class="exercicio">
<p><strong>Exercício 31</strong>.  <em>Escreva a função <em><code>asum :: Alternative f =&gt; [f a] -&gt; f a</code></em>. <em><code>foldr</code></em> é útil para isso.</em></p>
</div>
<p>Descrevemos a função <code>guard</code>, que permite “traduzir” um valor booleano, <code>True</code> ou <code>False</code>, para um valor semântico de <code>Alternative</code>, não-vazio ou <code>empty</code>, respectivamente. Essa definição é escrita em <code>Bool.hs</code>.</p>
<div class="sourceCode" id="cb135" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="ot">guard ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f ()</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">True</span> <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">False</span> <span class="ot">=</span> empty</span></code></pre></div>
<p>Numa seção futura, tratarenos de <code>Monad</code>, que leva adiante as abstrações definidas em <code>Functor</code> e <code>Applicative</code>.</p>
<h2 id="fix-e-programação-dinâmica"><code>fix</code> e Programação Dinâmica</h2>
<p>Em Haskell, fazemos uso de recursão tanto para definir tipos como para controlar operações. É usual que as definições recursivas tenham um caso base, em que há uma expressão simples. No entanto, temos nos deparado com funções recursivas que não têm um caso base e que, não fosse a preguiça de Haskell, teriam suas chamadas sempre resultando em estouros de pilha. É o caso das funções <code>repeat</code> e <code>cycle</code>, propostas na Subseção <a href="#lab2" data-reference-type="ref" data-reference="lab2">4.2</a>.</p>
<p>Temos em <code>nats</code> mais um exemplo desse tipo de definição.</p>
<div class="sourceCode" id="cb136" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nats ::</span> [<span class="dt">Int</span>]</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>nats <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) nats</span></code></pre></div>
<p>Claramente, <code>nats</code> é baseada na definição indutiva dos naturais, e de fato representa uma lista infinita contendo os naturais. Observamos o seguinte comportamento: uma vez que <code>map (+1)</code> retorne uma lista, essa será a cauda da lista retornada por <code>(1:)</code>; além disso, a lista retornada por <code>(1:)</code> é justamente o argumento passado para <code>map (+1)</code>. Podemos fazer uma análise similar para <code>repeat</code> e <code>cycle</code>. Reescrevemos <code>nats</code> de forma que isso fique evidente.</p>
<div class="sourceCode" id="cb137" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nats ::</span> [<span class="dt">Int</span>]</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>nats <span class="ot">=</span> ((<span class="dv">1</span><span class="op">:</span>) <span class="op">.</span> (<span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>))) nats</span></code></pre></div>
<p>Se admitirmos que <code>f = (1:) . (map (+1))</code>, temos que <code>nats = f nats</code>. Nesse momento, pode ser bastante estranho e desconfortável perceber que a definição de <code>nats</code> depende exclusivamente de <code>f</code>, uma vez que <code>nats</code>, por mais que seja o argumento passado para <code>f</code>, é o retorno de <code>f (f (f (f (...))))</code>. Isso pode dar um nó na mente, mas é útil a ponto de generalizarmos esse conceito para funções com argumento e retorno de mesmo tipo. Escrevemos a seguinte definição em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb138" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> f (fix f)</span></code></pre></div>
<p>Embora simples, <code>fix</code> é um tanto estranha. Ela toma <code>f</code> e deve retornar um elemento de tipo <code>a</code>. Para isso, ela passa um elemento de tipo <code>a</code> para <code>f</code>, que é justamente <code>fix f</code>. No fim das contas, <code>fix f == f (f (f (f (...))))</code>.</p>
<p>Bem, não seria muito interessante passar uma função de assinatura <code>Int -&gt; Int</code> para <code>fix</code>, por exemplo, afinal não poderíamos usar seu retorno.</p>
<div class="sourceCode" id="cb139" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> fix (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> stack overflow</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span></span></code></pre></div>
<p>Para usá-la de forma útil, é interessante que o retorno de <code>f</code> possa ser construído incrementalmente. O retorno de <code>nats</code>, por exemplo, cumpre esse requisito por ser uma lista.</p>
<div class="sourceCode" id="cb140" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nats ::</span> [<span class="dt">Int</span>]</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>nats <span class="ot">=</span> fix <span class="op">$</span> (<span class="dv">1</span><span class="op">:</span>) <span class="op">.</span> (<span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>))</span></code></pre></div>
<p>Embora <code>fix</code> não tenha caso base, <code>nats</code> pode ser usada mesmo que seja escrita dessa forma, por conta da preguiça de Haskell.</p>
<div class="exercicio">
<p><strong>Exercício 32</strong>.  <em>Escreva as funções <em><code>repeat</code></em> e <em><code>cycle</code></em> em termos de <em><code>fix</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 33</strong>.  <em>Defina <em><code>iterate</code></em> em termos de <em><code>fix</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 34</strong>.  <em>Implemente <em><code>forever</code></em> em termos de <em><code>fix</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 35</strong>.  <em>Tome a função <em><code>range</code></em> definida como segue.</em></p>
<div class="sourceCode" id="cb141" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> <span class="dv">0</span> <span class="ot">=</span> [<span class="dv">0</span>]</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> x <span class="ot">=</span> x <span class="op">:</span> <span class="fu">range</span> (x <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p><em>Escreva <em><code>range</code></em> em termos de <em><code>fix</code></em>.</em></p>
</div>
<div id="exercicioFixFactorial" class="exercicio">
<p><strong>Exercício 36</strong>.  <em>Tome a seguinte função.</em></p>
<div class="sourceCode" id="cb142" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>f _ <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>f rec n <span class="ot">=</span> n <span class="op">*</span> rec (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p><em>A função <em><code>f</code></em> parece estar calculando fatorial, mas é bizarra. Ela “conhece” a definição de fatorial, mas não podemos dizer que ela é recursiva, pois se define em termos de <em><code>rec</code></em>. No entanto, se <em><code>rec</code></em> calculasse fatorial, <em><code>f rec</code></em> seria umaa definição plausível de fatorial. Defina <em><code>fact :: Int -&gt; Int</code></em>, que calcula fatorial, em termos de <em><code>f</code></em> e <em><code>fix</code></em>.</em></p>
</div>
<p>No Exercício <a href="#exercicioFixFactorial" data-reference-type="ref" data-reference="exercicioFixFactorial">Exercício 36</a>, nos deparamos com uma prática um tanto peculiar: criar uma versão não-recursiva de uma função recursiva, fazendo sua chamada recursiva em termos de uma outra função de mesma assinatura, recebida como argumento. Embora o Exercício <a href="#exercicioFixFactorial" data-reference-type="ref" data-reference="exercicioFixFactorial">Exercício 36</a> use essa “decomposição” de maneira fútil, podemos ir mais adiante. É possível, por exemplo, “decompor” uma função recursiva <code>f</code> e deixar suas chamadas recursivas a cargo de uma versão “especial” de <code>f</code>. Esse conceito pode ser utilizado para, dentre outras coisas, implementar versões memoizadas de funções recursivas.</p>
<p>Para ilustrar essa ideia, vamos tomar um caso clássico.</p>
<div class="sourceCode" id="cb143" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Basta uma verificação superficial para constatar que <code>fib</code> retorna o <code>n</code>-ésimo número de Fibonacci, e que essa não é uma boa implementação. Por diversão, vamos tomar medidas do quão ruim ela é. Para isso, vamos criar um arquivo <code>Memo.hs</code>, com o seguinte conteúdo inicial (provisório), e escrever a definição de <code>fib</code> nesse arquivo.</p>
<div class="sourceCode" id="cb144" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Memo</span> <span class="kw">where</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (-), (+))</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span></code></pre></div>
<p>Agora vamos aos testes.</p>
<div class="sourceCode" id="cb145" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>l <span class="dt">Memo</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Memo</span>             ( Memo.hs, interpreted )</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="op">.</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">10</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.01</span> secs, <span class="dv">92</span>,<span class="dv">888</span> bytes)</span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">15</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="dv">610</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.01</span> secs, <span class="dv">388</span>,<span class="dv">032</span> bytes)</span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">20</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a><span class="dv">6765</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.01</span> secs, <span class="dv">3</span>,<span class="dv">655</span>,<span class="dv">320</span> bytes)</span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">25</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a><span class="dv">75025</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.12</span> secs, <span class="dv">39</span>,<span class="dv">882</span>,<span class="dv">672</span> bytes)</span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">30</span></span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a><span class="dv">832040</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.79</span> secs, <span class="dv">441</span>,<span class="dv">642</span>,<span class="dv">736</span> bytes)</span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>(<span class="fl">8.21</span> secs, <span class="dv">4</span>,<span class="dv">897</span>,<span class="dv">222</span>,<span class="dv">696</span> bytes)</span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<p>Vamos analisar rapidamente o uso de tempo e espaço. Observamos que, da chamada <code>fib 25</code> para <code>fib 30</code>, o tempo de execução aumentou cerca de <span class="math inline">\(6,5\)</span> vezes, enquanto de <code>fib 30</code> para <code>fib 35</code> o aumento foi de aproximadamente <span class="math inline">\(10,4\)</span> vezes. Isso não é muito animador. Quanto ao uso de espaço, não é preciso muita experiência para estranhar o fato de <code>fib 35</code> ter gasto quase cinco gigabytes de memória. Nesse pequeno experimento, a única coisa boa que aprendemos foi o uso de <code>:set +s</code> para exibir tempo de execução e uso de memória.</p>
<div id="exercicio:fix2" class="exercicio">
<p><strong>Exercício 37</strong>.  <em>Considere a seguinte definição.</em></p>
<div class="sourceCode" id="cb146" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    fix2 ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>    fix2 f <span class="ot">=</span> y <span class="kw">where</span> y <span class="ot">=</span> f y</span></code></pre></div>
<p><em>Observe o seguinte experimento.</em></p>
<div class="sourceCode" id="cb147" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> f x <span class="ot">=</span> fix (x<span class="op">:</span>)</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    (<span class="fl">0.00</span> secs, <span class="dv">0</span> bytes)</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> g x <span class="ot">=</span> fix2 (x<span class="op">:</span>)</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    (<span class="fl">0.00</span> secs, <span class="dv">0</span> bytes)</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">head</span> (<span class="fu">drop</span> <span class="dv">10000000</span> (f <span class="dv">2</span>))</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    (<span class="fl">1.21</span> secs, <span class="dv">640</span>,<span class="dv">063</span>,<span class="dv">368</span> bytes)</span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">head</span> (<span class="fu">drop</span> <span class="dv">10000000</span> (g <span class="dv">2</span>))</span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>    (<span class="fl">0.07</span> secs, <span class="dv">63</span>,<span class="dv">416</span> bytes)</span></code></pre></div>
<p><em>Explique o que torna <em><code>fix2</code></em> mais eficiente que <em><code>fix</code></em>.</em></p>
</div>
<p>Em vista do desastre que é a atual implementação de <code>fib</code>, propomos uma solução eficiente e elegante, que é praticamente um mascote da linguagem Haskell.</p>
<div class="sourceCode" id="cb148" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>fib <span class="ot">=</span> (fibs <span class="op">!!</span>) <span class="kw">where</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    fibs <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fibs (<span class="fu">tail</span> fibs)</span></code></pre></div>
<p>Nessa implementação, <code>fib</code> recebe <code>n</code> e toma o <code>n</code>-ésimo elemento de uma lista. Essa lista é justamente uma definição recursiva para a sequência de Fibonacci.</p>
<p>Escrita dessa forma, <code>fib</code> é eficiente porque, uma vez que os elementos de <code>fibs</code> são calculados, não há a necessidade de recalculá-los. Note como a primeira versão de <code>fib</code> precisa calcular um número de Fibonacci mais de uma vez. Enfim, vamos aos testes.</p>
<div class="sourceCode" id="cb149" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.14</span> secs, <span class="dv">84</span>,<span class="dv">040</span> bytes)</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">71</span>,<span class="dv">760</span> bytes)</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<p>Perceba que, na primeira chamada <code>fib 35</code>, o elemento correspondente em <code>fibs</code> ainda não havia sido calculado. Como a segunda chamada não precisava calcular esse elemento, mas apenas retorná-lo, seu tempo de execução é irrisório.</p>
<p>Essa refatoração de <code>fib</code> exibe uma maneira muito elegante de se determinar a sequência de Fibonacci, e com isso armazená-la como uma lista na memória, produzindo uma espécie de <em>cache</em> para <code>fib</code>. No entanto, essa abordagem não se generaliza para outras funções, já que usa algo característico dos números de Fibonacci para produzir uma <em>cache</em>.</p>
<p>Uma terceira forma de escrever <code>fib</code> é apresentada abaixo.</p>
<div class="sourceCode" id="cb150" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>fib <span class="ot">=</span> fix f <span class="kw">where</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    f _ <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    f _ <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>    f rec n <span class="ot">=</span> rec (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> rec (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>É aqui que entramos na toca do coelho. Primeiro, <code>fix</code> permite que a função <code>f</code> receba <code>f (f (f (f (...))))</code> como seu primeiro argumento. Segundo, isso é equivalente à nossa primeira definição de <code>fib</code>. Então por que escrevê-la de uma forma mais complicada? Antes de responder a essa pergunta, testamos essa definição.</p>
<div class="sourceCode" id="cb151" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>(<span class="fl">22.00</span> secs, <span class="dv">11</span>,<span class="dv">892</span>,<span class="dv">075</span>,<span class="dv">208</span> bytes)</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<p>Essa versão é ainda pior! Mas não tiramos proveito da “decomposição” da primeira versão de <code>fib</code>, aqui expressa como <code>f</code>. Se <code>rec</code> fosse uma versão eficiente de <code>f</code>, teríamos obtido uma implementação eficiente para <code>fib</code>.</p>
<p>Como <code>fib</code> tem assinatura <code>Int -&gt; Int</code> e espera um argumento não-negativo, tratamos de criar um esquema de <em>cache</em> adequado para funções com essas características.</p>
<div class="sourceCode" id="cb152" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="ot">memo ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> b</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>memo f <span class="ot">=</span> (ys <span class="op">!!</span>) <span class="kw">where</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    xs <span class="ot">=</span> <span class="fu">iterate</span> (<span class="op">+</span><span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>    ys <span class="ot">=</span> <span class="fu">map</span> f xs</span></code></pre></div>
<p>A definição de <code>memo</code> é bastante ingênua, estúpida até. Para uma função <code>f :: Int -&gt; Int</code> que espere argumentos não-negativos, <code>f</code> e <code>memo f</code> são equivalentes. No entanto, há uma diferença na forma como produzem seus retornos. Dado um argumento <code>n</code>, todas as chamadas <code>f n</code> teriam o mesmo custo computacional. Por outro lado, fazendo <code>g = memo f</code>, a primeira chamada <code>g n</code> teria o mesmo custo de <code>f n</code>, valor esse que ficaria salvo em <code>ys</code>, de forma que as chamadas seguintes <code>g n</code> apenas buscariam pelo valor salvo.</p>
<p>Tomando a primeira versão de <code>fib</code>, é tentador considerar que <code>memofib = memo fib</code> seja eficiente. Perceba, todavia, que <code>memofib</code> tem o mesmo custo de <code>fib</code> sempre que chamada para um novo argumento.</p>
<div class="sourceCode" id="cb153" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> memofib <span class="ot">=</span> memo fib</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> memofib <span class="dv">35</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>(<span class="fl">8.17</span> secs, <span class="dv">4</span>,<span class="dv">897</span>,<span class="dv">239</span>,<span class="dv">864</span> bytes)</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> memofib <span class="dv">35</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">71</span>,<span class="dv">760</span> bytes)</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> memofib <span class="dv">36</span></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a><span class="dv">14930352</span></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>(<span class="fl">13.08</span> secs, <span class="dv">7</span>,<span class="dv">923</span>,<span class="dv">836</span>,<span class="dv">624</span> bytes)</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> memofib <span class="dv">37</span></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a><span class="dv">24157817</span></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>(<span class="fl">21.13</span> secs, <span class="dv">12</span>,<span class="dv">820</span>,<span class="dv">992</span>,<span class="dv">200</span> bytes)</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<p>Esse experimento evidencia outra coisa muito chata sobre <code>memofib</code>. As duas chamadas <code>memofib 35</code> nos mostram que os retornos de <code>fib</code> realmente estão sendo salvos por <code>memo</code>. Porém, uma vez salvos <code>fib 35</code> e <code>fib 36</code>, era de se esperar que <code>memofib 37</code> tivesse um custo bem mais baixo que o apresentado. É por isso que precisamos de <code>fix</code>.</p>
<p>Tomando <code>f</code> como a versão “decomposta” de <code>fib</code>, <code>f rec</code> é uma implementação eficiente de <code>fib</code> desde que <code>rec</code> também seja. Ora, nesse caso <code>memo (f rec)</code> é uma implementação eficiente de <code>fib</code>. Usamos <code>fix</code> para ligar as duas pontas.</p>
<div class="sourceCode" id="cb154" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>fib <span class="ot">=</span> fix (memo <span class="op">.</span> f) <span class="kw">where</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    f _ <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    f _ <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>    f rec n <span class="ot">=</span> rec (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> rec (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>E aqui começa a festa do chá. Vamos usar a sanidade que nos resta para testar essa definição de <code>fib</code>.</p>
<div class="sourceCode" id="cb155" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.02</span> secs, <span class="dv">1</span>,<span class="dv">366</span>,<span class="dv">096</span> bytes)</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">71</span>,<span class="dv">760</span> bytes)</span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">36</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a><span class="dv">14930352</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">255</span>,<span class="dv">872</span> bytes)</span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">36</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a><span class="dv">14930352</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">72</span>,<span class="dv">616</span> bytes)</span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">37</span></span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a><span class="dv">24157817</span></span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">265</span>,<span class="dv">512</span> bytes)</span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">37</span></span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a><span class="dv">24157817</span></span>
<span id="cb155-19"><a href="#cb155-19" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">72</span>,<span class="dv">736</span> bytes)</span>
<span id="cb155-20"><a href="#cb155-20" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<p>Conseguimos mais uma versão de <code>fib</code> verdadeiramente eficiente. Para entender como ela funciona, note que <code>f</code> ignora seu primeiro argumento nos casos base. Isso e a preguiça de Haskell impedem <code>fix</code> de provocar um estouro de pilha. Observe também que, graças a <code>fix</code>, <code>g = memo . f</code> recebe <code>g (g (g (g (...))))</code> como primeiro argumento. Para entender a importância disso, perceba que <code>memo . f</code> retorna uma versão eficiente de <code>f</code> quando recebe uma versão eficiente de <code>f</code>. Nesse caso, basta passar para <code>memo . f</code> a função <code>memo . f</code> recebendo uma versão eficiente de <code>f</code>. Mas isso contém o mesmo problema da situação anterior! É aí que entra <code>fix</code>, permitindo passar <code>memo . f</code> para <code>memo . f</code> infinitamente.</p>
<p>Com tudo isso, criamos uma boa implementação para <code>fib</code> baseada em <em>cache</em>, mas dessa vez a implementação da <em>cache</em> é genérica. Bem, genérica para funções <code>f :: Int -&gt; Int</code> que esperam argumentos não-negativos: “decompomos” <code>f</code> em <code>f’ :: (Int -&gt; Int) -&gt; Int -&gt; Int</code> e fazemos <code>fix (memo . f’)</code>. Mas e quanto a funções quaisquer <code>a -&gt; b</code>?</p>
<p>Antes de abordar essa questão, vamos resolver uma mais simples. Representar a <em>cache</em> como uma lista infinita não é a abordagem mais eficiente, por conta de seu acesso em tempo linear. Vamos, portanto, representar a <em>cache</em> como uma árvore binária. Para isso, precisamos de uma árvore binária infinita, definida em <code>InfinityTree.hs</code> como segue.</p>
<div class="sourceCode" id="cb156" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">InfinityTree</span> (<span class="dt">InfinityTree</span>(<span class="dt">Branch</span>), find) <span class="kw">where</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (==), (-), divMod,</span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Functor</span>(<span class="fu">fmap</span>), <span class="dt">Applicative</span>(<span class="fu">pure</span>, (<span class="op">&lt;*&gt;</span>)))</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">InfinityTree</span> a <span class="ot">=</span> <span class="dt">Branch</span> a (<span class="dt">InfinityTree</span> a) (<span class="dt">InfinityTree</span> a)</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">InfinityTree</span> <span class="kw">where</span></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Branch</span> x lt rt) <span class="ot">=</span> <span class="dt">Branch</span> (f x) (<span class="fu">fmap</span> f lt) (<span class="fu">fmap</span> f rt)</span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">InfinityTree</span> <span class="kw">where</span></span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Branch</span> x (<span class="fu">pure</span> x) (<span class="fu">pure</span> x)</span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Branch</span> f flt frt) <span class="op">&lt;*&gt;</span> (<span class="dt">Branch</span> x xlt xrt) <span class="ot">=</span></span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Branch</span> (f x) (flt <span class="op">&lt;*&gt;</span> xlt) (frt <span class="op">&lt;*&gt;</span> xrt)</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-19"><a href="#cb156-19" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">InfinityTree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb156-20"><a href="#cb156-20" aria-hidden="true" tabindex="-1"></a>find (<span class="dt">Branch</span> x _ _) <span class="dv">0</span> <span class="ot">=</span> x</span>
<span id="cb156-21"><a href="#cb156-21" aria-hidden="true" tabindex="-1"></a>find (<span class="dt">Branch</span> _ lt rt) n <span class="ot">=</span> cond (r <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb156-22"><a href="#cb156-22" aria-hidden="true" tabindex="-1"></a>                               (find lt q)</span>
<span id="cb156-23"><a href="#cb156-23" aria-hidden="true" tabindex="-1"></a>                               (find rt (q <span class="op">-</span> <span class="dv">1</span>)) <span class="kw">where</span></span>
<span id="cb156-24"><a href="#cb156-24" aria-hidden="true" tabindex="-1"></a>    (q, r) <span class="ot">=</span> <span class="fu">divMod</span> n <span class="dv">2</span></span></code></pre></div>
<p>A definição de <code>InfinityTree</code> representa uma árvore infinita, já que não permite folhas em sua estrutura. A única função de acesso a seus elementos é <code>find</code>, que “passeia” pela árvore conforme a paridade de um <code>Int</code> dado como entrada: um número ímpar (par) leva a busca para a esquerda (direita).</p>
<p>Com isso, podemos escrever uma versão mais eficiente de <code>memo</code>, que representa a <em>cache</em> em uma estrutura arbórea.</p>
<div class="sourceCode" id="cb157" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="ot">memo ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> b</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>memo f <span class="ot">=</span> find ftree <span class="kw">where</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    natTree <span class="ot">=</span> <span class="dt">Branch</span> <span class="dv">0</span> oddTree evenTree <span class="kw">where</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>        oddTree <span class="ot">=</span> ((<span class="op">+</span><span class="dv">1</span>) <span class="op">.</span> (<span class="op">*</span><span class="dv">2</span>)) <span class="op">&lt;$&gt;</span> natTree</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>        evenTree <span class="ot">=</span> ((<span class="op">+</span><span class="dv">2</span>) <span class="op">.</span> (<span class="op">*</span><span class="dv">2</span>)) <span class="op">&lt;$&gt;</span> natTree</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>    ftree <span class="ot">=</span> f <span class="op">&lt;$&gt;</span> natTree</span></code></pre></div>
<p>Perceba que apenas a estrutura utilizada internamente sofreu modificações. Com isso, a nova implementação de <code>memo</code> tem a mesma assinatura da anterior, e portanto nossa definição de <code>fib</code> não precisa de alterações. Vamos fazer novos testes.</p>
<div class="sourceCode" id="cb158" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.01</span> secs, <span class="dv">1</span>,<span class="dv">440</span>,<span class="dv">632</span> bytes)</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">35</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="dv">9227465</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">69</span>,<span class="dv">872</span> bytes)</span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">36</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a><span class="dv">14930352</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">240</span>,<span class="dv">064</span> bytes)</span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">36</span></span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a><span class="dv">14930352</span></span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">70</span>,<span class="dv">680</span> bytes)</span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">37</span></span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a><span class="dv">24157817</span></span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">246</span>,<span class="dv">248</span> bytes)</span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span> fib <span class="dv">37</span></span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a><span class="dv">24157817</span></span>
<span id="cb158-19"><a href="#cb158-19" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">70</span>,<span class="dv">680</span> bytes)</span>
<span id="cb158-20"><a href="#cb158-20" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Memo</span><span class="op">&gt;</span></span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 38</strong>.  <em>Verifique se existe ganho de desempenho em definir <em><code>fib</code></em> em termos de <em><code>fix2</code></em>, definida no Exercício <a href="#exercicio:fix2" data-reference-type="ref" data-reference="exercicio:fix2">Exercício 37</a>.</em></p>
</div>
<p>Isso evidencia que a nova implementação de <code>memo</code> traz algum ganho. Infelizmente, como é preciso planejar as próximas aulas, não abordaremos memoização para funções <code>a -&gt; b</code>. Isso fica para a próxima versão da disciplina.</p>
<div class="exercicio">
<p><strong>Exercício 39</strong>.  <em>Escreva uma função <em><code>decomp37 :: Int -&gt; Maybe (Int, Int)</code></em> que, dada uma entrada não-negativa <span class="math inline">\(n\)</span>, decide se existem <span class="math inline">\(x, y \in \mathbb{N}\)</span> tais que <span class="math inline">\(n = 3x + 7y\)</span>, e caso existam, retorna o par <span class="math inline">\((x, y)\)</span>. É fácil escrever essa função tirando proveito de <em><code>Maybe</code></em> ser instância de <em><code>Applicative</code></em> e <em><code>Alternative</code></em>. Use <em><code>memo</code></em> e <em><code>fix</code></em> para criar uma implementação eficiente.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 40</strong>.  <em>Escreva uma função <em><code>primeFactors :: Int -&gt; [Int]</code></em>, que retorna a decomposição em fatores primos de uma entrada não-negativa <span class="math inline">\(n\)</span>. Para facilitar, crie uma lista infinita com todos os primos. Basta encontrar o menor primo <span class="math inline">\(p\)</span> divisor de <span class="math inline">\(n\)</span> e retorná-lo como cabeça, fazendo da cauda a chamada recursiva para <span class="math inline">\(n / p\)</span>. Use <em><code>memo</code></em> e <em><code>fix</code></em> para implementar memoização em <em><code>primeFactors</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 41</strong>.  <em>Dadas moedas de <span class="math inline">\(2, 3\)</span> e <span class="math inline">\(7\)</span> centavos, vamos expressar <span class="math inline">\(x\)</span> centavos, se possível, com o menor número de moedas. A função <span class="math inline">\(f(x) = 1 + \min \{f(x - 2), f(x - 3), f(x - 7)\}\)</span> representa uma relação de recorrência que resolve esse problema. Determine os casos base e desenvolva uma função <em><code>minCoins :: Int -&gt; Maybe Int</code></em>. Note que, para valores altos de <span class="math inline">\(x\)</span>, a função <span class="math inline">\(f\)</span> é computada mais de uma vez para alguns argumentos. Use <em><code>memo</code></em> e <em><code>fix</code></em> para evitar computar <span class="math inline">\(f\)</span> mais de uma vez para o mesmo argumento. Tire proveito de <em><code>Maybe</code></em> ser <em><code>Applicative</code></em>.</em></p>
</div>
<h2 id="mônadas">Mônadas</h2>
<p>Já temos visto aplicações simples de funções, que costumam ser representadas pelo operador <code>($) :: (a -&gt; b) -&gt; a -&gt; b</code>. Vimos também aplicações de funções simples a elementos contidos em um certo contexto. Esse tipo de aplicação é representado pelo operador <code>(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>. Inclusive, quando uma estrutura de dados permite que seu conteúdo seja trnsformado por uma função simples, ela pode ser vista como uma instância de <code>Functor</code>. Por último, nos deparamos com aplicações de funções, em um certo contexto, a elementos em um contexto semelhante. Essa forma de aplicação está associada ao operador <code>(&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code>. Quando uma estrutura de dados permite que seu conteúdo seja operado por funções contidas em uma estrutura similar, ela pode ser feita uma instância de <code>Applicative</code>.</p>
<p>Agora, vamos analisar funções que produzem um contexto a partir de elementos simples. Tais funções são ditas <em>monádicas</em>, e contextos que podem ser criados a partir de elementos simples são representados por estruturas que chamamos de <em>mônadas</em>. Tais tipos são agrupados na seguinte classe.</p>
<div class="sourceCode" id="cb159" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL (&gt;&gt;=) #-}</span></span></code></pre></div>
<p>Aqui, vemos um operador que utilizamos bastante nos laboratórios. Finalmente vamos entender <code>(&gt;&gt;=)</code>!</p>
<p>Em linhas gerais, o operador <code>(&gt;&gt;=)</code> toma valores do tipo <code>a</code> contidos em <code>m a</code>, onde <code>m</code> é uma mônada, e transforma cada um deles em <code>m b</code>, produzindo uma estrutura de tipo <code>m (m b)</code>. Vale ressaltar que isso também seria possível com um <code>Functor</code>, mas <code>Functor</code> não é o bastante para lidar com esse aninhamento de contextos. Em seguida, <code>(&gt;&gt;=)</code> “combina” os contextos interno e externo, produzindo a saída de tipo <code>m b</code>.</p>
<p>Antes de entendermos essa “combinação”, vamos falar a respeito das demais funções que compõem a classe <code>Monad</code>. O operador <code>(&gt;&gt;)</code> ignora o conteúdo de <code>m a</code>, mas faz com que seu valor semântico influencie <code>m b</code>, produzindo a saída. Não há diferença entre <code>(&gt;&gt;)</code> e <code>(*&gt;)</code>. Como <code>Applicative</code> é mais abrangente que <code>Monad</code>, preferimos fazer uso de <code>(*&gt;)</code>.</p>
<p>A função <code>return</code> é equivalente a <code>pure</code>, e sua presença em <code>Monad</code> apenas cumpre o papel de não “quebrar” <em>legacy code</em>. Isso se deve a uma época em que as instâncias de <code>Monad</code> não precisavam ser instâncias de <code>Applicative</code>. Preferimos sempre o uso de <code>pure</code>, pois <code>return</code> leva esse nome para, dada a forma como é usada em <em>do notation</em>, fazer analogia ao paradigma imperativo. Por fim, a presença de <code>fail</code> em <code>Monad</code> é depreciada, e portanto a ignoramos.</p>
<p>Uma função muito importante para a concepção matemática de mônadas, mas que não faz parte de <code>Monad</code>, é <code>join :: Monad m =&gt; m (m a) -&gt; m a</code>. Dificilmente precisaremos utilizá-la para instanciar <code>Monad</code>, mas conhcê-la pode nos permitir um melhor entendimento da “combinação” de contextos. Inclusive, a única finalidade de <code>join</code> é “combinar” contextos.</p>
<p>Vamos apresentar nossa primeira mônada, fazendo com que <code>Maybe</code> instancie <code>Monad</code>. As definições que seguem devem ser escritas em <code>Maybe.hs</code>.</p>
<div class="sourceCode" id="cb160" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span></code></pre></div>
<p>Analisar uma instância de <code>Monad</code> nos permite ver com mais clareza o que faz <code>(&gt;&gt;=)</code>, e porque ele costuma ser chamado de <em>binding operator</em>. Para <code>Maybe</code>, <code>(&gt;&gt;=)</code> retorna <code>Nothing</code> tão logo seu primeiro argumento é <code>Nothing</code>, do contrário aplica seu conteúdo a <code>f</code>, produzindo a saída.</p>
<div class="exercicio">
<p><strong>Exercício 42</strong>.  <em>Faça de <em><code>Maybe</code></em> uma instância de <em><code>Monad</code></em>, definindo <em><code>(&gt;&gt;=)</code></em> como uma chamada de <em><code>maybe</code></em>.</em></p>
</div>
<p>No contexto de <code>Maybe</code>, o operador <code>(&gt;&gt;=)</code> permite a criação de uma cadeia de computações que falha quando uma de suas partes falha. Com o uso de <code>pure</code>, podemos encadear computações determinísticas, que produzem exatamente um resultado, com computações que podem falhar. Dessa forma, uma computação que produz <code>m a</code> pode ter seu resultado passado como entrada para uma computação que produz <code>m b</code>, e essa pode ser “encaixada” na entrada de uma terceira computação. Dizemos que <code>(&gt;&gt;=)</code> permite o <em>binding</em> de computações.</p>
<p>Agora, vamos ilustrar como o tipo lista instancia a classe <code>Monad</code>.</p>
<div class="sourceCode" id="cb161" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="fu">concat</span> <span class="op">$</span> f <span class="op">&lt;$&gt;</span> xs</span></code></pre></div>
<p>Podemos perceber que essa implementação de <code>(&gt;&gt;=)</code> evidencia a “combinação” de contextos, isto é, transforma uma lista de listas em uma lista simples. Primeiro, <code>f &lt;$&gt; xs</code> tem tipo <code>[[b]]</code>, e depois esse aninhamento de contextos é resolvido com <code>concat</code>. Para listas, portanto, <code>join = concat</code>.</p>
<p>Para o exercício que segue, vamos precisar da função identidade. Sua definição é escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb162" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 43</strong>.  <em>Defina <em><code>join</code></em> em termos de <em><code>(&gt;&gt;=)</code></em> e <em><code>id</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 44</strong>.  <em>Aqui, assumimos que são dadas implementações para as funções <em><code>fmap</code></em> e <em><code>join</code></em>. Escreva uma implementação para <em><code>(&gt;&gt;=)</code></em> em termos de <em><code>fmap</code></em> e <em><code>join</code></em>.</em></p>
</div>
<p>Como listas representam computações não-determinísticas, chamamos a atenção para o impacto de <code>concat</code> quando usamos <code>(&gt;&gt;=)</code> para construir uma cadeia de computações não-determinísticas. Tome, por exemplo, uma cadeia de <span class="math inline">\(k\)</span> computações não-determinísticas, em que cada uma produz dois resultados. O uso de um <code>concat</code> por <em>binding</em> vai produzir, ao final da cadeia, uma lista representando os <span class="math inline">\(2^k\)</span> resultados possíveis.</p>
<div id="exercicio:foldM" class="exercicio">
<p><strong>Exercício 45</strong>.  <em>De forma similar a <em><code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></em>, implemente a função <em><code>foldM :: Monad m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; [a] -&gt; m b</code></em>.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 46</strong>.  <em>Tome a função <em><code>f xs x = [xs, x:xs]</code></em>. Podemos interpretar <em><code>f</code></em> como uma computação não-determinística, que pode retornar tanto <em><code>xs</code></em> como <em><code>x:xs</code></em>. Reimplemente <em><code>subsets</code></em>, proposta inicialmente no Exercício <a href="#exercicio:subsets" data-reference-type="ref" data-reference="exercicio:subsets">Exercício 26</a>, como uma chamada de <em><code>foldM</code></em>.</em></p>
</div>
<p>É natural nos perguntarmos o porquê dessa tendência de Haskell interpretar estruturas como semânticas, encapsulando-as em aplicadores especiais de funções. Haskell poderia muito bem deixar mais explícita a pureza de suas funções se não usasse tal artifício, e em troca escreveríamos definições mais extensas. No entanto, é esse artifício que permite uma representação para a impureza. Vamos falar da mônada <code>IO</code>.</p>
<div class="sourceCode" id="cb163" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>info <span class="dt">IO</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IO</span> a</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">GHC.Types.IO</span> (<span class="dt">GHC.Prim.State</span><span class="op">#</span> <span class="dt">GHC.Prim.RealWorld</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">GHC.Prim.State</span><span class="op">#</span> <span class="dt">GHC.Prim.RealWorld</span>, a <span class="op">#</span>))</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Defined in &#39;GHC.Types&#39;</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IO</span> <span class="co">-- Defined in &#39;GHC.Base&#39;</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">IO</span> <span class="co">-- Defined in &#39;GHC.Base&#39;</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">IO</span> <span class="co">-- Defined in &#39;GHC.Base&#39;</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">IO</span> a) <span class="co">-- Defined in &#39;GHC.Base&#39;</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">IO</span> a) <span class="co">-- Defined in &#39;GHC.Base&#39;</span></span></code></pre></div>
<p>Não entre em pânico. Basicamente, isso significa que <code>IO a</code> encapsula uma função que, dado um estado do mundo real, retorna um (possivelmente novo) estado mundo real junto de um valor do tipo <code>a</code>. Dessa forma, não devemos esperar que, dada <code>f :: a -&gt; IO b</code>, <code>f x</code> tenha sempre o mesmo valor, uma vez que o valor contido em <code>IO b</code> depende também do estado do mundo real. Inclusive, <code>IO b</code> não apenas depende, mas pode alterar o estado do mundo real.</p>
<div class="sourceCode" id="cb164" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> f _ <span class="ot">=</span> <span class="fu">getLine</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>t f</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> p <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>t (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> f <span class="dv">1</span> <span class="op">&lt;*&gt;</span> f <span class="dv">1</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">==</span>) <span class="op">&lt;$&gt;</span> f <span class="dv">1</span> <span class="op">&lt;*&gt;</span> f <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> f <span class="dv">1</span> <span class="op">&lt;*&gt;</span> f <span class="dv">1</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>aaa</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>aaa</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> f <span class="dv">1</span> <span class="op">&lt;*&gt;</span> f <span class="dv">1</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>aaa</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>bbb</span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span></code></pre></div>
<p>Perceba que não é verdade que <code>f 1</code> é sempre igual a <code>f 1</code>. O conteúdo da <code>IO</code> que <code>f</code> retorna pode mudar, mesmo que seja usado o mesmo argumento. Mas como isso pode ser possível? As função de Haskell são puras! A função <code>f</code>, inclusive, é pura, mas seu retorno não é o valor de um tipo simples. O retorno de <code>f</code> traz consigo a semântica da impureza, representada pela mônada <code>IO</code>. Em suma, <code>f</code> é pura como qualquer outra função, mas seu retorno é impuro. É como se <code>IO</code> fosse mais uma advertência do que um tipo.</p>
<p>A necessidade prática de se trabalhar com impurezas obriga Haskell a ter uma forma de lidar com elas, do contrário Haskell seria inútil, incapaz de interagir com as coisas do mundo real (como a arquitetura de um computador). Em seus anos iniciais, havia diversas propostas de como as impurezas deveriam estar presentes em Haskell. Em algum momento houve o consenso de atribuir semântica a tipos de <em>kind</em> <code>* -&gt; *</code>, e um tipo com esse <em>kind</em> teria o papel de indicar a impureza de seu conteúdo. Assim, houve a adoção das classes <code>Functor</code>, <code>Applicative</code> e <code>Monad</code>, representando conceitos que já existiam na Matemática.</p>
<p>Como sua implementação envolve elementos de baixo nível do compilador, não podemos “abrir” <code>IO</code> da mesma forma que fazemos com <code>Maybe</code> ou listas. Aí vem a outra sacada da adoção de <code>Functor</code>, <code>Applicative</code> e <code>Monad</code>: com as funções definidas nessas classes, não precisamos “abrir” nenhuma de suas instâncias. Embora possamos “abrir” <code>Maybe</code>, é mais coveniente usar as funções de <code>Functor</code>, <code>Applicative</code> e <code>Monad</code> para tratar esse tipo. No caso de <code>IO</code>, não se trata de coveniência. Essas três classes permitem que trabalhemos com valores impuros sem nos preocupar de onde vem sua impureza, ou como tais valores são implementados. Assim, <code>IO</code> é uma espécie de mônada “mágica”, e o encapsulamento que promove permite que as definições de Haskell não se atenham a detalhes de baixo nível.</p>
<p>Agora, vamos lidar com algumas funções que nos auxiliam no tratamento de mônadas. Primeiro, definimos <code>mapM</code> em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb165" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span> f [] <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">&gt;&gt;=</span> \x&#39; <span class="ot">-&gt;</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>                <span class="fu">mapM</span> f xs <span class="op">&gt;&gt;=</span> \xs&#39; <span class="ot">-&gt;</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>                <span class="fu">pure</span>  (x&#39; <span class="op">:</span> xs&#39;)</span></code></pre></div>
<p>Nessa definição, fizemos uso de <em>funções anônimas</em>. Essencialmente, podemos definir uma função sem dá-la um nome utilizando <code>‘ </code> seguido de seus argumentos, com <code>-&gt;</code> indicando a definição da função. Por exemplo, podemos definir uma função sem dá-la um nome por meio de uma aplicação parcial, como em <code>(+1)</code>, ou através de um função anônima, como em <code>‘ x -&gt; x + 1</code>.</p>
<p>Funções anônimas são especialmente úteis para definir o segundo argumento de <code>(&gt;&gt;=)</code>. Quando <code>(&gt;&gt;=)</code> “abre” seu primeiro argumento, é interessante podermos referenciar o seu “conteúdo”. Usamos uma função anônima para receber esse “conteúdo”, e assim podemos referenciá-lo através do argumento da função. Na definição de <code>mapM</code>, existem duas funções anônimas: a primeira recebe um argumento <code>x’</code> (“conteúdo” de <code>f x</code>) e é definida como uma chamada de <code>(&gt;&gt;=)</code>; a segunda, que ocorre dentro da primeira, recebe um argumento <code>xs’</code> (“conteúdo” de <code>mapM f xs</code>) e retorna <code>x’:xs’</code> no contexto adequado. Note que, devido a essas duas funções anônimas serem aninhadas, podemos usar o argumento da primeira dentro da segunda.</p>
<p>Preferimos essa definição de <code>mapM</code>, pois com ela podemos falar de funções anônimas e evidenciá-las como um bom recurso ao utilizar-se <code>(&gt;&gt;=)</code>. Existe, no entanto, uma definição bem mais simples de <code>mapM</code>.</p>
<div id="exercicio:mapM" class="exercicio">
<p><strong>Exercício 47</strong>.  <em>Defina <em><code>mapM</code></em> em termos de <em><code>map</code></em> e <em><code>sequenceA</code></em>, proposta no Exercício <a href="#exercicio:sequenceA" data-reference-type="ref" data-reference="exercicio:sequenceA">Exercício 27</a>.</em></p>
</div>
<p>O Exercício <a href="#exercicio:mapM" data-reference-type="ref" data-reference="exercicio:mapM">Exercício 47</a> pode nos deixar pensando que <code>mapM</code> não precisa ser restrita a <code>Monad</code>, mas apenas a <code>Applicative</code>. De fato, isso é verdade. No entanto, como o primeiro argumento de <code>mapM</code> é uma função <code>a -&gt; m b</code>, uma função que cria um contexto a partir de um elemento simples, ela é restrita a <code>Monad</code> não por necessidade, mas pelo fato de receber uma função monádica.</p>
<p>Vamos definir <code>mapM‘_ :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()</code>, que ignora os resultados produzidos pela função monádica. A definição que segue deve ser escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb166" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ()</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span> f [] <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">*&gt;</span> <span class="fu">mapM_</span> f xs</span></code></pre></div>
<p>Eis uma breve ilustração do uso de <code>mapM‘_</code>.</p>
<div class="sourceCode" id="cb167" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Prelude</span> (putStrLn)</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">mapM_</span> <span class="fu">putStrLn</span> [<span class="st">&quot;aaa&quot;</span>, <span class="st">&quot;bbb&quot;</span>, <span class="st">&quot;ccc&quot;</span>]</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>aaa</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>bbb</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>ccc</span></code></pre></div>
<div class="exercicio">
<p><strong>Exercício 48</strong>.  <em>Implemente <em><code>sequenceA‘_ :: Applicative f =&gt; [f a] -&gt; f ()</code></em>, que é similar a <em><code>sequenceA</code></em>, proposta no Exercício <a href="#exercicio:sequenceA" data-reference-type="ref" data-reference="exercicio:sequenceA">Exercício 27</a>, mas ignora os resultados das computações.</em></p>
</div>
<div class="exercicio">
<p><strong>Exercício 49</strong>.  <em>Defina <em><code>mapM‘_</code></em> em termos de <em><code>sequenceA‘_</code></em> e <em><code>map</code></em>.</em></p>
</div>
<p>Após uma longa sequência de abstrações, tratamos de coisas mais concretas. Vamos lidar com aspectos da linguagem que tem impacto direto no desempenho de nossos programas.</p>
<h2 id="avaliação-estrita-e-paralelismo">Avaliação estrita e Paralelismo</h2>
<div class="epigraph">
<p>O conteúdo desta subseção é baseado no livro <em>Parallel and Concurrent Programming in Haskell</em>, de Simon Marlow.</p>
</div>
<p>Como bem sabemos, Haskell é uma linguagem de programação com avaliação preguiçosa, isto é, as definições de valores são avaliadas apenas quando esses são necessários. Podemos verificar isso.</p>
<div class="sourceCode" id="cb168" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> _</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> x</span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">2</span></span></code></pre></div>
<p>Aqui, observamos o uso de <code>:sprint</code>, um comando especial do <code>ghci</code> que não faz parte da linguagem Haskell. A função de <code>:sprint</code> é verificar o valor associado a um identificador, sem forçar sua avaliação: quando o identificador já foi avaliado, seu valor é exibido; caso contrário, exibe-se <code>‘_</code>. Percebemos, portanto, que <code>x</code> não foi avaliado assim que foi definido. Quando exibimos o valor de <code>x</code>, no entanto, ele precisa ser avaliado. Vamos tentar algo um pouco mais elaborado.</p>
<div class="sourceCode" id="cb169" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> y <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> _</span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint y</span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> _</span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">seq</span> y <span class="st">&quot;eita&quot;</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;eita&quot;</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint y</span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">3</span></span></code></pre></div>
<p>Claramente, <code>x</code> e <code>y</code> não foram avaliados assim que definidos. Vamos dizer que <code>x</code> e <code>y</code> estavam <em>suspensos</em>. Jamais chegamos a exibir os valores de <code>x</code> e <code>y</code>, e mesmo assim eles foram avaliados.</p>
<p>Isso aconteceu por conta de <code>seq :: a -&gt; b -&gt; b</code>, que faz a avaliação do segundo argumento implicar na avaliação do primeiro. Assim, quando o segundo argumento de <code>seq</code> precisa ser avaliado, a avaliação do primeiro é forçada. Apesar do que seu nome sugere, <code>seq</code> não garante que, uma vez que seja necessário avaliar o segundo argumento, o primeiro argumento seja avaliado antes (embora, na prática, isso costume acontecer). Vale ressaltar que <code>seq</code> não pode ser definida em Haskell, já que é implementada a baixo nívvel pelo compilador.</p>
<p>Utilizando <code>seq</code>, podemos criar um operador que representa a avaliação estrita em Haskell. A definição que segue deve ser escrita em <code>Functions.hs</code>.</p>
<div class="sourceCode" id="cb170" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="ot">($!) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">$!</span> x <span class="ot">=</span> <span class="fu">seq</span> x (f x)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">$!</span></span></code></pre></div>
<p>Vamos testar o nosso novo operador.</p>
<div class="sourceCode" id="cb171" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (+))</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> f _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> _</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> f x</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> _</span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> f <span class="op">$</span> x</span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb171-12"><a href="#cb171-12" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb171-13"><a href="#cb171-13" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> _</span>
<span id="cb171-14"><a href="#cb171-14" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> f <span class="op">$!</span> x</span>
<span id="cb171-15"><a href="#cb171-15" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb171-16"><a href="#cb171-16" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Functions</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint x</span>
<span id="cb171-17"><a href="#cb171-17" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">2</span></span></code></pre></div>
<p>Vemos que <code>f</code> recebe um argumento, mas o ignora e apenas retorna <code>0</code>. Assim, <code>f x</code> é avaliada sem que <code>x</code> deixe de estar suspenso. O mesmo pode ser dito de <code>f $ x</code>. Já <code>f $! x</code> usa <code>seq</code> para garantir que o argumento passado para <code>f</code> tem sua avaliação forçada assim que <code>f x</code> é requerido.</p>
<p>É necessário justificar a existência de um aplicador de função que representa avaliação estrita, ou seja, um operador que faz a avaliação do argumento ser forçada, tão logo seja forçada a chamada da função. Em resumo, a preguiça de Haskell tem um custo de espaço. De forma mais elaborada, isso quer dizer que representar um valor suspenso demanda mais memória que avaliá-lo imediatamente. É fácil entender o porquê: enquanto suspenso, o valor é representado por um <em>thunk</em>, uma estrutura de dados que guarda a referência da função que o define, assim como referências para os argumentos que devem ser passados para essa função. Essas referências podem também estar apontando para valores suspensos (lembre-se que funções, inclusive, são valores como quaisquer outros), representados por outros <em>thunks</em>. No fim das contas, um valor suspenso pode acabar sendo representado por uma estrutura arbórea, construída a partir de <em>thunks</em> que apontam para novos <em>thunks</em>.</p>
<p>Um bom estudo de caso é <code>foldl</code>, que como bem sabemos é recursiva por cauda. Isso quer dizer que <code>foldl</code> executa em espaço constante, certo? Na pilha, sim, mas não na <em>heap</em>. Como é recursiva por cauda, <code>foldl</code> tem sua chamada corrente substituida por sua chamada recursiva, nunca ocupando mais que um <em>frame</em> na pilha. No entanto, a atualização do acumulador de <code>foldl</code> fica suspensa, afinal ele só poderia ser utilizado após <code>foldl</code> atingir seu caso base. Como os <em>thunks</em> são armazenados na <em>heap</em>, o acumulador final acaba sendo representado por uma cadeia de <em>thunks</em>, localizada na <em>heap</em>. Há uma surpresa desagradável, no entanto: quando o acumulador final precisa ser avaliado, a função registrada em seu <em>thunk</em> volta para a pilha, para ser avaliada com os devidos argumentos, e ao menos um desses (o valor anterior do acumulador) está suspenso e agora precisa ser avaliado. Isso implica que a cadeia de <em>thunks</em> que <code>foldl</code> produziu na <em>heap</em> volta para a pilha, convertida agora em uma pilha de chamadas de função. Precisamos consertar <code>foldl</code>. Escrevemos a seguinte definição em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb172" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldl&#39; ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>foldl&#39; _ acc [] <span class="ot">=</span> acc</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>foldl&#39; f acc (x<span class="op">:</span>xs) <span class="ot">=</span> foldl&#39; f <span class="op">$!</span> (f acc x) <span class="op">$</span> xs</span></code></pre></div>
<p>Temos o uso de <code>($!)</code> para forçar a avaliação de <code>f acc x</code> junto com a chamada de <code>foldl’</code>. Isso faz com que <code>foldl’</code> não construa uma cadeia de <em>thunks</em>, uma vez que as atualizações do acumulador são avaliadas imediatamente, já que <code>foldl’</code> é recursiva por cauda. Preferimos sempre o uso de <code>foldl’</code> a <code>foldl</code>.</p>
<p>Vamos lidar agora com tipos parametrizados. Tome o seguinte exemplo.</p>
<div class="sourceCode" id="cb173" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> y <span class="ot">=</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> p <span class="ot">=</span> (x, y)</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint p</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> _</span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">fst</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span><span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a</span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">fst</span> p</span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint p</span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> (<span class="dv">2</span>,_)</span></code></pre></div>
<p>Assim que definido, o par <code>p</code> fica suspenso. Ao utilizarmos <code>fst</code> (a assinatura deixa claro o que ela faz), a primeira componente de <code>p</code> é avaliada. Como não foi necessário avaliar a segunda componente, <code>p</code> é avaliado parcialmente. Tome este outro exemplo.</p>
<div class="sourceCode" id="cb174" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> p <span class="ot">=</span> (x, x)</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint p</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> _</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">fst</span> p</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>sprint p</span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> (<span class="dv">2</span>,<span class="dv">2</span>)</span></code></pre></div>
<p>Observa-se que, para avaliar a primeira componente de <code>p</code>, é necessário avaliar <code>x</code>. No entanto, como as componentes de <code>p</code> são ambas referências para o <em>thunk</em> de <code>x</code>, <code>p</code> acaba sendo avaliado por completo. Vamos brincar um pouco com listas.</p>
<div class="sourceCode" id="cb175" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> _</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> f _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> f xs</span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> _</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> f <span class="op">$!</span> xs</span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> _ <span class="op">:</span> _</span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="fu">length</span> xs</span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [_,_,_,_,_,_,_,_,_,_]</span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="fu">sum</span> xs</span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a><span class="dv">65</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>]</span></code></pre></div>
<p>Nota-se que <code>xs</code>, como esperado, não é avaliada assim que definida. Logo após <code>f $! xs</code>, <code>xs</code> é parcialmente avaliada. Como <code>f</code> ignora <code>xs</code>, sabemos que a forma como <code>xs</code> foi avaliada em <code>f $! xs</code> é fruto apenas de <code>seq</code>. Isso indica que, se o primeiro argumento de <code>seq</code> é um tipo parametrizado, ela não o avalia completamente, mas apenas evidencia sua estrutura.</p>
<p>Após <code>length xs</code>, percebemos que a estrutura de <code>xs</code> é avaliada por completo, uma vez que <code>length</code> precisa decompor seu argumento e, recursivamente, sua cauda. O conteúdo de <code>xs</code>, no entanto, é avaliado apenas depois de <code>sum xs</code>.</p>
<p>Agora, vamos tratar de <code>par :: a -&gt; b -&gt; b</code>, definida em <code>Control.Parallel</code>. Assim como <code>seq</code>, <code>par</code> é definida a baixo nível. A função <code>par</code> põe a avaliação de seu primeiro argumento para ocorrer paralelamente à avaliação de seu segundo, quando essa ocorrer. Vamos ilustrar seu uso.</p>
<div class="sourceCode" id="cb176" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Parallel</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Prelude</span> (seq)</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> sum&#39; <span class="ot">=</span> foldl&#39; (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> sum&#39; [<span class="dv">1</span><span class="op">..</span><span class="dv">10000000</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> y <span class="ot">=</span> sum&#39; [<span class="dv">1</span><span class="op">..</span><span class="dv">10000000</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">seq</span> x y</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a><span class="dv">50000005000000</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>(<span class="fl">9.68</span> secs, <span class="dv">8</span>,<span class="dv">640</span>,<span class="dv">075</span>,<span class="dv">072</span> bytes)</span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> x <span class="ot">=</span> sum&#39; [<span class="dv">1</span><span class="op">..</span><span class="dv">10000000</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">0</span> bytes)</span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> y <span class="ot">=</span> sum&#39; [<span class="dv">1</span><span class="op">..</span><span class="dv">10000000</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.00</span> secs, <span class="dv">0</span> bytes)</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span> <span class="dt">Control.Parallel</span> <span class="dt">Prelude</span><span class="op">&gt;</span> par x y</span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a><span class="dv">50000005000000</span></span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>(<span class="fl">4.28</span> secs, <span class="dv">4</span>,<span class="dv">320</span>,<span class="dv">073</span>,<span class="dv">040</span> bytes)</span></code></pre></div>
<p>No exemplo acima, <code>seq x y</code> força a avaliação de <code>x</code> assim que a de <code>y</code> é forçada. Como <code>y</code> é o retorno de <code>seq x y</code>, e esse é exibido no terminal, a avaliação de <code>x</code> precisa também ser feita, já que a de <code>y</code> é forçada. No caso de <code>par x y</code>, a avaliação de <code>x</code> ocorre simultaneamente a de <code>y</code>. Isso não é toda a explicação da redução de tempo apresentada.</p>
<p>É preciso esclarecer algo: se o processador que rodou o exemplo acima tivesse apenas um <em>core</em>, as avaliações de <code>x</code> e <code>y</code> seriam feitas em simultâneo, mas iriam concorrer pelo uso do único <em>core</em>, e daí não haveria redução de tempo. No entanto, o <code>ghc</code> é esperto o bastante para distribuir o trabalho em paralelo de forma equilibrada entre os <em>cores</em>. Usamos o comando <code>lscpu</code> para saber as características de nosso processador.</p>
<div class="sourceCode" id="cb177" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> lscpu</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Arquitetura</span><span class="op">:</span>                x86_64</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Modo</span>(s) operacional da <span class="dt">CPU</span><span class="op">:</span> <span class="dv">32</span><span class="op">-</span>bit, <span class="dv">64</span><span class="op">-</span>bit</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Ordem</span> dos bytes<span class="op">:</span>            <span class="dt">Little</span> <span class="dt">Endian</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Tamanhos</span> de endereco<span class="op">:</span>       <span class="dv">39</span> bits physical, <span class="dv">48</span> bits virtual</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="dt">CPU</span>(s)<span class="op">:</span>                     <span class="dv">4</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Lista</span> de <span class="dt">CPU</span>(s) on<span class="op">-</span>line<span class="op">:</span>    <span class="dv">0</span><span class="op">-</span><span class="dv">3</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Thread</span>(s) per nucleo<span class="op">:</span>       <span class="dv">2</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Nucleo</span>(s) por soquete<span class="op">:</span>      <span class="dv">2</span></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Soquete</span>(s)<span class="op">:</span>                 <span class="dv">1</span></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Vamos entender a parte que nos importa da saída de <code>lscpu</code>: o sistema operacional “enxerga” quatro CPU’s; um pouco abaixo, vemos que há dois <em>cores</em> no processador, cada um com duas <em>threads</em>. O sistema operacional nos diz que as quatro <em>threads</em> do processador são CPU’s. No entanto, cada par de <em>threads</em> disputa os recursos de um mesmo <em>core</em>. Daí, o número de trabalhos que esse processador consegue executar verdadeiramente em paralelo não é o número de CPU’s, mas o número de <em>cores</em>. Isso significa que, nesse processador, fazer uso de paralelismo nos traria um fator de redução de tempo limitado por <span class="math inline">\(2\)</span>. Chamamos esse fator de <em>speedup</em>.</p>
<p>No entanto, há tecnologias de certos processadores que podem distorcer a noção básica de <em>speedup</em>. Por exemplo, é possível estruturar um <em>core</em> de tal forma que as <em>threads</em> que o dividem, quando executando certos tipos de operação, concorram minimamente pelos recursos do <em>core</em>. Assim, o <em>speedup</em> poderia, na prática, ter um limite um pouco menor que o número de <em>threads</em>.</p>
<p>Junto de <code>par</code>, <code>Control.Parallel</code> também define <code>pseq :: a -&gt; b -&gt; b</code>. Além do comportamento herdado de <code>seq</code>, <code>pseq</code> assegura que a avaliação de seu primeiro argumento vai ocorrer necessariamente antes da avaliação de seu segundo. Essa diferença sutil entre <code>seq</code> e <code>pseq</code> permite um maior controle quando paralelizamos nosso código.</p>
<p>Para entender a necessidade de <code>pseq</code>, devemos estar cientes de que Haskell deixa em aberto a ordem de avaliação das partes de uma expressão. Isso é sensato, inclusive, já que uma expressão simples (sem a semântica de impureza) deve ter o mesmo valor, independente da ordem em que suas partes são avaliadas. Postergar a escolha de uma ordem pode abrir algumas oportunidades de otimizar o código. Uma preocupação a menos para o programador, certo? Em aplicações de execução serial, sim.</p>
<p>Tomemos um exemplo bem simples: <code>x + y</code>. Quando da avaliação de <code>x + y</code>, o compilador não nos dá garantias de quem será avaliado primeiro: <code>x</code> ou <code>y</code>. Para o resultado dessa soma, a ordem de avaliação de fato não importa. Mas e quanto a <code>par x (x + y)</code>?</p>
<p>Quando escreve-se <code>par x (x + y)</code>, a intenção é que <code>x</code> seja avaliado paralelamente a <code>x + y</code>, e assim poderia haver ganho de desempenho: caso a avaliação de <code>x + y</code> comece por <code>y</code>, temos ganho; caso comece por <code>x</code>, temos feito em vão a avaliação de <code>x</code> em paralelo, já que essa acaba sendo feita duas vezes. Assim, apenas o uso de <code>par</code> nos entrega o risco de gastar o tempo de um <em>core</em> com trabalho redundante.</p>
<p>Vamos analisar <code>par x (pseq y (x + y))</code>. Aqui, a avaliação de <code>x</code> é feita em paralelo com a avaliação de <code>pseq y (x + y)</code>, e essa força a avaliação de <code>y</code> a ocorrer antes da avaliação de <code>x + y</code>. Assim, temos que, quando <code>x + y</code> for avaliado, <code>y</code> já deve ter sido avaliada, assim como <code>x</code>, que deve ter sido avaliado em paralelo. Vemos, pois, que o uso de <code>pseq</code> para controlar a ordem de avaliação de expressões nos permite fazer avaliações em paralelo que não serão redundantes.</p>
<p>No caso de <code>x + y</code>, sabemos que <code>x</code> e <code>y</code> são tipos numéricos, o que indica que eles devem ser avaliados por completo. Mas quando se toma algo como <code>xs ++ ys</code>, em que <code>xs</code> e <code>ys</code> são duas listas, o uso de <code>seq</code> e <code>pseq</code> poderia forçar apenas uma avaliação superficial desses valores. Assim, uma simples combinação de <code>par</code> e <code>pseq</code> poderia apenas determinar, em paralelo, se <code>xs</code> é vazia ou tem cabeça e cauda. Isso faria quase nenhum trabalho ser feito em paralelo. Para remediar essa situação, vamos criar uma função que força a avaliação completa de uma lista. A definição a seguir deve ficar em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb178" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="ot">force ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>force [] <span class="ot">=</span> []</span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>force l<span class="op">@</span>(x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">seq</span> x (<span class="fu">seq</span> (force xs) l)</span></code></pre></div>
<p>Vamos entender o que <code>force</code> está fazendo. A chamada mais externa de <code>seq</code> garante que seu primeiro argumento (a cabeça de <code>l</code>) vai ser avaliada quando seu segundo argumento for avaliado. Esse segundo argumento é outra chamada de <code>seq</code>, e essa garante que <code>force xs</code> vai ser avaliada quando <code>l</code> for avaliada. Isso quer dizer que, quando <code>l</code> for avaliada, serão avaliadas tanto sua cabeça como sua cauda, e essa última de forma recursiva. Vale ressaltar que <code>force</code> não cria novas listas, uma vez que sempre retorna a mesma referência que recebe. Testamos o comportamento de <code>force</code>.</p>
<div class="sourceCode" id="cb179" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="fu">head</span> xs</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> _</span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> ys <span class="ot">=</span> force xs</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="fu">head</span> ys</span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint ys</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>ys <span class="ot">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>]</span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">List</span><span class="op">&gt;</span> <span class="op">:</span>sprint xs</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>]</span></code></pre></div>
<p>Com <code>force</code> em mãos, estamos aptos a processar listas em paralelo, com a certeza de que essas serão avaliadas por completo. Com a próxima ferramenta, poderemos “quebrar” uma lista em “pedaços” iguais. Essa definição deve ficar em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb180" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chunks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>chunks _ [] <span class="ot">=</span> []</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>chunks k xs <span class="ot">=</span> ps <span class="op">:</span> chunks k qs <span class="kw">where</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    (ps, qs) <span class="ot">=</span> <span class="fu">splitAt</span> k xs</span></code></pre></div>
<p>A essa altura, a definição de <code>chunks</code> não deve ser difícil de entender. Está claro que <code>chunks k xs</code> retorna <code>xs</code> dividida em partes, todas (talvez não a última) com <code>k</code> elementos.</p>
<p>Usando <code>chunks</code> e <code>force</code>, podemos criar uma estratégia para paralelizar a avaliação de uma lista. Vamos supor que a lista <code>xs</code> tem muitos elementos, e todos eles são caros de avaliar. Definimos, inicialmente, <code>ys = concat $ chunks 10 xs</code>, supondo que avaliar um grupo de <code>10</code> elementos de <code>xs</code> é custoso o bastante. Claramente, <code>xs == ys</code>, mas <code>ys</code> oferece uma oportunidade evidente de paralelismo. Poderíamos fazer com que a avaliação de cada um dos “pedaços” de <code>xs</code> ocorresse em paralelo. A definição que segue deve ser escrita em <code>List.hs</code>.</p>
<div class="sourceCode" id="cb181" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parChunks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>parChunks k <span class="ot">=</span> parallel <span class="op">.</span> chunks k <span class="kw">where</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    parallel [] <span class="ot">=</span> []</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    parallel l<span class="op">@</span>(xs<span class="op">:</span>xss) <span class="ot">=</span> par (force xs) (pseq (parallel xss) l)</span></code></pre></div>
<p>Vamos explicar o que <code>parChunks</code> está fazendo. Primeiro, <code>chunks</code> “quebra” a lista em diversas partes, e em seguida <code>parallel</code> força a avaliação de cada uma delas em paralelo: a chamada de <code>par</code> faz com que a avaliação de <code>force xs</code> ocorra paralelamente à avaliação de <code>pseq (parallel xss) l</code>, e essa garante que a avaliação de <code>parallel xss</code> (que vai forçar os demais “pedaços” em paralelo) vai ser feita antes da avaliação de <code>l</code>.</p>
<p>Em vez de <code>ys = concat $ chunks 10 xs</code>, usamos <code>ys = concat $ parChunks 10 xs</code>, que força a avaliação de cada “pedaço” de <code>xs</code> em paralelo, antes de concatená-los. Esse <code>10</code> que utilizamos é apenas ilustrativo. É preciso fazer testes com diversos valores para esse parâmetro, e assim descobrir qual valor traz o maior ganho de tempo. Vamos aplicar essa ideia em um exemplo bem artificial.</p>
<div class="sourceCode" id="cb182" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (+), (^), <span class="dt">IO</span>, print)</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a><span class="ot">sum&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>sum&#39; <span class="ot">=</span> foldl&#39; (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> [<span class="dt">Int</span>]</span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [sum&#39; [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span><span class="dv">9</span>], sum&#39; [<span class="dv">2</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span><span class="dv">9</span>], sum&#39; [<span class="dv">3</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span><span class="dv">9</span>], sum&#39; [<span class="dv">4</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span><span class="dv">9</span>]]</span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a><span class="ot">ys ::</span> [<span class="dt">Int</span>]</span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a>ys <span class="ot">=</span> <span class="fu">concat</span> (parChunks <span class="dv">1</span> xs)</span>
<span id="cb182-15"><a href="#cb182-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-16"><a href="#cb182-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb182-17"><a href="#cb182-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> ys</span></code></pre></div>
<p>Como <code>xs</code> tem quatro elementos, <code>parChunks 1 xs</code> cria quatro trabalhos paralelos para avaliar <code>xs</code>. Criamos um arquivo <code>Test.hs</code> com essas definições. Vamos compilar esse arquivo com o seguinte comando.</p>
<div class="sourceCode" id="cb183" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="op">-</span><span class="dt">O2</span> <span class="op">-</span>threaded <span class="dt">Test</span> <span class="op">-</span><span class="dt">W</span></span></code></pre></div>
<p>Esse comando faz o compilador gerar código muito otimizado (<code>-O2</code>), e acoplar um <em>runtime system</em> (<code>-threaded</code>), que gerencia os trabalhos feitos em paralelo. Agora, realizamos alguns testes com o executável criado.</p>
<div class="sourceCode" id="cb184" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> time <span class="op">./</span><span class="dt">Test</span> <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N1</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">500000000500000000</span>,<span class="dv">500000000499999999</span>,<span class="dv">500000000499999997</span>,<span class="dv">500000000499999994</span>]</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>real    0m39,523s</span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>user    0m38,978s</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>sys 0m0,530s</span></code></pre></div>
<p>Primeiro, <code>time</code> mede o tempo de execução do comando que vem em seguida. O tempo <code>real</code> é o tempo real de execução do programa, enquanto <code>user</code> e <code>sys</code> indicam, respectivamente, quanto tempo o processo gastou rodando código de usuário e código do <em>kernel</em>.</p>
<p>A chamada do executável <code>Test</code> apresenta o parâmetro <code>+RTS</code>, que indica que os parâmetros seguintes dizem respeito ao <em>runtime system</em>. O único parâmetro que vem depois de <code>+RTS</code> é <code>-N1</code>, que instrui o <em>runtime system</em> a distribuir todos os trabalhos em uma <em>thread</em>. Assim, mesmo fazendo uso de paralelismo, <code>-N1</code> não nos permite ter ganhos, pois mesmo as avaliações paralelizadas são realizadas todas pela mesma <em>thread</em>, e portanto não ocorrem de forma simultânea. Vamos tentar <code>-N2</code>.</p>
<div class="sourceCode" id="cb185" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> time <span class="op">./</span><span class="dt">Teste</span> <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N2</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">500000000500000000</span>,<span class="dv">500000000499999999</span>,<span class="dv">500000000499999997</span>,<span class="dv">500000000499999994</span>]</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>real    0m33,065s</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>user    0m44,820s</span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>sys 0m1,494s</span></code></pre></div>
<p>A primeira coisa que notamos é uma redução de tempo bem pequena, de <span class="math inline">\(39,523\)</span> para <span class="math inline">\(33,065\)</span> segundos, resultando em um <em>speedup</em> de quase <span class="math inline">\(1,2\)</span>. O <em>speedup</em> aqui obtido passou longe de <span class="math inline">\(2\)</span>, e para o nosso processador, esse deve ser o limite teórico de <em>speedup</em>. Não adianta testar os parâmetros de <code>-N3</code> em diante, pois pelo menos duas <em>threads</em> concorreriam pelos recursos de um mesmo <em>core</em>.</p>
<p>Há uma observação interessante a ser feita sobre os tempos <code>user</code> e <code>sys</code>. No primeiro teste, a soma de <code>user</code> e <code>sys</code> é bastante próxima de <code>real</code>. No segundo teste, porém, essa soma ultrapassa <code>real</code>. Isso ocorre porque <code>user</code> e <code>sys</code> acumulam os devidos tempos de cada uma das <em>threads</em>.</p>
<p>Vamos fazer uma modificação em <code>Test.hs</code>. Substituimos a expressão <code>parChunks 1 xs</code> por <code>parChunks 2 xs</code>, fazendo <code>xs</code> ser avaliada, dessa vez, por dois trabalhos paralelos. Recompilamos <code>Test.hs</code> e voltamos aos testes.</p>
<div class="sourceCode" id="cb186" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> time <span class="op">./</span><span class="dt">Teste</span> <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N1</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">500000000500000000</span>,<span class="dv">500000000499999999</span>,<span class="dv">500000000499999997</span>,<span class="dv">500000000499999994</span>]</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>real    0m39,544s</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>user    0m39,056s</span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>sys 0m0,470s</span></code></pre></div>
<p>Esse novo teste nos tomou quase o mesmo tempo de execução que o primeiro teste. Vamos testar com <code>-N2</code>.</p>
<div class="sourceCode" id="cb187" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a> time <span class="op">./</span><span class="dt">Teste</span> <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N2</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">500000000500000000</span>,<span class="dv">500000000499999999</span>,<span class="dv">500000000499999997</span>,<span class="dv">500000000499999994</span>]</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>real    0m21,273s</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>user    0m41,760s</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>sys 0m0,646s</span></code></pre></div>
<p>Agora sim! A redução de tempo foi de 39,544 para 21,273 segundos, o que nos dá um <em>speedup</em> um pouco maior que <span class="math inline">\(1,85\)</span>. Esse <em>speedup</em> está bem mais próximo do limite teórico de <span class="math inline">\(2\)</span>. Novamente, não faz sentido usar mais <em>threads</em> do que o número de <em>cores</em>. Com esses dois grupos de experimentos, observamos o impacto que o parâmetro de <code>parChunks</code> tem sobre o <em>speedup</em> que podemos atingir.</p>
<p>Nosso pequeno exemplo artificial pode deixar a impressão de que a escolha do parâmetro de <code>parChunks</code> deve ser tal que haja exatamente um “pedaço” da lista para cada <em>core</em> avaliar. Embora plausível, essa escolha não nos dá escalabilidade. Isso quer dizer que, se prepararmos um programa para tirar proveito de um certo número de <em>cores</em>, ele precisará ser modificado para executar eficientemente em outro número de <em>cores</em>.</p>
<p>Quanto maiores os “pedaços” em que partimos a lista, maiores serão os trabalhos a serem realizados em paralelo. Para haver um bom ganho de tempo com paralelismo, é necessário que os trabalhos paralelizados sejam custosos a ponto de compensar o <em>overhead</em> introduzido pelo <em>runtime system</em>. O parâmetro ideal de <code>parChunks</code> varia conforme a natureza das tarefas que se está paralelizando. Geralmente, descobrir esse valor ideal requer alguma experimentação.</p>
<h1 id="laboratórios">Laboratórios</h1>
<p>Aqui se encontram as atividades a serem desenvolvidas durante as aulas práticas. Cada subseção corresponde a uma aula em laboratório.</p>
<h2 id="laboratório-1">Laboratório 1</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab1.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb188" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Lab1</span> <span class="kw">where</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Eq</span>, (+), (*), <span class="dt">Int</span>)</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span>(foldl, foldr)</span></code></pre></div>
<ol>
<li><p>Reescreva as funções <code>length</code>, <code>(++)</code>, <code>concat</code> e <code>reverse</code> como chamadas de <code>foldl</code> ou <code>foldr</code> (a que parecer mais adequada). Transcreva essas novas definições para <code>List.hs</code>.</p></li>
<li><p>Escreva a função <code>squares</code> que, dada uma lista de inteiros, retorna uma lista contendo o quadrado desses inteiros.</p></li>
<li><p>Escreva a função <code>count :: Eq a =&gt; a -&gt; [a] -&gt; Int</code>, que retorna o número de ocorrências de um elemento em uma lista. Além de deixá-la em <code>Lab1.hs</code>, copie essa função para <code>List.hs</code>.</p></li>
</ol>
<h2 id="lab2">Laboratório 2</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab2.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb189" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Lab2</span> <span class="kw">where</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span>(<span class="dt">Eq</span>, <span class="dt">Fractional</span>, (/))</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span></code></pre></div>
<ol>
<li><p>Escreva a função <code>repeat :: a -&gt; [a]</code> que, dado um elemento <code>x</code> de tipo <code>a</code>, retorna uma lista infinita cujos elementos são todos iguais a <code>x</code>.</p></li>
<li><p>Escreva a função <code>cycle :: [a] -&gt; [a]</code> que, dada uma lista <code>xs</code> como entrada, retorna uma lista infinita formada por repetir continuamente os elementos de <code>xs</code>, em ordem. Desejamos que <code>cycle [] == []</code>.</p></li>
<li><p>Escreva a função <code>intercalate :: a -&gt; [a] -&gt; [a]</code> que, dado um elemento <code>x</code> e uma lista <code>ys</code>, retorna uma lista que consiste dos elementos de <code>ys</code> intercalados por <code>x</code>. Desejamos que <code>intercalate _ [] == []</code> e <code>intercalate _ [y] == [y]</code>, pois nesses casos <code>ys</code> não tem elementos a serem intercalados por <code>x</code>.</p></li>
<li><p>Escreva a função <code>safeDiv :: (Eq a, Fractional a) =&gt; a -&gt; a -&gt; Maybe a</code> que faz divisões de forma segura, isto é, representa a divisão por zero como uma falha.</p></li>
<li><p>Escreva uma implementação para <code>find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a</code>. Perceba que é possível implementar <code>find</code> utilizando composições de <code>dropWhile</code>, <code>safeHead</code> e <code>not</code>. Essa é apenas uma sugestão. Implemente como achar mais adequado.</p></li>
</ol>
<h2 id="lab3">Laboratório 3</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab3.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb190" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Lab3</span> <span class="kw">where</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Ord</span>, (&lt;=), <span class="dt">Eq</span>, (==), <span class="dt">Bool</span>(<span class="dt">True</span>, <span class="dt">False</span>))</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span></code></pre></div>
<ol>
<li><p>Implemente a função <code>group :: Eq a =&gt; [a] -&gt; [[a]]</code>, que recebe uma lista <code>xs</code> e retorna uma lista de listas, onde cada sublista é uma subsequência contínua maximal de elementos iguais de <code>xs</code>. Por exemplo, <code>group [1, 1, 2, 2, 2, 3, 3, 1, 1, 1] == [[1, 1], [2, 2, 2], [3, 3], [1, 1, 1]]</code>. A função <code>span</code> pode ser de grande ajuda aqui.</p></li>
<li><p>Agora, generalizamos a função <code>group</code> como <code>groupBy</code>, fazendo com que <code>group</code> seja equivalente a <code>groupBy (==)</code>. Implemente <code>groupBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [[a]]</code>.</p></li>
<li><p>Implemente as funções <code>all</code> e <code>any</code>, ambas com assinatura <code>(a -&gt; Bool) -&gt; [a] -&gt; Bool</code>, que decidem, respectivamente, se todos ou algum elemento de uma lista satisfazem o predicado dado como entrada. Perceba que elas podem ser dadas como composições de <code>and</code>, <code>or</code> e <code>map</code>.</p></li>
<li><p>Escreva a função <code>merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]</code> que, dadas duas listas ordenadas como entrada, retorna uma lista ordenada com todos os elementos das listas recebidas.</p></li>
<li><p>Escreva a função <code>split :: [a] -&gt; ([a], [a])</code> que, dada uma lista <code>xs</code> como entrada, retorna duas listas: a primeira contém os elementos das posições ímpares de <code>xs</code>, e a segunda os elementos das posições pares de <code>xs</code>. Aqui, estamos admitindo que a cabeça de uma lista está na posição 1.</p></li>
<li><p>Agora, utilizando <code>merge</code> e <code>split</code>, implementadas anteriormente, desenvolva a função <code>mergesort :: Ord a =&gt; [a] -&gt; [a]</code>.</p></li>
</ol>
<h2 id="lab4">Laboratório 4</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab4.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb191" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Eq</span>, (==), (/=),</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Int</span>, (<span class="op">+</span>), <span class="dt">Char</span>,</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, <span class="fu">readFile</span>, <span class="fu">putStrLn</span>, <span class="fu">show</span>,</span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>                (<span class="op">&gt;&gt;=</span>), <span class="fu">pure</span>)</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">BSTree</span> <span class="kw">as</span> <span class="dt">BST</span></span></code></pre></div>
<p>Para esse laboratório, vamos utilizar o arquivo auxiliar <code>heyjude.txt</code>, que contém a letra da referida música. Como você deve ter notado, o arquivo <code>Lab4.hs</code> contém um módulo chamado <code>Main</code>. Isso indica que vamos criar um executável <code>Lab4</code>. Para informações sobre como compilar um programa em Haskell, veja a Subseção <a href="#subsec:compiling" data-reference-type="ref" data-reference="subsec:compiling">3.7</a>.</p>
<p>As atividades a seguir devem ser um guia para o desenvolvimento de um programa que imprime a contagem da ocorrência de palavras no arquivo <code>heyjude.txt</code>.</p>
<ol>
<li><p>Escreva a função <code>remove :: Eq a =&gt; a -&gt; [a] -&gt; [a]</code>, que remove todas as ocorrências de um certo elemento em uma lista. Perceba que <code>remove</code> pode ser implementada como uma chamada de <code>filter</code>.</p></li>
<li><p>Escreva a função <code>split :: Eq a =&gt; a -&gt; [a] -&gt; [[a]]</code> que, dados um elemento <code>x</code> e uma lista <code>ys</code>, retorna as sublistas de <code>ys</code> entre as ocorrências de <code>x</code>. Por exemplo, <code>split 0 [0, 1, 2, 0, 2, 5, 7, 0, 0, 0, 3, 0] == [[1, 2], [2, 5, 7], [3]]</code>. As funções <code>span</code> e <code>dropWhile</code> são bastante úteis aqui.</p></li>
<li><p>Utilize a função <code>split</code> para escrever as funções <code>lines</code> e <code>words</code>, ambas com assinatura <code>[Char] -&gt; [[Char]]</code>. A função <code>lines</code> (<code>words</code>) deve particionar uma string em substrings que representem suas linhas (palavras). Lembre-se que linhas são separadas por <code>’‘ n’</code> e palavras por <code>’ ’</code>.</p></li>
<li><p>Escreva a função <code>count :: [[Char]] -&gt; BST.BSTree [Char] Int</code> que, dada uma lista de strings, retorna uma árvore binária de busca onde as chaves são essas strings e cada uma é valorada pelo número de vezes que ocorre na lista. As funções <code>foldr</code>, <code>BST.empty</code>, <code>BST.contains</code>, <code>BST.insert</code> e <code>BST.update</code> são muito úteis para isso.</p></li>
<li><p>Vamos desenvolver a função <code>process :: [Char] -&gt; [Char]</code>, que junta todas as partes do nosso programa. Essencialmente, <code>process</code> vai limpar a string de entrada, removendo caracteres indesejáveis, contar a ocorrência das palavras e em seguida preparar a saída do programa, que é seu retorno. Podemos decompor <code>process</code> nessas três partes.</p>
<div class="sourceCode" id="cb192" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> makeOutput <span class="op">.</span> countWords <span class="op">.</span> clean <span class="kw">where</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    clean <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>    countWords <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    makeOutput <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="op">.</span> <span class="fu">map</span> f <span class="op">.</span> BST.inOrder</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    f (str, c) <span class="ot">=</span> str <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> <span class="fu">show</span> c</span></code></pre></div>
<p>Escreva implementações para <code>clean</code> e <code>countWords</code>. A função <code>clean</code> deve remover os caracteres <code>’,’</code>, <code>’(’</code>, <code>’)’</code>, <code>’?’</code> e <code>’!’</code>, e isso pode ser feito com uma composição de <code>remove</code>s. A função <code>countWords</code> deve construir a árvore com a contagem de ocorrência das palavras, e isso pode ser expresso como uma composição das funções <code>lines</code>, <code>words</code>, <code>map</code>, <code>concat</code> e <code>count</code>.</p></li>
<li><p>Com todas as funções desenvolvidas, estamos aptos a finalizar nosso programa. Nossa <code>main</code> (que não pode ser totalmente explicada agora) é apresentada a seguir.</p>
<div class="sourceCode" id="cb193" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">readFile</span> <span class="st">&quot;heyjude.txt&quot;</span> <span class="op">&gt;&gt;=</span> <span class="fu">pure</span> <span class="op">.</span> process <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>Agora, basta compilar <code>Lab4.hs</code> e conferir a saída do executável.</p></li>
</ol>
<h2 id="laboratório-5">Laboratório 5</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab5.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb194" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Eq</span>, (==), (/=),</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Int</span>, (<span class="op">+</span>), <span class="dt">Char</span>,</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, <span class="fu">readFile</span>, <span class="fu">putStrLn</span>, <span class="fu">show</span>,</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>                (<span class="op">&gt;&gt;=</span>), <span class="fu">pure</span>)</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">BSTree</span> <span class="kw">as</span> <span class="dt">BST</span></span></code></pre></div>
<p>Vamos criar um programa ligeiramente diferente do criado na Subseção <a href="#lab4" data-reference-type="ref" data-reference="lab4">4.4</a>. Em vez de imprimir as palavras em ordem alfabética, vamos imprimí-las em ordem decrescente de frequência, isto é, as palavras com maior número de ocorrências serão impressas primeiro.</p>
<p>Para tanto, é preciso criar uma função auxiliar <code>sortBy</code>, que ordena uma lista de acordo com um comparador, também dado como entrada. Basta generalizar <code>mergesort</code>, proposta na Subseção <a href="#lab3" data-reference-type="ref" data-reference="lab3">4.3</a>.</p>
<p>Descobrindo-se o comparador adequado para produzir a ordenação desejada, uma simples alteração no programa da Subseção <a href="#lab4" data-reference-type="ref" data-reference="lab4">4.4</a> é suficiente para concluir esse laboratório. Com isso, esperamos evidenciar o reuso obtido quando expressamos programas funcionais por meio de composições.</p>
<p>Esta subseção se encontra escrita em um estilo distinto das anteriores por uma razão. Aqui, queremos também avaliar a capacidade de conceber assinaturas e tipos para as funções, em vez de apenas criá-las a partir de assinaturas pré-determinadas.</p>
<h2 id="laboratório-6">Laboratório 6</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab6.hs</code>. Seu conteúdo inicial deve ser o seguinte.</p>
<div class="sourceCode" id="cb195" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Char</span>, <span class="dt">Bool</span>(<span class="dt">False</span>), pure, (&gt;&gt;=),</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, <span class="fu">readFile</span>, <span class="fu">putStrLn</span>, <span class="fu">read</span>, <span class="fu">show</span>)</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Graph</span> <span class="kw">as</span> <span class="dt">G</span></span></code></pre></div>
<p>Vamos trabalhar com grafos. Em particular, vamos desenvolver um programa que resolve o Problema da Celebridade, um clássico das maratonas de programação.</p>
<p>Dado um grafo <span class="math inline">\(G = (V, E)\)</span>, dizemos que um vértice <span class="math inline">\(v \in V\)</span> é uma celebridade se todo outro vértice “conhece” <span class="math inline">\(v\)</span> e <span class="math inline">\(v\)</span> “conhece” ninguém. Perceba que um grafo tem no máximo uma celebridade. Aqui, estamos usando “<span class="math inline">\(u\)</span> conhece <span class="math inline">\(v\)</span>” para indicar a existência da aresta <span class="math inline">\((u, v) \in E\)</span>.</p>
<p>Para começar, nossa <code>main</code> será como nos outros laboratórios.</p>
<div class="sourceCode" id="cb196" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">readFile</span> <span class="st">&quot;g1.txt&quot;</span> <span class="op">&gt;&gt;=</span> <span class="fu">pure</span> <span class="op">.</span> process <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>No entanto, o arquivo <code>g1.txt</code> contém a codificação de um grafo, em vez de um conteúdo arbitrário. Sua primeira linha contém um inteiro, indicando o número de vértices. As demais linhas contêm exatamente dois inteiros, indicando as extremidades das arestas.</p>
<p>Nossa função <code>process</code> tem quatro etapas: dividir o conteúdo do arquivo por linhas, construir o grafo correspondente, resolver o Problema da Celebridade e produzir a saída.</p>
<div class="sourceCode" id="cb197" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> makeOutput <span class="op">.</span> hasCelebrity <span class="op">.</span> buildGraph <span class="op">.</span> <span class="fu">lines</span></span></code></pre></div>
<p>Para que possamos nos concentrar no problema em si, eis a definição de <code>buildGraph</code>.</p>
<div class="sourceCode" id="cb198" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildGraph ::</span> [[<span class="dt">Char</span>]] <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>buildGraph [] <span class="ot">=</span> G.empty</span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>buildGraph (n<span class="op">:</span>es) <span class="ot">=</span> <span class="fu">foldr</span> f gn es&#39; <span class="kw">where</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>    es&#39; <span class="ot">=</span> <span class="fu">map</span> <span class="fu">words</span> es</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>    gn <span class="ot">=</span> G.edgeless (<span class="fu">read</span> n)</span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>    f e g <span class="ot">=</span> G.addEdge g u v <span class="kw">where</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>        (u<span class="op">:</span>v<span class="op">:</span>_) <span class="ot">=</span> <span class="fu">map</span> <span class="fu">read</span> e</span></code></pre></div>
<p>Note que, nesse contexto, <code>read</code> consegue inferir o tipo de seu retorno. Isso é possível por conta das assinaturas das funções que estão em <code>Graph.hs</code>.</p>
<p>Em um primeiro momento, podemos supor que <code>makeOutput = show</code>. Assim, o retorno booleano de <code>hasCelebrity</code> é impresso na tela, indicando se o grafo tem uma celebridade. Obviamente, é mais útil dizer qual é a celebridade, caso haja alguma. No entanto, esse improviso nos deixa apenas com <code>hasCelebrity</code> indefinida.</p>
<div class="sourceCode" id="cb199" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hasCelebrity ::</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>hasCelebrity g <span class="ot">=</span> verify candidate <span class="kw">where</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    verify <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>    candidate <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Vamos utilizar uma solução bem simples para o problema. Como um grafo tem no máximo uma celebridade, em um primeiro momento queremos encontrar um vértice candidato a celebridade. Isso pode ser feito com uma pilha, e as listas cumprem esse papel. Colocamos todos os vértices em uma pilha. Se há pelo menos dois vértices na pilha, digamos <span class="math inline">\(u\)</span> e <span class="math inline">\(v\)</span>, verificamos se a aresta <span class="math inline">\((u, v)\)</span> existe: caso exista, <span class="math inline">\(u\)</span> “conhece” alguém e não pode ser uma celebridade; caso contrário, <span class="math inline">\(v\)</span> não é “conhecido” por um outro vértice e não pode ser celebridade. Em ambos os casos, eliminamos um vértice e o outro volta para a pilha. Quando tivermos um único vértice na pilha, esse será nosso candidato. Precisamos retornar o candidato dentro de um <code>Maybe</code>, para podermos tratar o caso da pilha (lista) vazia.</p>
<p>Uma vez determinado o candidato, caso haja algum, a função <code>verify</code> testa as condições de celebridade para ele.</p>
<div class="sourceCode" id="cb200" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>verify <span class="ot">=</span> <span class="fu">maybe</span> <span class="dt">False</span> f <span class="kw">where</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    f c <span class="ot">=</span> <span class="fu">and</span> [cond1, <span class="fu">not</span> cond2] <span class="kw">where</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    cond1 <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>    cond2 <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Nessa definição, <code>maybe</code> nos poupa de tratar explicitamente os casos de <code>Maybe</code>. O valor <code>cond1</code> indica se todos os outros vértices “conhecem” o candidato, enquanto <code>cond2</code> indica se o candidato “conhece” algum outro vértice. As funções <code>and</code>, <code>or</code>, <code>zipWith</code>, <code>G.hasEdge</code>, <code>repeat</code> e <code>remove</code> são úteis para definí-los.</p>
<p>Aqui, o executável já deve estar pronto. Teste-o, modificando o conteúdo de <code>g1.txt</code> para isso. Uma vez seguro do comportamento do programa, altere-o para que a celebridade (caso haja uma) seja exibida como saída.</p>
<h2 id="laboratório-7">Laboratório 7</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab7.hs</code>. Antes de abordar nosso objetivo primário, vamos criar uma variante de <code>Heap.hs</code>.</p>
<p>Baseado na estrutura definida em <code>Heap.hs</code>, crie uma estrutura para representar uma fila de prioridade máxima. Copie o conteúdo de <code>Heap.hs</code> para <code>MaxHeap.hs</code>. Além de renomear o módulo do arquivo adequadamente, note que apenas uma função de <code>MaxHeap.hs</code> precisa sofrer alterações.</p>
<p>Agora que temos implementações para filas de prioridade mínima e máxima, vamos aprovietá-las e criar uma fila de prioridade mediana. A finalidade de tal estrutura de dados é permitir acesso em tempo constante à mediana de um conjunto de elementos, mesmo que esse conjunto sofra alterações. Por simplicidade, consideramos que, dada uma lista <code>xs</code> de <span class="math inline">\(n\)</span> elementos, sua mediana é o <span class="math inline">\(\lceil\frac{n}{2}\rceil\)</span>-ésimo elemento de uma versão ordenada de <code>xs</code>.</p>
<p>Dada uma lista inicial <code>xs</code> de <span class="math inline">\(n\)</span> elementos do tipo <code>(k, v)</code>, com <code>k</code> ordenável, vamos criar um algoritmo <code>median :: Ord k =&gt; [(k, v)] -&gt; Maybe (k, v)</code>, que encontra a mediana de <code>xs</code> (de acordo com <code>k</code>) em tempo linear, no caso médio. O algoritmo que <code>median</code> implementa é o <em>quickselect</em>, inspirado nas mesmas ideias do <em>quicksort</em>. Para implementá-lo, <code>filter</code> é bastante útil.</p>
<p>Uma vez determinada a mediana de <code>xs</code>, digamos <code>m</code>, dividimos <code>xs</code> em duas listas: a dos elementos menores ou iguais a <code>m</code> (<code>ps</code>) e a dos elementos maiores que <code>m</code> (<code>qs</code>). Por fim, criamos uma fila de prioridade máxima (mínima) com os elementos de <code>ps</code> (<code>qs</code>).</p>
<p>Após isso tudo, obtemos duas filas de prioridade: a máxima agrupa os elementos com prioridade menor ou igual a da mediana; a mínima agrupa os elementos com prioridade superior a da mediana. Perceba que a diferença entre as quantidades de elementos em cada fila de prioridade é no máximo um: se <span class="math inline">\(n\)</span> é par, as duas <em>heaps</em> têm o mesmo número de elementos; se <span class="math inline">\(n\)</span> é ímpar, a <em>heap</em> máxima tem exatamente um elemento a mais que a <em>heap</em> mínima.</p>
<p>A ideia principal dessa estrutura de dados está no fato de que, ao inserir ou remover exatamente um elemento do conjunto representado, ou o “sucessor” ou o “antecessor” da mediana torna-se a nova mediana. O “antecessor” (“sucessor”) é indicado como o elemento mais prioritário da <em>heap</em> máxima (mínima).</p>
<p>Quando queremos tomar a mediana, escolhemos sempre o elemento mais prioritário da <em>heap</em> com mais elementos. Em caso de empate, preferimos o elemento mais prioritário da <em>heap</em> máxima. Aqui, fica claro que é preciso armazenar, além das <em>heaps</em>, a quantidade de elementos de cada uma.</p>
<p>Ao inserirmos um elemento <code>x</code>, fazemos a inserção de acordo com a relação entre <code>x</code> e a mediana atual <code>m</code>: se <code>x</code> tem mais prioridade que <code>m</code>, inserimos <code>x</code> na <em>heap</em> mínima; do contrário, inserimos <code>x</code> na <em>heap</em> máxima.</p>
<p>Sempre que é feita uma alteração na estrutura de dados, é preciso rebalancear as <em>heaps</em> caso uma tenha pelo menos dois elementos a mais que a outra. Isso é feito removendo o elemento mais prioritário da <em>heap</em> com mais elementos, e inserindo-o na outra <em>heap</em>. A quantidade de vezes que essa operação deve ser feita pode ser controlada com o uso de recursão.</p>
<p>É esperado que sejam implementadas as operações <code>fromList</code>, <code>lookup</code>, <code>insert</code> e <code>pop</code> para essa estrutura de dados. Observe que <code>fromList</code> falha caso receba uma lista vazia. Além dessas, a função auxiliar <code>rebalance</code> deve ser chamada sempre que uma alteração for feita.</p>
<p>Com a estrutura implementada, escreva um programa para testá-la. Podemos trabalhar com elementos de tipo <code>(Int, ())</code>.</p>
<p>Uma ideia seria receber um arquivo com duas linhas, cada uma contendo inteiros separados por um espaço. A estrutura inicial é construída a partir das chaves na primeira linha. Após isso, os elementos da segunda linha são inseridos um por vez. A cada modificação da estrutura, a mediana atual deve ser impressa na tela.</p>
<h2 id="laboratório-8">Laboratório 8</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab8.hs</code>. Por razões que ficarão claras no decorrer desse texto, esperamos receber, como resultado desse laboratório, os arquivos <code>Lab4.hs</code> e <code>Lab8.hs</code>. O conteúdo inicial de <code>Lab8.hs</code> deve ser o seguinte.</p>
<div class="sourceCode" id="cb201" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">IO</span>, print, putStrLn,</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>                <span class="fu">readFile</span>, <span class="fu">writeFile</span>,</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>                <span class="fu">getContents</span>,</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>                (<span class="op">&gt;&gt;=</span>))</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span></code></pre></div>
<p>Nesse laboratório, vamos exercitar uma interação básica com o sistema operacional, que consiste em tratar argumentos da linha de comando. Vamos desenvolver uma série de programas elementares, começando com <code>program1</code>.</p>
<div class="sourceCode" id="cb202" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>program1 <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span></code></pre></div>
<p>Basicamente, <code>program1</code> toma a lista de argumentos e a imprime no terminal. Para compilar, acrescentamos.</p>
<div class="sourceCode" id="cb203" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> program1</span></code></pre></div>
<p>Não escrevemos a assinatura explícita de <code>main</code>, pois ela tem claramente a mesma assinatura de <code>program1</code>. Tente passar argumentos para o executável <code>Lab8</code>. Agora, vamos desenvolver um análogo do comando <code>cat</code>, que imprime o conteúdo de um arquivo de texto no terminal.</p>
<div class="sourceCode" id="cb204" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>program2 <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> <span class="fu">readFile</span> <span class="op">.</span> <span class="fu">head</span> <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>Com o uso de <code>head</code>, é bem simples tratar um único argumento passado pela linha de comando. Faça a alteração devida em <code>main</code> e teste o novo programa. Observe que ele ignora todos, menos o primeiro argumento para ele passado. Note também que ele lança exceções caso não receba argumentos (por conta de <code>head</code>), ou caso seu primeiro argumento não seja um arquivo válido (por conta de <code>readFile</code>). Isso indica que deve haver um jeito melhor de lidar com argumentos.</p>
<p>Como sua primeira tarefa, escreva <code>program3</code>, que imprime o conteúdo de um arquivo de texto passado como argumento, mas antes ordena suas linhas. As funções <code>lines</code>, <code>sortBy</code>, <code>intercalate</code> e <code>concat</code> são úteis para isso. Organizá-las por composição pode ser uma boa ideia.</p>
<p>Agora, vamos criar um programa que copia o conteúdo de um arquivo de texto.</p>
<div class="sourceCode" id="cb205" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program4 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>program4 <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> treatArgs <span class="kw">where</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    treatArgs [from, to] <span class="ot">=</span> <span class="fu">readFile</span> from <span class="op">&gt;&gt;=</span> <span class="fu">writeFile</span> to</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    treatArgs _ <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;You must pass exactly two arguments.&quot;</span></span></code></pre></div>
<p>Verifique a assinatura de <code>writeFile</code> no <code>ghci</code>, afinal é a primeira vez que a vemos. A função <code>treatArgs</code> trata os argumentos usando dois casos: no primeiro, fica claro que esperamos dois argumentos, para ler o conteúdo do arquivo <code>from</code> e escrevê-lo no arquivo <code>to</code>; o segundo caso lida com qualquer outro número de argumentos, informando o usuário sobre o uso correto do programa. Tente copiar o conteúdo de <code>heyjude.txt</code> para <code>teste.txt</code>. Após isso, tente passar diversos números de argumentos. Como <code>writeFile</code> apaga o conteúdo do arquivo antes de escrever seu segundo argumento, não é interessante que <code>to</code> seja o nome de um arquivo existente.</p>
<p>Vamos voltar ao <code>program2</code>. Dissemos que <code>program2</code> é análogo ao comando <code>cat</code>. No entanto, <code>cat</code> e <code>program2</code> se comportam de formas distintas quando não recebem argumentos.</p>
<p>Após verificar isso, sua segunda tarefa é escrever <code>program5</code>, que deve se comportar exatamente igual a <code>cat</code>, seja com zero ou um argumentos. Já devemos ter notado que <code>cat</code> lê sua entrada do teclado quando não tem argumentos. Em Haskell, <code>getContents</code> faz exatamente isso, isto é, retorna uma string “infinita” de coisas que são digitadas no teclado. Para esse programa, <code>treatArgs</code> deve tratar os casos de zero e um argumentos, e invalidar todos os demais casos.</p>
<p>Na nossa terceira tarefa, vamos modificar o conteúdo de <code>Lab4.hs</code>, que foi desenvolvido na Subseção <a href="#lab4" data-reference-type="ref" data-reference="lab4">4.4</a>. Em vez de tratar apenas o conteúdo do arquivo <code>heyjude.txt</code>, nosso programa modificado deve receber exatamente um argumento, que é o nome do arquivo que deve ser tratado.</p>
<p>Por fim, a quarta tarefa consiste em desenvolver <code>program6</code>, que recebe exatamente dois argumentos: uma string <code>str</code> e o nome de um arquivo <code>file</code>. Esse programa deve imprimir apenas as linhas de <code>file</code> que contém <code>str</code> como substring. A função <code>isInfixOf</code>, proposta no Exercício <a href="#exercicioIsInfixOf" data-reference-type="ref" data-reference="exercicioIsInfixOf">Exercício 2</a>, pode ser utilizada para essa filtragem. Feito isso, acrescente um caso em que <code>program6</code> recebe exatamente um argumento, e imprime apenas as linhas digitadas no teclado que tenham <code>str</code> como substring. Temos implementado uma versão (muito) simplificada do comando <code>grep</code>. Inclusive, podemos usar <code>program6</code> em combinação com o <em>pipe</em> do sistema operacional.</p>
<h2 id="laboratório-9">Laboratório 9</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab9.hs</code>. O conteúdo inicial de <code>Lab9.hs</code> deve ser o seguinte.</p>
<div class="sourceCode" id="cb206" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">IO</span>, putStrLn, getLine,</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>                (<span class="op">&lt;$&gt;</span>), (<span class="op">&lt;*&gt;</span>), <span class="fu">pure</span>,</span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>                (<span class="op">*&gt;</span>), (<span class="op">&gt;&gt;=</span>),</span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Char</span>, (<span class="op">==</span>))</span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span></code></pre></div>
<p>Vamos desenvolver um programa que “cadastra” uma senha. Por motivos de verificação, o programa pede que ela seja digitada duas vezes e, enquanto houver divergência, pede novamente.</p>
<p>A primeira coisa de que precisamos é uma função <code>ask :: [Char] -&gt; IO [Char]</code>, que imprime seu argumento na tela e retorna uma linha lida a partir do teclado, dentro de <code>IO</code>. Para construir <code>ask</code>, as funções <code>putStrLn</code>, <code>getLine</code> e <code>(*&gt;)</code> são úteis.</p>
<p>Com <code>ask</code> em mãos, vamos construir <code>getPasswd :: IO ([Char], [Char])</code>, uma ação que retorna um par de strings em <code>IO</code>. A ideia aqui não é tão complicada: precisamos construir um par, mas dentro de <code>IO</code>. O operador <code>(,)</code> constrói pares simples, e podemos aproveitá-lo para construir um par em <code>IO</code>, já que <code>IO</code> é instância de <code>Functor</code> e <code>Applicative</code>. Sabemos que <code>(,) x y</code> constrói um par de tipo <code>(a, b)</code>, desde que <code>x :: a</code> e <code>y :: b</code>. Caso <code>x :: IO a</code> e <code>y :: IO b</code>, como poderíamos usar <code>(,)</code>, <code>(&lt;$&gt;)</code> e <code>(&lt;*&gt;)</code> para construir <code>IO (a, b)</code>? Respondida a pergunta, basta fazer com que <code>x</code> e <code>y</code> sejam duas chamadas de <code>ask</code>, com strings que avisem o usuário se é a primeira (<code>x</code>) ou segunda (<code>y</code>) vez que estão digitando a senha.</p>
<p>Temos implementado <code>getPasswd</code>, mas ainda precisamos validar se as duas strings digitadas são iguais. Fazemos isso em <code>validPasswd</code>, uma ação recursiva que termina apenas ao receber duas strings idênticas. Sua implementação é dada a seguir.</p>
<div class="sourceCode" id="cb207" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="ot">validPasswd ::</span> <span class="dt">IO</span> [<span class="dt">Char</span>]</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>validPasswd <span class="ot">=</span> getPasswd <span class="op">&gt;&gt;=</span> f <span class="kw">where</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    f (p1, p2) <span class="ot">=</span> cond (p1 <span class="op">==</span> p2)</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>                      (<span class="fu">pure</span> p1)</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>                      (incorrect <span class="op">*&gt;</span> validPasswd)</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    incorrect <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;They don&#39;t match! Try again.&quot;</span></span></code></pre></div>
<p>Agora que sabemos como obter uma senha válida, implemente <code>main :: IO ()</code> e teste seu programa. Mas o laboratório ainda não acabou.</p>
<p>Em <code>Data.Char</code>, existem alguns predicados muito úteis, que testam se um <code>Char</code> é um certo tipo de caractere, como letra minúscula, maiúscula ou dígito. Dizemos que uma senha é forte se ela tem pelo menos oito caracteres e há, dentre eles, uma letra minúscula, uma maiúscula e um dígito. Escreva uma função <code>isStrong :: [Char] -&gt; Bool</code>, que determina se uma senha é forte.</p>
<p>Uma vez implementada <code>isStrong</code>, escreva a ação <code>strongPasswd :: IO [Char]</code>, que utiliza <code>validPasswd</code> para obter senhas válidas e retorna, dentro de <code>IO</code>, a primeira que seja forte. A definição de <code>validPasswd</code> é um bom modelo para <code>strongPasswd</code>.</p>
<p>Adapte sua <code>main</code> e teste seu programa. Agora sim o laboratório acabou.</p>
<h2 id="laboratório-10">Laboratório 10</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab10.hs</code>. O conteúdo inicial de <code>Lab10.hs</code> deve ser o seguinte.</p>
<div class="sourceCode" id="cb208" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Ord</span>, (&lt;=), (&gt;=), (-), <span class="dt">Bool</span>,</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, <span class="fu">putStrLn</span>, (<span class="op">&lt;$&gt;</span>), <span class="fu">pure</span>, (<span class="op">&lt;*&gt;</span>))</span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Maybe</span></span></code></pre></div>
<p>Neste laboratório, vamos resolver o problema da maior subsequência crescente, ou <em>longest increasing subsequence</em>. Dada uma sequência de naturais, gostaríamos de encontrar a maior subsequência crescente dessa sequência. Por exemplo, dada a sequência <span class="math inline">\(10, 22, 9, 33, 21, 50, 41, 60, 80\)</span>, sua maior subsequência crescente é <span class="math inline">\(10, 22, 33, 41, 60, 80\)</span>.</p>
<p>Primeiro, desenvolva <code>maximum :: Ord a =&gt; [a] -&gt; Maybe a</code>, que retorna o maior elemento de uma lista, caso ela não seja vazia. Basta usar <code>foldl</code> e <code>(&lt;=)</code>. No entanto, precisaremos fazer uso de uma versão genérica de <code>maximum</code>. Para tanto, implemente a função <code>maximalBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; Maybe a</code>, de tal forma que <code>maximalBy (&gt;=)</code> seja equivalente a <code>maximum</code>.</p>
<p>Agora, vamos criar uma solução ingênua para o problema em vista. Dada uma sequência de <span class="math inline">\(n\)</span> naturais <span class="math inline">\(x_0, x_1, \dots, x_{n - 1}\)</span>, criamos a seguinte notação: <span class="math inline">\(s_i\)</span> representa a maior subsequência crescente começando com <span class="math inline">\(x_i\)</span>, para <span class="math inline">\(0 \leq i \leq n - 1\)</span>.</p>
<p>Podemos definir <span class="math inline">\(s\)</span> em termos de si mesma: claramente, <span class="math inline">\(s_{n - 1}\)</span> é uma sequência unitária contendo <span class="math inline">\(x_{n - 1}\)</span>; para <span class="math inline">\(0 \leq i \leq n - 2\)</span>, <span class="math inline">\(s_i\)</span> começa com <span class="math inline">\(x_i\)</span>, e pode seguir com os elementos de <span class="math inline">\(s_j, i &lt; j \leq n - 1\)</span>, desde que <span class="math inline">\(x_i \leq x_j\)</span>. Certamente, definimos <span class="math inline">\(s_i\)</span> utilizando, dentre todos os <span class="math inline">\(s_j\)</span> possíveis, aquele que represente a maior subsequência. Por fim, é fácil escolher a maior subsequência crescente dentre os <span class="math inline">\(s_i, 0 \leq i \leq k - 1\)</span>. Essa solução pode ser implementada da seguinte forma.</p>
<div class="sourceCode" id="cb209" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lis ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>lis [] <span class="ot">=</span> []</span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>lis [x] <span class="ot">=</span> [x]</span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a>lis xs <span class="ot">=</span> fromMaybe [] (maximalBy cmp (s <span class="op">&lt;$&gt;</span> [<span class="dv">0</span><span class="op">..</span>n <span class="op">-</span> <span class="dv">1</span>] <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> xs)) <span class="kw">where</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">=</span> <span class="fu">length</span> xs</span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>    cmp ps qs <span class="ot">=</span> <span class="fu">length</span> ps <span class="op">&gt;=</span> <span class="fu">length</span> qs</span>
<span id="cb209-7"><a href="#cb209-7" aria-hidden="true" tabindex="-1"></a>    s <span class="dv">0</span> [] <span class="ot">=</span> []</span>
<span id="cb209-8"><a href="#cb209-8" aria-hidden="true" tabindex="-1"></a>    s <span class="dv">0</span> [y] <span class="ot">=</span> [y]</span>
<span id="cb209-9"><a href="#cb209-9" aria-hidden="true" tabindex="-1"></a>    s <span class="dv">0</span> (y<span class="op">:</span>ys) <span class="ot">=</span> y <span class="op">:</span> ms <span class="kw">where</span></span>
<span id="cb209-10"><a href="#cb209-10" aria-hidden="true" tabindex="-1"></a>        candidates <span class="ot">=</span> <span class="fu">filter</span> ((y<span class="op">&lt;=</span>) <span class="op">.</span> <span class="fu">head</span>) <span class="op">$</span> s <span class="op">&lt;$&gt;</span> [<span class="dv">0</span><span class="op">..</span>k <span class="op">-</span> <span class="dv">1</span>] <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> ys</span>
<span id="cb209-11"><a href="#cb209-11" aria-hidden="true" tabindex="-1"></a>        k <span class="ot">=</span> <span class="fu">length</span> ys</span>
<span id="cb209-12"><a href="#cb209-12" aria-hidden="true" tabindex="-1"></a>        ms <span class="ot">=</span> fromMaybe [] <span class="op">$</span> maximalBy cmp candidates</span>
<span id="cb209-13"><a href="#cb209-13" aria-hidden="true" tabindex="-1"></a>    s i ys <span class="ot">=</span> s <span class="dv">0</span> <span class="op">$</span> <span class="fu">drop</span> i ys</span></code></pre></div>
<p>Em um primeiro momento, a função <code>s</code> parece receber mais argumentos que o necessário, afinal <span class="math inline">\(s\)</span> é indexada apenas por <span class="math inline">\(0 \leq i \leq n - 1\)</span>. No entanto, receber a lista como segundo argumento nos permite tratar o caso referente a <span class="math inline">\(s_i\)</span>, para algum <span class="math inline">\(0 &lt; i \leq n - 1\)</span>, com <code>drop</code>.</p>
<p>Uma outra coisa interessante de se notar é <code>candidates</code>. Note que <code>candidates</code> parece estar fazendo <code>s</code> tratar sobre subsequências de outras listas além de <code>xs</code>. Na verdade não está, mas da forma como <code>candidates</code> se comporta, os índices passados para <code>s</code> podem referir-se a posições em sufixos de <code>xs</code>, e assim não podem ser interpretados de maneira absoluta, como os índices de <span class="math inline">\(s\)</span>.</p>
<p>Bem, a implementação de <code>lis</code> apresentada está correta, mas é extremamente ineficiente. É preciso utilizar <code>memo</code> e <code>fix</code> para criar uma <em>cache</em> para <code>s</code>. No entanto, há um obstáculo: <code>memo</code> espera receber uma função <code>Int -&gt; b</code>, e essa não é a assinatura de <code>s</code>.</p>
<p>O objetivo final desse laboratório é reescrever <code>lis</code> de forma que <code>s</code> tenha assinatura <code>Int -&gt; [a]</code>, para em seguida criar uma <em>cache</em> para <code>s</code>.</p>
<h2 id="laboratório-11">Laboratório 11</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab11.hs</code>. O conteúdo inicial de <code>Lab11.hs</code> deve ser o seguinte.</p>
<div class="sourceCode" id="cb210" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Char</span>, <span class="dt">Int</span>, (==),</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, <span class="fu">putStrLn</span>, (<span class="op">&lt;$&gt;</span>))</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Bool</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span></code></pre></div>
<p>Neste laboratório, vamos construir definições para trabalhar com autômatos finitos não-determinísticos. Para isso, vamos usar o seguinte tipo.</p>
<div class="sourceCode" id="cb211" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Transition</span> <span class="ot">=</span> (<span class="dt">State</span>, <span class="dt">Char</span>, <span class="dt">State</span>)</span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NFA</span> <span class="ot">=</span> <span class="dt">NFA</span> [<span class="dt">State</span>] <span class="dt">State</span> [<span class="dt">Transition</span>] [<span class="dt">State</span>]</span></code></pre></div>
<p>Em <code>NFA</code>, o primeiro campo representa o conjunto de estados do autômato, enquanto o segundo representa seu estado corrente. Isso difere um pouco da definição usual de autômato, mas facilita a implementação. Já o terceiro campo é a lista de transições do autômato, enquanto o quarto representa seu conjunto de estados finais. Além disso, definimos uma série de funções auxiliares para esse tipo.</p>
<div class="sourceCode" id="cb212" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nfa ::</span> [<span class="dt">State</span>] <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> [<span class="dt">Transition</span>] <span class="ot">-&gt;</span> [<span class="dt">State</span>] <span class="ot">-&gt;</span> <span class="dt">NFA</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>nfa states s trs finals <span class="ot">=</span> <span class="dt">NFA</span> states s trs finals</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a><span class="ot">states ::</span> <span class="dt">NFA</span> <span class="ot">-&gt;</span> [<span class="dt">State</span>]</span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>states (<span class="dt">NFA</span> states _ _ _) <span class="ot">=</span> states</span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a><span class="ot">currentState ::</span> <span class="dt">NFA</span> <span class="ot">-&gt;</span> <span class="dt">State</span></span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>currentState (<span class="dt">NFA</span> _ s _ _) <span class="ot">=</span> s</span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a><span class="ot">transitions ::</span> <span class="dt">NFA</span> <span class="ot">-&gt;</span> [<span class="dt">Transition</span>]</span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>transitions (<span class="dt">NFA</span> _ _ trs _) <span class="ot">=</span> trs</span>
<span id="cb212-12"><a href="#cb212-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-13"><a href="#cb212-13" aria-hidden="true" tabindex="-1"></a><span class="ot">finalStates ::</span> <span class="dt">NFA</span> <span class="ot">-&gt;</span> [<span class="dt">State</span>]</span>
<span id="cb212-14"><a href="#cb212-14" aria-hidden="true" tabindex="-1"></a>finalStates (<span class="dt">NFA</span> _ _ _ finals) <span class="ot">=</span> finals</span></code></pre></div>
<p>Com elas, podemos definir uma função que faz o autômato “consumir” um caractere. Em nossa representação desse conceito, o autômato não vai mudar de estado, e sim produzir novos autômatos, cada um deles representando o resultado de uma possível transição.</p>
<div class="sourceCode" id="cb213" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="ot">transition ::</span> <span class="dt">NFA</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">NFA</span>]</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>transition aut c <span class="ot">=</span> f <span class="op">&lt;$&gt;</span> nextStates <span class="kw">where</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>  validTransitions <span class="ot">=</span> <span class="fu">filter</span> valid (transitions aut)</span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>  valid (st, c&#39;, _) <span class="ot">=</span> <span class="fu">and</span> [st <span class="op">==</span> (currentState aut), c&#39; <span class="op">==</span> c]</span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>  nextStates <span class="ot">=</span> thd <span class="op">&lt;$&gt;</span> validTransitions</span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>  thd (_, _, z) <span class="ot">=</span> z</span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>  f st <span class="ot">=</span> nfa (states aut) st (transitions aut) (finalStates aut)</span></code></pre></div>
<p>Para prosseguir com as atividades do laboratório, faça a implementação de duas funções: <code>isAccepting :: NFA -&gt; Bool</code> e <code>run :: NFA -&gt; [Char] -&gt; Bool</code>. Enquanto a primeira função deixa claro o seu propósito, a segunda deve fazer um autômato consumir uma lista de caracteres, e no fim determinar se essa foi aceita pelo autômato. Para facilitar a escrita, recomendamos a implementação de <code>foldM</code>, proposta no Exercício <a href="#exercicio:foldM" data-reference-type="ref" data-reference="exercicio:foldM">Exercício 45</a>. Como a lista representa não-determinismo enquanto mônada, <code>run</code> pode ser escrita em termos de <code>foldM</code>. Observe bem a assinatura de <code>transition</code>.</p>
<p>Por fim, crie dois autômatos, utilizando o arcabouço aqui desenvolvido. O primeiro autômato deve aceitar representações binárias de números pares, enquanto o segundo aceita strings binárias que tenham <span class="math inline">\(010\)</span> como substring. Perceba que, em ambos os casos, quaisquer outros valores de <code>Char</code> devem implicar na rejeição da string.</p>
<h2 id="laboratório-12">Laboratório 12</h2>
<p>Desenvolva as atividades a seguir. Salve suas funções em um arquivo <code>Lab12.hs</code>. O conteúdo inicial de <code>Lab12.hs</code> deve ser o seguinte.</p>
<div class="sourceCode" id="cb214" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, (+), (^),</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>                <span class="dt">IO</span>, (<span class="op">&gt;&gt;=</span>),</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>                <span class="fu">print</span>, <span class="fu">read</span>)</span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Functions</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">List</span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a><span class="ot">sum&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>sum&#39; <span class="ot">=</span> foldl&#39; (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> \[kstr] <span class="ot">-&gt;</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>       <span class="fu">print</span> <span class="op">$</span> sum&#39; (xs <span class="op">$</span> <span class="fu">read</span> kstr)</span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb214-20"><a href="#cb214-20" aria-hidden="true" tabindex="-1"></a>xs k <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">+</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span>k] [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span><span class="op">^</span>k]</span></code></pre></div>
<p>Além do código que deve ser desenvolvido, é esperada a entrega de uma planilha contendo os tempos de execução do programa, de acordo com dois parâmetros: o tamanho da entrada, dado por <code>k</code>; o argumento passado para <code>parChunks</code> (o tamanho dos “pedaços” em que se divide a lista).</p>
<p>Compile esse programa com <code>ghc -O2 -threaded Lab12 -W</code>. Estabeleça alguns valores de <code>k</code> com os quais serão realizados testes. Inicialmente, use o comando <code>time ./Lab12 k +RTS -N1</code> para verificar o tempo (<code>real</code>) de execução serial para esses valores de <code>k</code>.</p>
<p>Observamos que há duas oportunidades de paralelização nesse programa. A primeira consiste em avaliar os “pedaços” de <code>xs</code> em paralelo. A segunda consiste em aplicar <code>sum’</code> a cada “pedaço”, e em seguida somar os resultados parciais. Estabeleça alguns valores para o argumento de <code>parChunks</code>, com os quais serão realizados testes.</p>
<p>A partir de agora, utilize o comando <code>time ./Lab12 k +RTS -Nc</code> para realizar os testes. Nesse comando, <code>k</code> controla o tamanho da entrada, enquanto <code>c</code> é o número de <em>cores</em> do seu computador.</p>
<p>Implemente a primeira abordagem. Realize testes para as combinações de valores estabelecidos. Faça o mesmo para a segunda abordagem. Em seguida, utilize as duas abordagens simultaneamente.</p>
<p>Monte uma planilha com os tempos de execução <code>real</code> coletados, e calcule os <em>speedups</em> obtidos (que também devem constar na planilha). Lembre-se que o <em>speedup</em> é dado pelo tempo de execução serial sobre o tempo de execução paralelo. Não esqueça de fechar a maior parte dos programas durante os testes.</p>
<h1 id="trabalhos-práticos">Trabalhos práticos</h1>
<p>Nesta seção, descrevemos os trabalhos práticos de cada Avaliação Parcial. É esperado que haja uma subseção para cada Avaliação Parcial. Na presente versão da disciplina, deve haver três subseções.</p>
<h2 id="trabalho-1">Trabalho 1</h2>
<p>Descrevemos alguns problemas que devem ser resolvidos e implementados.</p>
<h3 id="problema-1">Problema 1</h3>
<p>Uma agência de crédito emite cartões de crédito, cada um identificado por uma sequência de dez dígitos: os oito primeiros são significativos e os dois últimos são verificadores. Os dois dígitos verificadores representam a soma dos oito primeiros dígitos.</p>
<p>Escreva uma função <code>addSum</code> que, dada uma string de oito dígitos, adiciona ao seu final os dois dígitos verificadores. Você vai precisar transformar cada dígito da string de entrada em um inteiro (pode ser interessante definir <code>getDigit :: Char -&gt; Int</code>, com o auxílio de <code>read</code>), e em seguida somá-los e transformar o resultado em uma string (usar <code>show</code> é muito útil).</p>
<p>Escreva uma função <code>valid</code> que, dada uma string de dez dígitos, verifica se ela é um identificador válido de um cartão. Isso é bem simples quando se usa a função <code>take</code>.</p>
<h3 id="problema-2">Problema 2</h3>
<p>A primeira parte desse problema, que será útil para a segunda, consiste em implementar a função <code>until :: (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a</code>. A função <code>until</code> recebe duas funções: a primeira é um predicado <code>p</code>, e a segunda é uma função <code>f</code> que transforma elementos do tipo <code>a</code>. Além disso, ela recebe um elemento <code>x</code> do tipo <code>a</code>. Se <code>x</code> satisfaz o predicado <code>p</code>, então <code>until</code> retorna <code>x</code>. Caso contrário, <code>until</code> testa, recursivamente, o predicado <code>p</code> para <code>f x</code>. É bastante simples implementar <code>until</code> com o auxílio de <code>iterate</code>, proposta no Exercício <a href="#exercicio:iterate" data-reference-type="ref" data-reference="exercicio:iterate">Exercício 10</a>.</p>
<p>Agora, vamos implementar a raiz quadrada. Você pode usar o seguinte template.</p>
<div class="sourceCode" id="cb215" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span><span class="ot"> ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span> x <span class="ot">=</span> <span class="fu">until</span> goodEnough improve x <span class="kw">where</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    goodEnough y <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>    improve y <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Para implementar <code>goodEnough</code>, determine se o valor absoluto de <code>y*y</code> está suficientemente próximo de <code>x</code>. Sugerimos uma precisão de seis casas decimais.</p>
<p>Para implementar <code>improve</code>, pode ser útil pesquisar por alguma fórmula baseada no método de Newton (ou no método da secante).</p>
<h3 id="problema-3">Problema 3</h3>
<p>A definição indutiva dos números naturais diz que há um primeiro número natural, digamos zero, e que cada um dos outros é obtido aplicando-se uma certa função injetora a algum natural. Essa função é chamada de <em>sucessora</em>, e zero é sucessor de nenhum natural. Isso é suficiente para determinar que os números naturais formam um conjunto infinito.</p>
<p>Com base nessa definição, podemos implementar os naturais da seguinte forma.</p>
<div class="sourceCode" id="cb216" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Suc</span> <span class="dt">Nat</span></span></code></pre></div>
<p>Faça de <code>Nat</code> uma instância da classe <code>Eq</code> (basta implementar <code>(==)</code>). Faça de <code>Nat</code> uma instância da classe <code>Ord</code> (basta implementar <code>(&lt;=)</code>). Escreva as funções <code>natToInt :: Nat -&gt; Int</code> e <code>intToNat :: Int -&gt; Nat</code> e verifique se os comparadores estão funcionando corretamente.</p>
<h2 id="trabalho-2">Trabalho 2</h2>
<p>Dado um conjunto de símbolos <span class="math inline">\(S\)</span>, uma codificação <span class="math inline">\(c : S \to \{0, 1\}^*\)</span> é uma função bijetora que atribui a cada símbolo uma sequência de valores binários. Uma codificação livre de prefixos tem a seguinte propriedade: <span class="math inline">\(c(s_1)\)</span> não é prefixo de <span class="math inline">\(c(s_2)\)</span>, para quaisquer <span class="math inline">\(s_1, s_2 \in S\)</span>.</p>
<p>Vamos admitir que cada símbolo de <span class="math inline">\(S\)</span> é formado por uma sequência de valores binários. Dado <span class="math inline">\(s \in S\)</span>, <span class="math inline">\(|s|\)</span> representa o comprimento da sequência de <em>bits</em> que forma <span class="math inline">\(s\)</span>.</p>
<p>Se conhecemos <span class="math inline">\(c : S \to \{0, 1\}^*\)</span> tal que, para cada <span class="math inline">\(s \in S\)</span>, <span class="math inline">\(|c(s)| \leq |s|\)</span>, então uma sequência de símbolos <span class="math inline">\(s_1s_2\dots s_k\)</span> seria representada mais eficientemente como <span class="math inline">\(c(s_1)c(s_2)\dots c(s_k)\)</span>. No entanto, esperamos que os símbolos de <span class="math inline">\(S\)</span> não admitam tal codificação. Uma vez que admitissem, passaríamos a representar <span class="math inline">\(s\)</span> por <span class="math inline">\(c(s)\)</span>, para todo <span class="math inline">\(s \in S\)</span>. Com isso, estamos supondo que a representação dos símbolos em <span class="math inline">\(S\)</span> é a mais eficiente possível. Via de regra, se <span class="math inline">\(|S| \leq 2^l\)</span>, precisamos de no máximo <span class="math inline">\(l\)</span> <em>bits</em> para a representação de cada símbolo de <span class="math inline">\(S\)</span>.</p>
<p>Então, dada uma sequência de símbolos <span class="math inline">\(s_1s_2 \dots s_k\)</span> de <span class="math inline">\(S\)</span>, concatenar as representações dos símbolos é a maneira mais eficiente de represnetar a sequência? Não necessariamente. Pode ser que, nessa sequência em particular, um símbolo <span class="math inline">\(\overline{s}\)</span> ocorra muito mais que outro <span class="math inline">\(\tilde{s}\)</span>. Nesse caso, seria interessante que <span class="math inline">\(\overline{s}\)</span> tivesse uma representação menor que <span class="math inline">\(\tilde{s}\)</span>.</p>
<p>Vamos admitir que, dado o conteúdo de um arquivo de texto, queremos criar uma codificação para suas palavras, associando às palavras mais frequentes as menores sequências binárias possíveis. Utilizando funções já escritas em laboratório, sabemos construir uma <code>BSTree</code> que associa a cada palavra sua quantidade de ocorrências.</p>
<p>Vamos criar o seguinte tipo, que representa uma <em>codificação de Huffman</em>.</p>
<div class="sourceCode" id="cb217" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HuffmanTree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">Branch</span> (<span class="dt">HuffmanTree</span> a) (<span class="dt">HuffmanTree</span> a)</span></code></pre></div>
<p>Vamos usar esse tipo para representar as palavras de um arquivo de texto como suas folhas. Cada folha tem sua codificação representada pelo seu caminho a partir da raiz da árvore: descer para a esquerda (direita) representa <span class="math inline">\(0\)</span> (<span class="math inline">\(1\)</span>).</p>
<p>Para construir a <code>HuffmanTree</code>, criamos, para cada palavra <code>w</code>, um par <code>(nw, w)</code>, onde <code>nw</code> representa o número de ocorrências de <code>w</code>. Isso pode ser feito com um passeio em uma <code>BSTree</code>. Em seguida, criamos uma <code>Heap</code> (mínima) onde os elementos são, para cada palavra <code>w</code>, <code>Leaf w</code> com prioridade <code>nw</code>.</p>
<p>Agora, o algoritmo de Huffman é bem simples: enquanto for possível retirar dois elementos da <code>Heap</code>, digamos <code>(n1, t1)</code> e <code>(n2, t2)</code>, retire-os e insira <code>(n1 + n2, Branch t1 t2)</code>. Quando houver exatamente um elemento na <code>Heap</code>, esse estará representando a codificação de Huffman das palavras de acordo com seu número de ocorrências.</p>
<p>Com isso, podemos substituir cada palavra do arquivo pela codificação dada pela <code>HuffmanTree</code>. Para tanto, é interessante criar uma função <code>encoding</code> que, dada uma <code>HuffmanTree</code>, retorna a codificação associada a cada uma de suas folhas. Poderíamos, por fim, usar <code>encoding</code> para criar uma <code>BSTree</code>, digamos <code>encodingTree</code>, que associa cada palavra à sua codificação, e usá-la para substituir cada palavra do arquivo pela codificação associada. Lembre-se que, como uma codificação de Huffman é livre de prefixos, não precisamos separar as codificações com espaços, e assim economizamos um pouco mais de memória.</p>
<p>É esperado que, nesse momento, estejamos aptos a, dado um arquivo de texto como entrada, criar um arquivo de texto codificado como saída que também contém a codificação usada. Podemos organizar o arquivo de saída da seguinte forma: a primeira linha contém o conteúdo codificado do arquivo de entrada; cada uma das linhas seguintes tem uma sequência binária e sua palavra correspondente.</p>
<p>Para facilitar a implementação, crie um executável capaz de codificar o conteúdo do arquivo <code>input.txt</code>, produzindo o arquivo <code>output.txt</code>. Agora, vamos tratar de recuperar o conteúdo original do arquivo.</p>
<p>Além de criar <code>encodingTree</code>, é interessante criar <code>decodingTree</code>, uma <code>BSTree</code> chaveada pelas codificações e valorada pelas palavras. Com ela, estamos aptos a criar <code>decode</code>, que recebe uma codificação e retorna a palavra associada. Antes de poder usar <code>decode</code> em um conteúdo codificado (que seria uma sequência enorme de valores binários), precisamos saber separar seu conteúdo.</p>
<p>Vamos agora criar <code>isValid</code>, que determina se uma sequência binária é uma codificação válida, isto é, verifica se é uma chave de <code>decodingTree</code>. Com ela e <code>inits</code>, vamos poder determinar o menor prefixo de uma sequência binária que é uma codificação válida, e usamos isso para criar <code>encodingSplit</code>, que dada uma sequência binária, retorna-a particionada em codificações válidas. Por fim, temos apenas o trabalho de substituir cada codificação pela palavra correspondente, intercalar a lista resultante com espaços e concatenar as strings dessa lista.</p>
<p>Nesse momento, esperamos estar aptos a, dado um arquivo codificado (como o produzido acima) como entrada, decodificar o conteúdo de sua primeira linha a partir da codificação descrita pelas demais linhas, e imprimir o conteúdo decodificado no terminal. Para simplificar a implementação, crie um executável capaz de decodificar <code>output.txt</code>.</p>
<h2 id="trabalho-3">Trabalho 3</h2>
<p>Nos trabalhos práticos dessa Avaliação Parcial, cada grupo de alunos deve escolher um, e somente um, dos temas listados abaixo, ou sugerir seu próprio tema. Cada grupo de alunos deve desenvolver um programa com características de paralelismo que atenda a proposta do seu tema.</p>
<p>Em cada um dos temas, é esperado que, além do desenvolvimento do programa, seja também elaborada uma análise do tempo de execução e do <em>speedup</em>, de acordo com os seguintes parâmetros: tamanho da entrada; número de <em>cores</em> utilizados (controlado com o parâmetro <code>-N</code>); primeiro argumento de <code>parChunks</code> (quando utilizada). Fica a critério do grupo de alunos decidir se tal análise será apresentada em forma de gráficos ou tabelas.</p>
<p>Para fins de consistência, aconselhamos que todos os programas desenvolvidos nesse contexto sejam compilados com o seguinte comando. Nele, <code>Program.hs</code> representa o nome do arquivo desenvolvido.</p>
<div class="sourceCode" id="cb218" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>ghc <span class="op">-</span><span class="dt">O2</span> <span class="op">-</span>threaded Program.hs</span></code></pre></div>
<p>Esperamos também que os testes sejam feitos com o seguinte comando. Nele, <code>k</code> representa o número de <em>threads</em> a serem utilizadas pelo programa. Lembramos que <code>real</code> é o tempo que deve ser considerado.</p>
<div class="sourceCode" id="cb219" data-bgcolor="bg"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>time <span class="op">./</span><span class="dt">Program</span> <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">Nk</span></span></code></pre></div>
<p>Sugerimos que, para obtenção de bons resultados, os testes concorram com o menor número possível de outros programas. Assim, é bom fechar o navegador e o editor de texto antes de realizar um teste.</p>
<h3 id="tema-1">Tema 1</h3>
<p>Nesse tema, devem ser desenvolvidas operações elementares de Álgebra Linear, como soma, subtração e multiplicação de matrizes, assim como soma, subtração e produto interno de vetores. Tais operações oferecem muitas oportunidades de paralelismo.</p>
<p>Por exemplo, podemos imaginar a soma <span class="math inline">\(A + B\)</span> de duas matrizes <span class="math inline">\(A, B \in \mathbb{R}^{m
  \times n}\)</span> dividida em <span class="math inline">\(m\)</span> (<span class="math inline">\(n\)</span>) tarefas, onde cada tarefa realiza a soma de duas linhas (colunas) correspondentes de <span class="math inline">\(A\)</span> e <span class="math inline">\(B\)</span>. Com isso, podemos usar <code>parChunks</code> para realizar grupos dessas tarefas em paralelo.</p>
<p>Observamos que, para a multiplicação de matrizes, é interessante que uma das matrizes esteja representada por suas linhas, enquanto a outra esteja representada por suas colunas. Assim, faz-se necessário desenvolver funções que convertam matrizes entre essas representações.</p>
<h3 id="tema-2">Tema 2</h3>
<p>Aqui, deve ser desenvolvida uma função que, dada uma lista <code>x:xs</code> sem elementos repetidos, retorna uma lista com todos os subconjuntos de <code>x:xs</code>. Uma vez construídos os subconjuntos da cauda <code>xs</code>, é preciso realizar as tarefas de duplicar cada um deles, e acrescentar <code>x</code> em uma das cópias. Note que essas são tarefas que podem ser paralelizadas, mas são muito baratas, e assim não conseguem justificar o custo do <em>runtime system</em>. Seria possível, mesmo assim, desenvolver uma forma de paralelizá-las que resulte em ganhos no tempo de execução?</p>
<h3 id="tema-3">Tema 3</h3>
<p>Podemos aproximar o cálculo de uma integral <span class="math inline">\(\int_a^b f(x) dx\)</span> através de uma quadratura, como a regra do trapézio ou a regra de Simpson, cujas fórmulas são fáceis de implementar. No entanto, aplicar diretamente essas quadraturas pode resultar em uma aproximação não muito boa, principalmente se <span class="math inline">\(|b - a|\)</span> for um valor muito alto. Com a propriedade <span class="math inline">\(\int_a^b f(x) dx = \int_a^c f(x) dx + \int_c^b f(x) dx\)</span>, para algum <span class="math inline">\(c \in [a, b]\)</span>, podemos ver a integral em um certo intervalo <span class="math inline">\([a, b]\)</span> como a soma das integrais em subintervalos que particionam <span class="math inline">\([a,
b]\)</span>, e essas podem ser aproximadas em paralelo. Note que essas tarefas são muito baratas para, individualmente, compensar o <em>overhead</em> do <em>runtime system</em>.</p>
<p>Assim, deve ser desenvolvida uma função que toma quatro argumentos: um integrando <code>Double -&gt; Double</code>, uma quadratura (que também é uma função), um intervalo de integração <code>(Double, Double)</code> e um número <code>k</code> de subintervalos. Essa função deve particionar o intervalo recebido em <code>k</code> subintervalos, e aplicar a quadratura a cada um deles, de forma paralela.</p>
<h3 id="tema-4">Tema 4</h3>
<p>Considere a função <code>mergesort</code>, proposta na Subseção <a href="#lab3" data-reference-type="ref" data-reference="lab3">4.3</a>. Desenvolva duas versões paralelizadas de <code>mergesort</code>.</p>
<p>Na primeira versão, “quebre” a lista em sublistas, ordene-as em paralelo, e faça as operações de <code>merge</code> também em paralelo. Note que a eficiência dessa abordagem está relacionada com o tamanho das sublistas que se toma.</p>
<p>Na segunda versão, crie uma função auxiliar <code>mergesort’</code>, que recebe, além da lista, um segundo argumento que determina a “profundidade” da chamada recursiva. Assim, <code>mergesort xs = mergesort’ xs 0</code>, e <code>mergesort’</code> incrementa seu segundo argumento para suas chamadas recursivas. Com isso, pode-se determinar, de acordo com o segundo argumento, se as chamadas recursivas serão realizadas em paralelo ou não. O ideal é que apenas as chamadas recursivas mais “rasas” sejam realizadas em paralelo.</p>
<h3 id="tema-5">Tema 5</h3>
<p>Escolha um dos temas anteriores e o desenvolva na linguagem Scala. O tema deve ser desenvolvido, preferencialmente, evidenciando as facilidades que se obtém ao integrar programação OO com programação funcional. Assim como os outros temas, esse também deve ser desenvolvido usado paralelismo. Observamos também que algumas instruções dadas no começo dessa seção não se aplicam a esse tema.</p>
</body>
</html>
